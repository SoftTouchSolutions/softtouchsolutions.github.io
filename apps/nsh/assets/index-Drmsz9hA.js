const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/App-Bke1WHj_.js","assets/mui-6YGer9Nu.js","assets/vendor-DcOWwNOt.js","assets/index-DRCK5GEP.js","assets/Switcherdata-YIYJ30vT.js","assets/firebase-CMXa_3X0.js","assets/store-DFqh3qej.js","assets/16-Cj3VG8Ln.js","assets/editprofile-CWaPFwGl.js","assets/data-CEwbOx7G.js","assets/4-C6YgBNXp.js","assets/2-D-V5ih7N.js","assets/5-Bf8W3P_a.js","assets/UncontrolledDropdown-ChYO2B-2.js","assets/Collapse-D9rzJkT9.js","assets/logo1-BnyHkmZE.js","assets/favicon-TrKW_Zmf.js","assets/utils-pMlYcaaZ.js","assets/custompages-O_0tnQcQ.js","assets/Switcherapp-Bp-VLfph.js","assets/Dashboard01-9Ho2UgJB.js","assets/index-D8JvFaG3.js","assets/react-apexcharts.esm-CkgSm5Qi.js","assets/12-DCQ8KYQr.js","assets/5-Dpcr_Tz2.js","assets/10-DvLRbf8W.js","assets/2-CzZ0lnvD.js","assets/4-D2jqn9Fg.js","assets/1-BRel2upO.js","assets/award-CariT6ql.js","assets/Dashboard02-DjSDvjG8.js","assets/CardFooter-D9Bpfg9x.js","assets/data-CxQQzp0D.js","assets/3-BGsNsrgF.js","assets/6-CYNIMoC8.js","assets/7-6SzHPYz9.js","assets/8-lww0UeON.js","assets/9-uUt78-1N.js","assets/11-DOVWzwhr.js","assets/13-P8HidYhJ.js","assets/14-D5oivJTg.js","assets/15-M80PxkED.js","assets/Dashboard03-5Jg2HVOO.js","assets/CardTitle-DTApbb8G.js","assets/Dashboard04-yK2LdAZm.js","assets/Dashboard05-i2LEqSF5.js","assets/index-D6-dXmlQ.js","assets/react-select.esm-CaNXbm0e.js","assets/Nav-43SVGHcv.js","assets/NavItem-BawSsbNx.js","assets/NavLink-q9n61eUo.js","assets/TabPane-D1Rqo7q4.js","assets/slick-theme-mGZwkrRL.js","assets/slick-theme-G420z6PA.css","assets/Chat-qG7L5VDN.js","assets/ListGroupItem-C2xqAcTL.js","assets/UncontrolledTooltip-YSmGIrnj.js","assets/TooltipPopoverWrapper-BZlnwhoL.js","assets/Chat02-CVrgYvRI.js","assets/Chat03-DNHcGuEq.js","assets/Contactlist-vvuqguzm.js","assets/Contactlist02-t1vDNlNk.js","assets/FileManager-BLCn_TQF.js","assets/file-yDWqDtJD.js","assets/data-BPmjKXVB.js","assets/word-B4_tjrhl.js","assets/1-CXDQDCif.js","assets/FileManager02-McxPiKnb.js","assets/FileDetails-DfCSmw90.js","assets/14-0pej-tsD.js","assets/4-CUU99mC1.js","assets/6-NgB5q-sK.js","assets/7-oZbLhkCE.js","assets/8-DBQQbcvu.js","assets/9-Cd4JggXr.js","assets/10-8A9hOF9c.js","assets/11-_IJrd_jw.js","assets/thumbnails-y-mndhZy.js","assets/thumbnails-BDLe6cpE.css","assets/fileimage1-Dq_zGUdJ.js","assets/FileAttachments-Bt9SmKI3.js","assets/2-bavdzQaD.js","assets/file2-9Fx0WMPB.js","assets/Todolist-BA-cYKuK.js","assets/TodoList03-g58fDHj7.js","assets/TodoList02-BCuE01T6.js","assets/UserList01-DsDqFqu3.js","assets/UserList02-CSP6F03B.js","assets/data-B2-10s3Q.js","assets/UserList03-D6IKJVw8.js","assets/UserList04-SyNz30ke.js","assets/LeafletMaps-DBA3XJE3.js","assets/SimpleMaps-DzKND3GF.js","assets/Calendar-BbrtElYa.js","assets/Pagesessiontimeout-n-qF9b0z.js","assets/Notifications-BRFA7Jhq.js","assets/PopoverBody-B-UYVGh_.js","assets/ImageCrop-BkO2SwMH.js","assets/23-B5Zg6o7q.js","assets/Rating-OTcfcBVt.js","assets/createSvgIcon-eqKHTxvP.js","assets/TimeLine-XvOYBw4o.js","assets/Loaders-PSZJAhty.js","assets/Counters-C1wZEy6c.js","assets/Sweetalerts-BFSsVcNi.js","assets/Rangeslider-Ur0WuwIw.js","assets/Widgets-CNa6iYuM.js","assets/ChartWidgets-1zxDwvuc.js","assets/FormElements-DdQcMAO1.js","assets/AdvancedForms-iQiUd9uS.js","assets/react-filepond.esm-Cg2gVH4h.js","assets/filepond-plugin-image-preview-jIDQBtim.js","assets/filepond-plugin-image-preview-D5zs2v52.css","assets/AdvancedForms-BjSR2UOg.css","assets/FormWizard-C5XoqR43.js","assets/InputGroup--fPAVDN-.js","assets/FormEdit-CxvpxzQo.js","assets/FormElementSizes-UKUAvAeD.js","assets/FormTreeView-DBk5i2uN.js","assets/Area-1LYzaRnR.js","assets/apexchart-hKp8Mg_F.js","assets/Bar-CMX6ssyb.js","assets/Column-DJ6gDcxD.js","assets/Line-Brx_GrIW.js","assets/Mixed-Ka_89bxq.js","assets/Echart-CWFa80g4.js","assets/Chartjs-BioxNYB_.js","assets/Defaulttable-Bbs754DI.js","assets/DataTable-D7cmPjb1.js","assets/index.es-Dn4wSDoi.js","assets/_baseIsEqual-BzPMTjal.js","assets/Accordion-C6Kjk0g0.js","assets/AccordionBody-B1b8Swi5.js","assets/Alerts-BrJIpmEL.js","assets/Avatars-DfUe3EOz.js","assets/Badges-Bk-wGwLa.js","assets/Breadcrumd-B6Jf-6q7.js","assets/Button-BqifmvQ_.js","assets/Cards-5YQA1Ey8.js","assets/CardImages-DeWiPL7b.js","assets/12-U7ux0O5W.js","assets/15-CS5OAozU.js","assets/Carousel-DIDk20IJ.js","assets/18-OKtq5Itd.js","assets/Dropdown-BNe4mJoH.js","assets/Footers-CRqgSi2C.js","assets/Header-DlG5HaFB.js","assets/List-XLpyRiOi.js","assets/MediaObject-WVJOQLUb.js","assets/Modal-s-fu73HS.js","assets/Navigation-DRuVQxjt.js","assets/Pagination-CVo6lEpN.js","assets/Panel-D1e6ERCh.js","assets/Tooltips-AIpXD13A.js","assets/Tags-MoJib5vo.js","assets/Tabs-vfpgC5zH.js","assets/Popover-Bwu7rb44.js","assets/Progress-1wMRX1AP.js","assets/FontAwesome-lQ7E2lcx.js","assets/SimpleLineIcons-BvNn3MhG.js","assets/MaterialDesignIcons-B6jYqD4Z.js","assets/FeatherIcons-CMZY7BCf.js","assets/ThemifyIcons-Br4G9nqe.js","assets/Pe7Icons-Vb99_KT5.js","assets/FlagIcons-BafXhNRA.js","assets/IonicIcons-CKMBE09d.js","assets/Bootstrap5SVGIcons-jG0N7kqr.js","assets/MaterialIcons-Cz-go8ss.js","assets/WeatherIcons-DMay-gQT.js","assets/Profile01-F613ldXv.js","assets/Profile03-BsnwF9K5.js","assets/Profile02-Ct4EyFiy.js","assets/AboutUs-9uSs23rs.js","assets/EditProfile-e2_F8gmW.js","assets/Settings-BKpApWJJ.js","assets/EmailCompose-B0gtm9CP.js","assets/EmailInbox-CosMFTYz.js","assets/EmailRead-DaunGyl9.js","assets/Pricing03-x9as3b2k.js","assets/Pricing02-C7D9voBK.js","assets/Pricing01-7knmcG2e.js","assets/Invoicelist-BshR6w5P.js","assets/Invoice01-CmJshT2b.js","assets/Invoice02-CDGXeSTd.js","assets/Invoice03-D4JTgMwV.js","assets/AddInvoice-BxIWEjSo.js","assets/EditInvoice-M2-HsbTM.js","assets/BlogPost-DJ7xxp5b.js","assets/BlogPost-BNdUdR3S.css","assets/BlogStyles-Cp-HAxdG.js","assets/Blog03-C_dZUUtq.js","assets/Blog01-BZPjXBir.js","assets/data-BeVYO8Ky.js","assets/Blog02-B4S4et5Y.js","assets/Wishlist-rVJfQRq4.js","assets/Action-jflwqxF-.js","assets/Checkout-DxQx1Mgq.js","assets/ShoppingCart-BRIp9sux.js","assets/ProductDetails-CzFHUgoi.js","assets/Products-DfzfrGsA.js","assets/Gallery-BvhlppYj.js","assets/FAQS-DvCzU1dW.js","assets/Terms-B_Dq2Sxv.js","assets/Search-Pkp3W6Ce.js","assets/EmptyPage-mSRujYcn.js","assets/Error400-VZRkK1y5.js","assets/Error401-Cky5slib.js","assets/Error403-BDCAy-nJ.js","assets/Error404-Cv01yE1n.js","assets/Error500-BBux22QF.js","assets/Error503-DZRgV-up.js","assets/ComingSoon-CNZPOu7Q.js","assets/UnderConstruction-FXQCT9Ex.js","assets/1-2rUKNz8n.js","assets/Login01-Dcrus_vt.js","assets/Login02-y2hiNByG.js","assets/Login03-BldAFyOk.js","assets/login-BlSAtsHC.js","assets/Register03-CZAfUSHB.js","assets/Register02-D8lDo_5h.js","assets/Register01-HHmy_vuw.js","assets/ForgetPassword02-CtWVVgPQ.js","assets/ForgetPassword01-CVsA5fTv.js","assets/ForgetPassword03-9o-_rCwa.js","assets/ResetPassword01-C9eobT38.js","assets/ResetPassword02-BbBl7L27.js","assets/ResetPassword03-8FPbup07.js","assets/LockScreen03-Cd-MeY3V.js","assets/LockScreen02-Jcj-gY1A.js","assets/LockScreen01-BrAYOA9H.js","assets/Height-CrDGGAlJ.js","assets/Width-CPncCxkB.js","assets/Padding-B48fzb2u.js","assets/Typography-BMFFTbyz.js","assets/Margin--rwYF9Qa.js","assets/Colors-CslkKQb5.js","assets/FlexItems-BJEcy1UI.js","assets/Border-CZsfFy4z.js","assets/Display-XEPMiAwv.js","assets/TypiconsIcons-cpuPjfep.js","assets/Signup-CpyQgd52.js","assets/Auth-C_xNB_SP.js","assets/ForgetPassword-k8qTzVfh.js","assets/CreateGoal-BrpDJ129.js","assets/GoalCategory-xpumh5FT.js","assets/SettingsTools-yqBiaaF-.js","assets/PerformanceCriteria-BLWmvIoq.js","assets/PerformanceMetric-B2ZcsIJL.js","assets/Manager-YrR08pIe.js","assets/AppraisalRoutes-CxOfozoG.js","assets/BusinessGoal-BgEQhA4i.js","assets/AppraisalPeriod-C3tc_ioJ.js","assets/DeveloymentPlan-D73NLB7c.js","assets/CreateNewEmployee-C1jjCW6P.js","assets/EmployeeDetails-CQsp6Bi2.js","assets/EmployeeProfile-C-0XJSc9.js","assets/FeedBack-DkuhBsmx.js","assets/FeedBackDetails-jAYV0Cnb.js","assets/GoalApproval-BmpVOdHy.js","assets/GoalTracking-DXlmcfi7.js","assets/CreateBulkUsers-g3QriRRP.js","assets/CreateBulkUsers-o0u6duTa.css","assets/Login-uEOzC-Rv.js"])))=>i.map(i=>d[i]);
import { r as reactExports, R as React, j as jsxRuntimeExports, P as PropTypes, a as React$1, b as reactDomExports, c as createPopper, d as ReactDOM$1, T as Transition } from "./mui-6YGer9Nu.js";
import { a as requireReactDom, g as getDefaultExportFromCjs, r as requireReact, b as getAugmentedNamespace } from "./vendor-DcOWwNOt.js";
import { a as axios } from "./utils-pMlYcaaZ.js";
function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/apps/nsh/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled2 = function(promises) {
      return Promise.all(
        promises.map(
          (p2) => Promise.resolve(p2).then(
            (value) => ({ status: "fulfilled", value }),
            (reason) => ({ status: "rejected", reason })
          )
        )
      );
    };
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = allSettled2(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
var client = {};
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m2 = requireReactDom();
  {
    client.createRoot = m2.createRoot;
    client.hydrateRoot = m2.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
/**
 * @remix-run/router v1.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$v() {
  _extends$v = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$v.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning$1(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$v({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$v({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error2) {
      if (error2 instanceof DOMException && error2.name === "DataCloneError") {
        throw error2;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    href = href.replace(/ $/, "%20");
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename2) {
  if (basename2 === void 0) {
    basename2 = "/";
  }
  return matchRoutesImpl(routes, locationArg, basename2);
}
function matchRoutesImpl(routes, locationArg, basename2, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename2);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i2], decoded);
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required2 = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required2, ""] : [required2];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required2 : [required2, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    let route = meta.route;
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce((memo, _ref, index2) => {
    let {
      paramName,
      isOptional
    } = _ref;
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index2];
    if (isOptional && !value) {
      memo[paramName] = void 0;
    } else {
      memo[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning$1(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_2, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
  } catch (error2) {
    warning$1(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error2 + ")."));
    return value;
  }
}
function stripBasename(pathname, basename2) {
  if (basename2 === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename2.toLowerCase())) {
    return null;
  }
  let startIndex = basename2.endsWith("/") ? basename2.length - 1 : basename2.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
const ABSOLUTE_URL_REGEX$1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX$1.test(url);
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname;
  if (toPathname) {
    if (isAbsoluteUrl(toPathname)) {
      pathname = toPathname;
    } else {
      if (toPathname.includes("//")) {
        let oldPathname = toPathname;
        toPathname = toPathname.replace(/\/\/+/g, "/");
        warning$1(false, "Pathnames cannot have embedded double slashes - normalizing " + (oldPathname + " -> " + toPathname));
      }
      if (toPathname.startsWith("/")) {
        pathname = resolvePathname(toPathname.substring(1), "/");
      } else {
        pathname = resolvePathname(toPathname, fromPathname);
      }
    }
  } else {
    pathname = fromPathname;
  }
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match, index2) => index2 === 0 || match.route.path && match.route.path.length > 0);
}
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);
  if (v7_relativeSplatPath) {
    return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);
  }
  return pathMatches.map((match) => match.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$v({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
function isRouteErrorResponse(error2) {
  return error2 != null && typeof error2.status === "number" && typeof error2.statusText === "string" && typeof error2.internal === "boolean" && "data" in error2;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$u() {
  _extends$u = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$u.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename: basename2,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename2 !== "/") {
    joinedPathname = pathname === "/" ? basename2 : joinPaths([basename2, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect$2(cb) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename: basename2,
    future,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$2(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename2 !== "/") {
      path.pathname = path.pathname === "/" ? basename2 : joinPaths([basename2, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename2, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
const OutletContext = /* @__PURE__ */ reactExports.createContext(null);
function useOutlet(context) {
  let outlet = reactExports.useContext(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ reactExports.createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useParams() {
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    future
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
    ]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$u({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error2 = useRouteError();
  let message = isRouteErrorResponse(error2) ? error2.status + " " + error2.statusText : error2 instanceof Error ? error2.message : JSON.stringify(error2);
  let stack = error2 instanceof Error ? error2.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error2) {
    return {
      error: error2
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error2, errorInfo) {
    console.error("React Router caught the following error during render", error2, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState, future) {
  var _dataRouterState;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches == null) {
    var _future;
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]) !== void 0);
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i2 = 0; i2 < renderedMatches.length; i2++) {
      let match = renderedMatches[i2];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i2;
      }
      if (match.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState;
        let needsToRunLoader = match.route.loader && loaderData[match.route.id] === void 0 && (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index2) => {
    let error2;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error2 = errors && match.route.id ? errors[match.route.id] : void 0;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index2 === 0) {
          warningOnce("route-fallback");
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index2) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren = () => {
      let children;
      if (error2) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error: error2,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ (function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
})(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ (function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
})(DataRouterStateHook$1 || {});
function useDataRouterContext$1(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error2 = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState();
  let routeId = useCurrentRouteId();
  if (error2 !== void 0) {
    return error2;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext$1(DataRouterHook$1.UseNavigateStable);
  let id = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$2(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, _extends$u({
        fromRouteId: id
      }, options));
    }
  }, [router, id]);
  return navigate;
}
const alreadyWarned$1 = {};
function warningOnce(key, cond, message) {
  if (!alreadyWarned$1[key]) {
    alreadyWarned$1[key] = true;
  }
}
function logV6DeprecationWarnings(renderFuture, routerFuture) {
  if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === void 0) ;
  if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === void 0 && true) ;
}
function Navigate(_ref4) {
  let {
    to,
    replace: replace2,
    state,
    relative
  } = _ref4;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    future,
    static: isStatic
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let navigate = useNavigate();
  let path = resolveTo(to, getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === "path");
  let jsonPath = JSON.stringify(path);
  reactExports.useEffect(() => navigate(JSON.parse(jsonPath), {
    replace: replace2,
    state,
    relative
  }), [navigate, jsonPath, relative, replace2, state]);
  return null;
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Route(_props) {
  invariant(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename2 = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename: basename2,
    navigator: navigator2,
    static: staticProp,
    future: _extends$u({
      v7_relativeSplatPath: false
    }, future)
  }), [basename2, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename2);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename2, pathname, search, hash, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index2];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$t() {
  _extends$t = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$t.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$s(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
function createSearchParams(init2) {
  if (init2 === void 0) {
    init2 = "";
  }
  return new URLSearchParams(typeof init2 === "string" || Array.isArray(init2) || init2 instanceof URLSearchParams ? init2 : Object.keys(init2).reduce((memo, key) => {
    let value = init2[key];
    return memo.concat(Array.isArray(value) ? value.map((v2) => [key, v2]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    defaultSearchParams.forEach((_2, key) => {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach((value) => {
          searchParams.append(key, value);
        });
      }
    });
  }
  return searchParams;
}
const _excluded$s = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"];
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e2) {
}
const ViewTransitionContext = /* @__PURE__ */ reactExports.createContext({
  isTransitioning: false
});
const START_TRANSITION = "startTransition";
const startTransitionImpl = React[START_TRANSITION];
function BrowserRouter(_ref4) {
  let {
    basename: basename2,
    children,
    future,
    window: window2
  } = _ref4;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  reactExports.useEffect(() => logV6DeprecationWarnings(future), [future]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename: basename2,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future
  });
}
const isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref7, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset,
    viewTransition
  } = _ref7, rest = _objectWithoutPropertiesLoose$s(_ref7, _excluded$s);
  let {
    basename: basename2
  } = reactExports.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
    absoluteHref = to;
    if (isBrowser$1) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename2);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e2) {
      }
    }
  }
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative,
    viewTransition
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends$t({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
});
const NavLink = /* @__PURE__ */ reactExports.forwardRef(function NavLinkWithRef(_ref8, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    viewTransition,
    children
  } = _ref8, rest = _objectWithoutPropertiesLoose$s(_ref8, _excluded2);
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = reactExports.useContext(DataRouterStateContext);
  let {
    navigator: navigator2,
    basename: basename2
  } = reactExports.useContext(NavigationContext);
  let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  useViewTransitionState(path) && viewTransition === true;
  let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  if (nextLocationPathname && basename2) {
    nextLocationPathname = stripBasename(nextLocationPathname, basename2) || nextLocationPathname;
  }
  const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let renderProps = {
    isActive,
    isPending,
    isTransitioning
  };
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp(renderProps);
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
  return /* @__PURE__ */ reactExports.createElement(Link, _extends$t({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to,
    viewTransition
  }), typeof children === "function" ? children(renderProps) : children);
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant(false) : void 0;
  return ctx;
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    viewTransition
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return reactExports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative,
        viewTransition
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);
}
function useSearchParams(defaultInit) {
  let defaultSearchParamsRef = reactExports.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = reactExports.useRef(false);
  let location = useLocation();
  let searchParams = reactExports.useMemo(() => (
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)
  ), [location.search]);
  let navigate = useNavigate();
  let setSearchParams = reactExports.useCallback((nextInit, navigateOptions) => {
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    hasSetSearchParamsRef.current = true;
    navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
function useViewTransitionState(to, opts) {
  if (opts === void 0) {
    opts = {};
  }
  let vtContext = reactExports.useContext(ViewTransitionContext);
  !(vtContext != null) ? invariant(false) : void 0;
  let {
    basename: basename2
  } = useDataRouterContext(DataRouterHook.useViewTransitionState);
  let path = useResolvedPath(to, {
    relative: opts.relative
  });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename2) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename2) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}
var withSelector = { exports: {} };
var useSyncExternalStoreWithSelector_production = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreWithSelector_production;
function requireUseSyncExternalStoreWithSelector_production() {
  if (hasRequiredUseSyncExternalStoreWithSelector_production) return useSyncExternalStoreWithSelector_production;
  hasRequiredUseSyncExternalStoreWithSelector_production = 1;
  var React2 = requireReact();
  function is2(x2, y2) {
    return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore = React2.useSyncExternalStore, useRef = React2.useRef, useEffect = React2.useEffect, useMemo = React2.useMemo, useDebugValue = React2.useDebugValue;
  useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = { hasValue: false, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = true;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual2 && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual2(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual2 && isEqual2(currentSelection, nextSelection))
            return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          null === maybeGetServerSnapshot ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual2]
    );
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(
      function() {
        inst.hasValue = true;
        inst.value = value;
      },
      [value]
    );
    useDebugValue(value);
    return value;
  };
  return useSyncExternalStoreWithSelector_production;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  {
    withSelector.exports = requireUseSyncExternalStoreWithSelector_production();
  }
  return withSelector.exports;
}
requireWithSelector();
var IS_REACT_19 = /* @__PURE__ */ reactExports.version.startsWith("19");
var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(
  IS_REACT_19 ? "react.transitional.element" : "react.element"
);
var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
var REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler");
var REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer");
var REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context");
var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
var REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense");
var REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for(
  "react.suspense_list"
);
var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
var REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy");
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Memo = REACT_MEMO_TYPE;
function typeOf(object2) {
  if (typeof object2 === "object" && object2 !== null) {
    const { $$typeof } = object2;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        switch (object2 = object2.type, object2) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
            return object2;
          default:
            switch (object2 = object2 && object2.$$typeof, object2) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
                return object2;
              case REACT_CONSUMER_TYPE:
                return object2;
              default:
                return $$typeof;
            }
        }
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }
}
function isMemo(object2) {
  return typeOf(object2) === REACT_MEMO_TYPE;
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {
  areStatesEqual,
  areOwnPropsEqual,
  areStatePropsEqual
}) {
  let hasRunAtLeastOnce = false;
  let state;
  let ownProps;
  let stateProps;
  let dispatchProps;
  let mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    const nextStateProps = mapStateToProps(state, ownProps);
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    const stateChanged = !areStatesEqual(
      nextState,
      state,
      nextOwnProps,
      ownProps
    );
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch, {
  initMapStateToProps,
  initMapDispatchToProps,
  initMergeProps,
  ...options
}) {
  const mapStateToProps = initMapStateToProps(dispatch, options);
  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  const mergeProps = initMergeProps(dispatch, options);
  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
function bindActionCreators(actionCreators, dispatch) {
  const boundActionCreators = {};
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));
    }
  }
  return boundActionCreators;
}
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch) {
    const constant = getConstant(dispatch);
    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, { displayName }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      let props = proxy(stateOrDispatch, ownProps);
      if (typeof props === "function") {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }
      return props;
    };
    return proxy;
  };
}
function createInvalidArgFactory(arg, name) {
  return (dispatch, options) => {
    throw new Error(
      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`
    );
  };
}
function mapDispatchToPropsFactory(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant(
    (dispatch) => (
      // @ts-ignore
      bindActionCreators(mapDispatchToProps, dispatch)
    )
  ) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch) => ({
    dispatch
  })) : typeof mapDispatchToProps === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapDispatchToProps)
  ) : createInvalidArgFactory(mapDispatchToProps, "mapDispatchToProps");
}
function mapStateToPropsFactory(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapStateToProps)
  ) : createInvalidArgFactory(mapStateToProps, "mapStateToProps");
}
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return { ...ownProps, ...stateProps, ...dispatchProps };
}
function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {
    let hasRunOnce = false;
    let mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      if (hasRunOnce) {
        if (!areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
      }
      return mergedProps;
    };
  };
}
function mergePropsFactory(mergeProps) {
  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, "mergeProps");
}
function defaultNoopBatch(callback) {
  callback();
}
function createListenerCollection() {
  let first = null;
  let last = null;
  return {
    clear() {
      first = null;
      last = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      const listeners = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      const listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store2, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store2.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
var canUseDOM$1 = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM$1();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? reactExports.useLayoutEffect : reactExports.useEffect;
var useIsomorphicLayoutEffect$1 = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
function is(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || y2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;
  for (let i2 = 0; i2 < keysA.length; i2++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !is(objA[keysA[i2]], objB[keysA[i2]])) {
      return false;
    }
  }
  return true;
}
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {
  [ForwardRef]: FORWARD_REF_STATICS,
  [Memo]: MEMO_STATICS
};
function getStatics(component) {
  if (isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      const inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent);
      }
    }
    let keys = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }
    const targetStatics = getStatics(targetComponent);
    const sourceStatics = getStatics(sourceComponent);
    for (let i2 = 0; i2 < keys.length; ++i2) {
      const key = keys[i2];
      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          defineProperty(targetComponent, key, descriptor);
        } catch (e2) {
        }
      }
    }
  }
  return targetComponent;
}
var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext$1() {
  if (!reactExports.createContext) return {};
  const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());
  let realContext = contextMap.get(reactExports.createContext);
  if (!realContext) {
    realContext = reactExports.createContext(
      null
    );
    contextMap.set(reactExports.createContext, realContext);
  }
  return realContext;
}
var ReactReduxContext = /* @__PURE__ */ getContext$1();
var NO_SUBSCRIPTION_ARRAY = [null, null];
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect$1(() => effectFunc(...effectArgs), dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store2, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
  if (!shouldHandleStateChanges) return () => {
  };
  let didUnsubscribe = false;
  let lastThrownError = null;
  const checkForUpdates = () => {
    if (didUnsubscribe || !isMounted.current) {
      return;
    }
    const latestStoreState = store2.getState();
    let newChildProps, error2;
    try {
      newChildProps = childPropsSelector(
        latestStoreState,
        lastWrapperProps.current
      );
    } catch (e2) {
      error2 = e2;
      lastThrownError = e2;
    }
    if (!error2) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      additionalSubscribeListener();
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  const unsubscribeWrapper = () => {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
function strictEqual(a2, b2) {
  return a2 === b2;
}
function connect(mapStateToProps, mapDispatchToProps, mergeProps, {
  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
  // @ts-ignore
  pure,
  areStatesEqual = strictEqual,
  areOwnPropsEqual = shallowEqual,
  areStatePropsEqual = shallowEqual,
  areMergedPropsEqual = shallowEqual,
  // use React's forwardRef to expose a ref of the wrapped component
  forwardRef = false,
  // the context consumer to use
  context = ReactReduxContext
} = {}) {
  const Context = context;
  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);
  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);
  const initMergeProps = mergePropsFactory(mergeProps);
  const shouldHandleStateChanges = Boolean(mapStateToProps);
  const wrapWithConnect = (WrappedComponent) => {
    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    const displayName = `Connect(${wrappedComponentName})`;
    const selectorFactoryOptions = {
      shouldHandleStateChanges,
      displayName,
      wrappedComponentName,
      WrappedComponent,
      // @ts-ignore
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      areStatesEqual,
      areStatePropsEqual,
      areOwnPropsEqual,
      areMergedPropsEqual
    };
    function ConnectFunction(props) {
      const [propsContext, reactReduxForwardedRef, wrapperProps] = reactExports.useMemo(() => {
        const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;
        return [props.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props]);
      const ContextToUse = reactExports.useMemo(() => {
        let ResultContext = Context;
        if (propsContext == null ? void 0 : propsContext.Consumer) ;
        return ResultContext;
      }, [propsContext, Context]);
      const contextValue = reactExports.useContext(ContextToUse);
      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
      const store2 = didStoreComeFromProps ? props.store : contextValue.store;
      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store2.getState;
      const childPropsSelector = reactExports.useMemo(() => {
        return finalPropsSelectorFactory(store2.dispatch, selectorFactoryOptions);
      }, [store2]);
      const [subscription, notifyNestedSubs] = reactExports.useMemo(() => {
        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;
        const subscription2 = createSubscription(
          store2,
          didStoreComeFromProps ? void 0 : contextValue.subscription
        );
        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store2, didStoreComeFromProps, contextValue]);
      const overriddenContextValue = reactExports.useMemo(() => {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return {
          ...contextValue,
          subscription
        };
      }, [didStoreComeFromProps, contextValue, subscription]);
      const lastChildProps = reactExports.useRef(void 0);
      const lastWrapperProps = reactExports.useRef(wrapperProps);
      const childPropsFromStoreUpdate = reactExports.useRef(void 0);
      const renderIsScheduled = reactExports.useRef(false);
      const isMounted = reactExports.useRef(false);
      const latestSubscriptionCallbackError = reactExports.useRef(
        void 0
      );
      useIsomorphicLayoutEffect$1(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      const actualChildPropsSelector = reactExports.useMemo(() => {
        const selector = () => {
          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
            return childPropsFromStoreUpdate.current;
          }
          return childPropsSelector(store2.getState(), wrapperProps);
        };
        return selector;
      }, [store2, wrapperProps]);
      const subscribeForReact = reactExports.useMemo(() => {
        const subscribe = (reactListener) => {
          if (!subscription) {
            return () => {
            };
          }
          return subscribeUpdates(
            shouldHandleStateChanges,
            store2,
            subscription,
            // @ts-ignore
            childPropsSelector,
            lastWrapperProps,
            lastChildProps,
            renderIsScheduled,
            isMounted,
            childPropsFromStoreUpdate,
            notifyNestedSubs,
            reactListener
          );
        };
        return subscribe;
      }, [subscription]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [
        lastWrapperProps,
        lastChildProps,
        renderIsScheduled,
        wrapperProps,
        childPropsFromStoreUpdate,
        notifyNestedSubs
      ]);
      let actualChildProps;
      try {
        actualChildProps = reactExports.useSyncExternalStore(
          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
          subscribeForReact,
          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
          actualChildPropsSelector,
          getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector
        );
      } catch (err) {
        if (latestSubscriptionCallbackError.current) {
          err.message += `
The error may be correlated with this previous error:
${latestSubscriptionCallbackError.current.stack}

`;
        }
        throw err;
      }
      useIsomorphicLayoutEffect$1(() => {
        latestSubscriptionCallbackError.current = void 0;
        childPropsFromStoreUpdate.current = void 0;
        lastChildProps.current = actualChildProps;
      });
      const renderedWrappedComponent = reactExports.useMemo(() => {
        return (
          // @ts-ignore
          /* @__PURE__ */ reactExports.createElement(
            WrappedComponent,
            {
              ...actualChildProps,
              ref: reactReduxForwardedRef
            }
          )
        );
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      const renderedChild = reactExports.useMemo(() => {
        if (shouldHandleStateChanges) {
          return /* @__PURE__ */ reactExports.createElement(ContextToUse.Provider, { value: overriddenContextValue }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    const _Connect = reactExports.memo(ConnectFunction);
    const Connect = _Connect;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef) {
      const _forwarded = reactExports.forwardRef(
        function forwardConnectRef(props, ref) {
          return /* @__PURE__ */ reactExports.createElement(Connect, { ...props, reactReduxForwardedRef: ref });
        }
      );
      const forwarded = _forwarded;
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);
    }
    return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);
  };
  return wrapWithConnect;
}
var connect_default = connect;
function Provider(providerProps) {
  const { children, context, serverState, store: store2 } = providerProps;
  const contextValue = reactExports.useMemo(() => {
    const subscription = createSubscription(store2);
    const baseContextValue = {
      store: store2,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
    {
      return baseContextValue;
    }
  }, [store2, serverState]);
  const previousState = reactExports.useMemo(() => store2.getState(), [store2]);
  useIsomorphicLayoutEffect$1(() => {
    const { subscription } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store2.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext;
  return /* @__PURE__ */ reactExports.createElement(Context.Provider, { value: contextValue }, children);
}
var Provider_default = Provider;
function createReduxContextHook(context = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = reactExports.useContext(context);
    return contextValue;
  };
}
var useReduxContext = /* @__PURE__ */ createReduxContextHook();
function createStoreHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
    // @ts-ignore
    createReduxContextHook(context)
  );
  const useStore2 = () => {
    const { store: store2 } = useReduxContext2();
    return store2;
  };
  Object.assign(useStore2, {
    withTypes: () => useStore2
  });
  return useStore2;
}
var useStore = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context = ReactReduxContext) {
  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
  const useDispatch2 = () => {
    const store2 = useStore2();
    return store2.dispatch;
  };
  Object.assign(useDispatch2, {
    withTypes: () => useDispatch2
  });
  return useDispatch2;
}
var useDispatch = /* @__PURE__ */ createDispatchHook();
function formatProdErrorMessage$1(code) {
  return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject$3(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
function createStore(reducer, preloadedState, enhancer) {
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage$1(2));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage$1(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage$1(1));
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  let currentReducer = reducer;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener, key) => {
        nextListeners.set(key, listener);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage$1(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage$1(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage$1(5));
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage$1(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$3(action)) {
      throw new Error(formatProdErrorMessage$1(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage$1(8));
    }
    if (typeof action.type !== "string") {
      throw new Error(formatProdErrorMessage$1(17));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage$1(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach((listener) => {
      listener();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage$1(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage$1(11));
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store2;
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach((key) => {
    const reducer = reducers[key];
    const initialState2 = reducer(void 0, {
      type: actionTypes_default.INIT
    });
    if (typeof initialState2 === "undefined") {
      throw new Error(formatProdErrorMessage$1(12));
    }
    if (typeof reducer(void 0, {
      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(formatProdErrorMessage$1(13));
    }
  });
}
function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);
  const finalReducers = {};
  for (let i2 = 0; i2 < reducerKeys.length; i2++) {
    const key = reducerKeys[i2];
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  let shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e2) {
    shapeAssertionError = e2;
  }
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    let hasChanged = false;
    const nextState = {};
    for (let i2 = 0; i2 < finalReducerKeys.length; i2++) {
      const key = finalReducerKeys[i2];
      const reducer = finalReducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        action && action.type;
        throw new Error(formatProdErrorMessage$1(14));
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore2) => (reducer, preloadedState) => {
    const store2 = createStore2(reducer, preloadedState);
    let dispatch = () => {
      throw new Error(formatProdErrorMessage$1(15));
    };
    const middlewareAPI = {
      getState: store2.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch = compose(...chain)(store2.dispatch);
    return {
      ...store2,
      dispatch
    };
  };
}
function createThunkMiddleware(extraArgument) {
  const middleware = ({ dispatch, getState }) => (next) => (action) => {
    if (typeof action === "function") {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
  return middleware;
}
var thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0) return void 0;
  if (typeof arguments[0] === "object") return compose;
  return compose.apply(null, arguments);
};
var Tuple = class _Tuple extends Array {
  constructor(...items) {
    super(...items);
    Object.setPrototypeOf(this, _Tuple.prototype);
  }
  static get [Symbol.species]() {
    return _Tuple;
  }
  concat(...arr) {
    return super.concat.apply(this, arr);
  }
  prepend(...arr) {
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new _Tuple(...arr[0].concat(this));
    }
    return new _Tuple(...arr.concat(this));
  }
};
function isBoolean(x2) {
  return typeof x2 === "boolean";
}
var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {
  const {
    thunk: thunk$1 = true,
    immutableCheck = true,
    serializableCheck = true,
    actionCreatorCheck = true
  } = options ?? {};
  let middlewareArray = new Tuple();
  if (thunk$1) {
    if (isBoolean(thunk$1)) {
      middlewareArray.push(thunk);
    } else {
      middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
    }
  }
  return middlewareArray;
};
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var createQueueWithTimer = (timeout) => {
  return (notify) => {
    setTimeout(notify, timeout);
  };
};
var autoBatchEnhancer = (options = {
  type: "raf"
}) => (next) => (...args) => {
  const store2 = next(...args);
  let notifying = true;
  let shouldNotifyAtEndOfTick = false;
  let notificationQueued = false;
  const listeners = /* @__PURE__ */ new Set();
  const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
  ) : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
  const notifyListeners = () => {
    notificationQueued = false;
    if (shouldNotifyAtEndOfTick) {
      shouldNotifyAtEndOfTick = false;
      listeners.forEach((l2) => l2());
    }
  };
  return Object.assign({}, store2, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(listener2) {
      const wrappedListener = () => notifying && listener2();
      const unsubscribe = store2.subscribe(wrappedListener);
      listeners.add(listener2);
      return () => {
        unsubscribe();
        listeners.delete(listener2);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(action) {
      var _a2;
      try {
        notifying = !((_a2 = action == null ? void 0 : action.meta) == null ? void 0 : _a2[SHOULD_AUTOBATCH]);
        shouldNotifyAtEndOfTick = !notifying;
        if (shouldNotifyAtEndOfTick) {
          if (!notificationQueued) {
            notificationQueued = true;
            queueCallback(notifyListeners);
          }
        }
        return store2.dispatch(action);
      } finally {
        notifying = true;
      }
    }
  });
};
var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {
  const {
    autoBatch = true
  } = options ?? {};
  let enhancerArray = new Tuple(middlewareEnhancer);
  if (autoBatch) {
    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
  }
  return enhancerArray;
};
function configureStore(options) {
  const getDefaultMiddleware = buildGetDefaultMiddleware();
  const {
    reducer = void 0,
    middleware,
    devTools = true,
    duplicateMiddlewareCheck = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options || {};
  let rootReducer2;
  if (typeof reducer === "function") {
    rootReducer2 = reducer;
  } else if (isPlainObject$3(reducer)) {
    rootReducer2 = combineReducers(reducer);
  } else {
    throw new Error(formatProdErrorMessage(1));
  }
  let finalMiddleware;
  if (typeof middleware === "function") {
    finalMiddleware = middleware(getDefaultMiddleware);
  } else {
    finalMiddleware = getDefaultMiddleware();
  }
  let finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools({
      // Enable capture of stack traces for dispatched Redux actions
      trace: false,
      ...typeof devTools === "object" && devTools
    });
  }
  const middlewareEnhancer = applyMiddleware(...finalMiddleware);
  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
  let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
  const composedEnhancer = finalCompose(...storeEnhancers);
  return createStore(rootReducer2, preloadedState, composedEnhancer);
}
function formatProdErrorMessage(code) {
  return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
const SET_LOADING = "SET_LOADING";
const SET_TOKEN = "SET_TOKEN";
const setLoading = (isLoading2) => ({
  type: SET_LOADING,
  payload: isLoading2
});
const initialState = {
  isLoading: false,
  token: null
};
const authReducer = (state = initialState, action) => {
  switch (action.type) {
    case SET_LOADING:
      return {
        ...state,
        isLoading: action.payload
      };
    case SET_TOKEN:
      return {
        ...state,
        token: action.payload
      };
    default:
      return state;
  }
};
const rootReducer = combineReducers({
  auth: authReducer
});
const store = configureStore({
  reducer: rootReducer
  // Wrap `rootReducer` in an object with the `reducer` key
});
const loader = "/apps/nsh/assets/loader-DRZCugiD.svg";
const Loader = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "global-loader", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: loader }) });
};
/*!
* sweetalert2 v11.26.4
* Released under the MIT License.
*/
function _assertClassBrand(e2, t2, n2) {
  if ("function" == typeof e2 ? e2 === t2 : e2.has(t2)) return arguments.length < 3 ? t2 : n2;
  throw new TypeError("Private element is not present on this object");
}
function _checkPrivateRedeclaration(e2, t2) {
  if (t2.has(e2)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet2(s2, a2) {
  return s2.get(_assertClassBrand(s2, a2));
}
function _classPrivateFieldInitSpec(e2, t2, a2) {
  _checkPrivateRedeclaration(e2, t2), t2.set(e2, a2);
}
function _classPrivateFieldSet2(s2, a2, r2) {
  return s2.set(_assertClassBrand(s2, a2), r2), r2;
}
const RESTORE_FOCUS_TIMEOUT = 100;
const globalState = {};
const focusPreviousActiveElement = () => {
  if (globalState.previousActiveElement instanceof HTMLElement) {
    globalState.previousActiveElement.focus();
    globalState.previousActiveElement = null;
  } else if (document.body) {
    document.body.focus();
  }
};
const restoreActiveElement = (returnFocus) => {
  return new Promise((resolve) => {
    if (!returnFocus) {
      return resolve();
    }
    const x2 = window.scrollX;
    const y2 = window.scrollY;
    globalState.restoreFocusTimeout = setTimeout(() => {
      focusPreviousActiveElement();
      resolve();
    }, RESTORE_FOCUS_TIMEOUT);
    window.scrollTo(x2, y2);
  });
};
const swalPrefix = "swal2-";
const classNames = ["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "html-container", "actions", "confirm", "deny", "cancel", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error", "draggable", "dragging"];
const swalClasses = classNames.reduce(
  (acc, className) => {
    acc[className] = swalPrefix + className;
    return acc;
  },
  /** @type {SwalClasses} */
  {}
);
const icons = ["success", "warning", "info", "question", "error"];
const iconTypes = icons.reduce(
  (acc, icon) => {
    acc[icon] = swalPrefix + icon;
    return acc;
  },
  /** @type {SwalIcons} */
  {}
);
const consolePrefix = "SweetAlert2:";
const capitalizeFirstLetter = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const warn = (message) => {
  console.warn(`${consolePrefix} ${typeof message === "object" ? message.join(" ") : message}`);
};
const error = (message) => {
  console.error(`${consolePrefix} ${message}`);
};
const previousWarnOnceMessages = [];
const warnOnce$1 = (message) => {
  if (!previousWarnOnceMessages.includes(message)) {
    previousWarnOnceMessages.push(message);
    warn(message);
  }
};
const warnAboutDeprecation = (deprecatedParam, useInstead = null) => {
  warnOnce$1(`"${deprecatedParam}" is deprecated and will be removed in the next major release.${useInstead ? ` Use "${useInstead}" instead.` : ""}`);
};
const callIfFunction = (arg) => typeof arg === "function" ? arg() : arg;
const hasToPromiseFn = (arg) => arg && typeof arg.toPromise === "function";
const asPromise = (arg) => hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
const isPromise = (arg) => arg && Promise.resolve(arg) === arg;
const getContainer = () => document.body.querySelector(`.${swalClasses.container}`);
const elementBySelector = (selectorString) => {
  const container = getContainer();
  return container ? container.querySelector(selectorString) : null;
};
const elementByClass = (className) => {
  return elementBySelector(`.${className}`);
};
const getPopup = () => elementByClass(swalClasses.popup);
const getIcon = () => elementByClass(swalClasses.icon);
const getIconContent = () => elementByClass(swalClasses["icon-content"]);
const getTitle = () => elementByClass(swalClasses.title);
const getHtmlContainer = () => elementByClass(swalClasses["html-container"]);
const getImage = () => elementByClass(swalClasses.image);
const getProgressSteps = () => elementByClass(swalClasses["progress-steps"]);
const getValidationMessage = () => elementByClass(swalClasses["validation-message"]);
const getConfirmButton = () => (
  /** @type {HTMLButtonElement} */
  elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`)
);
const getCancelButton = () => (
  /** @type {HTMLButtonElement} */
  elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`)
);
const getDenyButton = () => (
  /** @type {HTMLButtonElement} */
  elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`)
);
const getInputLabel = () => elementByClass(swalClasses["input-label"]);
const getLoader = () => elementBySelector(`.${swalClasses.loader}`);
const getActions = () => elementByClass(swalClasses.actions);
const getFooter = () => elementByClass(swalClasses.footer);
const getTimerProgressBar = () => elementByClass(swalClasses["timer-progress-bar"]);
const getCloseButton = () => elementByClass(swalClasses.close);
const focusable = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`;
const getFocusableElements = () => {
  const popup = getPopup();
  if (!popup) {
    return [];
  }
  const focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])');
  const focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex).sort((a2, b2) => {
    const tabindexA = parseInt(a2.getAttribute("tabindex") || "0");
    const tabindexB = parseInt(b2.getAttribute("tabindex") || "0");
    if (tabindexA > tabindexB) {
      return 1;
    } else if (tabindexA < tabindexB) {
      return -1;
    }
    return 0;
  });
  const otherFocusableElements = popup.querySelectorAll(focusable);
  const otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter((el) => el.getAttribute("tabindex") !== "-1");
  return [...new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))].filter((el) => isVisible$1(el));
};
const isModal = () => {
  return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses["toast-shown"]) && !hasClass(document.body, swalClasses["no-backdrop"]);
};
const isToast = () => {
  const popup = getPopup();
  if (!popup) {
    return false;
  }
  return hasClass(popup, swalClasses.toast);
};
const isLoading = () => {
  const popup = getPopup();
  if (!popup) {
    return false;
  }
  return popup.hasAttribute("data-loading");
};
const setInnerHtml = (elem, html) => {
  elem.textContent = "";
  if (html) {
    const parser = new DOMParser();
    const parsed = parser.parseFromString(html, `text/html`);
    const head2 = parsed.querySelector("head");
    if (head2) {
      Array.from(head2.childNodes).forEach((child) => {
        elem.appendChild(child);
      });
    }
    const body = parsed.querySelector("body");
    if (body) {
      Array.from(body.childNodes).forEach((child) => {
        if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {
          elem.appendChild(child.cloneNode(true));
        } else {
          elem.appendChild(child);
        }
      });
    }
  }
};
const hasClass = (elem, className) => {
  if (!className) {
    return false;
  }
  const classList = className.split(/\s+/);
  for (let i2 = 0; i2 < classList.length; i2++) {
    if (!elem.classList.contains(classList[i2])) {
      return false;
    }
  }
  return true;
};
const removeCustomClasses = (elem, params) => {
  Array.from(elem.classList).forEach((className) => {
    if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {
      elem.classList.remove(className);
    }
  });
};
const applyCustomClass = (elem, params, className) => {
  removeCustomClasses(elem, params);
  if (!params.customClass) {
    return;
  }
  const customClass = params.customClass[
    /** @type {keyof SweetAlertCustomClass} */
    className
  ];
  if (!customClass) {
    return;
  }
  if (typeof customClass !== "string" && !customClass.forEach) {
    warn(`Invalid type of customClass.${className}! Expected string or iterable object, got "${typeof customClass}"`);
    return;
  }
  addClass(elem, customClass);
};
const getInput$1 = (popup, inputClass) => {
  if (!inputClass) {
    return null;
  }
  switch (inputClass) {
    case "select":
    case "textarea":
    case "file":
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);
    case "checkbox":
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);
    case "radio":
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);
    case "range":
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);
    default:
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);
  }
};
const focusInput = (input) => {
  input.focus();
  if (input.type !== "file") {
    const val = input.value;
    input.value = "";
    input.value = val;
  }
};
const toggleClass = (target, classList, condition) => {
  if (!target || !classList) {
    return;
  }
  if (typeof classList === "string") {
    classList = classList.split(/\s+/).filter(Boolean);
  }
  classList.forEach((className) => {
    if (Array.isArray(target)) {
      target.forEach((elem) => {
        if (condition) {
          elem.classList.add(className);
        } else {
          elem.classList.remove(className);
        }
      });
    } else {
      if (condition) {
        target.classList.add(className);
      } else {
        target.classList.remove(className);
      }
    }
  });
};
const addClass = (target, classList) => {
  toggleClass(target, classList, true);
};
const removeClass = (target, classList) => {
  toggleClass(target, classList, false);
};
const getDirectChildByClass = (elem, className) => {
  const children = Array.from(elem.children);
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (child instanceof HTMLElement && hasClass(child, className)) {
      return child;
    }
  }
};
const applyNumericalStyle = (elem, property, value) => {
  if (value === `${parseInt(`${value}`)}`) {
    value = parseInt(value);
  }
  if (value || parseInt(`${value}`) === 0) {
    elem.style.setProperty(property, typeof value === "number" ? `${value}px` : value);
  } else {
    elem.style.removeProperty(property);
  }
};
const show = (elem, display = "flex") => {
  if (!elem) {
    return;
  }
  elem.style.display = display;
};
const hide = (elem) => {
  if (!elem) {
    return;
  }
  elem.style.display = "none";
};
const showWhenInnerHtmlPresent = (elem, display = "block") => {
  if (!elem) {
    return;
  }
  new MutationObserver(() => {
    toggle(elem, elem.innerHTML, display);
  }).observe(elem, {
    childList: true,
    subtree: true
  });
};
const setStyle = (parent, selector, property, value) => {
  const el = parent.querySelector(selector);
  if (el) {
    el.style.setProperty(property, value);
  }
};
const toggle = (elem, condition, display = "flex") => {
  if (condition) {
    show(elem, display);
  } else {
    hide(elem);
  }
};
const isVisible$1 = (elem) => !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
const allButtonsAreHidden = () => !isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());
const isScrollable = (elem) => !!(elem.scrollHeight > elem.clientHeight);
const selfOrParentIsScrollable = (element, stopElement) => {
  let parent = element;
  while (parent && parent !== stopElement) {
    if (isScrollable(parent)) {
      return true;
    }
    parent = parent.parentElement;
  }
  return false;
};
const hasCssAnimation = (elem) => {
  const style = window.getComputedStyle(elem);
  const animDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
  const transDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
  return animDuration > 0 || transDuration > 0;
};
const animateTimerProgressBar = (timer, reset = false) => {
  const timerProgressBar = getTimerProgressBar();
  if (!timerProgressBar) {
    return;
  }
  if (isVisible$1(timerProgressBar)) {
    if (reset) {
      timerProgressBar.style.transition = "none";
      timerProgressBar.style.width = "100%";
    }
    setTimeout(() => {
      timerProgressBar.style.transition = `width ${timer / 1e3}s linear`;
      timerProgressBar.style.width = "0%";
    }, 10);
  }
};
const stopTimerProgressBar = () => {
  const timerProgressBar = getTimerProgressBar();
  if (!timerProgressBar) {
    return;
  }
  const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
  timerProgressBar.style.removeProperty("transition");
  timerProgressBar.style.width = "100%";
  const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
  const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
  timerProgressBar.style.width = `${timerProgressBarPercent}%`;
};
const isNodeEnv = () => typeof window === "undefined" || typeof document === "undefined";
const sweetHTML = `
 <div aria-labelledby="${swalClasses.title}" aria-describedby="${swalClasses["html-container"]}" class="${swalClasses.popup}" tabindex="-1">
   <button type="button" class="${swalClasses.close}"></button>
   <ul class="${swalClasses["progress-steps"]}"></ul>
   <div class="${swalClasses.icon}"></div>
   <img class="${swalClasses.image}" />
   <h2 class="${swalClasses.title}" id="${swalClasses.title}"></h2>
   <div class="${swalClasses["html-container"]}" id="${swalClasses["html-container"]}"></div>
   <input class="${swalClasses.input}" id="${swalClasses.input}" />
   <input type="file" class="${swalClasses.file}" />
   <div class="${swalClasses.range}">
     <input type="range" />
     <output></output>
   </div>
   <select class="${swalClasses.select}" id="${swalClasses.select}"></select>
   <div class="${swalClasses.radio}"></div>
   <label class="${swalClasses.checkbox}">
     <input type="checkbox" id="${swalClasses.checkbox}" />
     <span class="${swalClasses.label}"></span>
   </label>
   <textarea class="${swalClasses.textarea}" id="${swalClasses.textarea}"></textarea>
   <div class="${swalClasses["validation-message"]}" id="${swalClasses["validation-message"]}"></div>
   <div class="${swalClasses.actions}">
     <div class="${swalClasses.loader}"></div>
     <button type="button" class="${swalClasses.confirm}"></button>
     <button type="button" class="${swalClasses.deny}"></button>
     <button type="button" class="${swalClasses.cancel}"></button>
   </div>
   <div class="${swalClasses.footer}"></div>
   <div class="${swalClasses["timer-progress-bar-container"]}">
     <div class="${swalClasses["timer-progress-bar"]}"></div>
   </div>
 </div>
`.replace(/(^|\n)\s*/g, "");
const resetOldContainer = () => {
  const oldContainer = getContainer();
  if (!oldContainer) {
    return false;
  }
  oldContainer.remove();
  removeClass([document.documentElement, document.body], [swalClasses["no-backdrop"], swalClasses["toast-shown"], swalClasses["has-column"]]);
  return true;
};
const resetValidationMessage$1 = () => {
  globalState.currentInstance.resetValidationMessage();
};
const addInputChangeListeners = () => {
  const popup = getPopup();
  const input = getDirectChildByClass(popup, swalClasses.input);
  const file = getDirectChildByClass(popup, swalClasses.file);
  const range = popup.querySelector(`.${swalClasses.range} input`);
  const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);
  const select = getDirectChildByClass(popup, swalClasses.select);
  const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);
  const textarea = getDirectChildByClass(popup, swalClasses.textarea);
  input.oninput = resetValidationMessage$1;
  file.onchange = resetValidationMessage$1;
  select.onchange = resetValidationMessage$1;
  checkbox.onchange = resetValidationMessage$1;
  textarea.oninput = resetValidationMessage$1;
  range.oninput = () => {
    resetValidationMessage$1();
    rangeOutput.value = range.value;
  };
  range.onchange = () => {
    resetValidationMessage$1();
    rangeOutput.value = range.value;
  };
};
const getTarget$1 = (target) => typeof target === "string" ? document.querySelector(target) : target;
const setupAccessibility = (params) => {
  const popup = getPopup();
  popup.setAttribute("role", params.toast ? "alert" : "dialog");
  popup.setAttribute("aria-live", params.toast ? "polite" : "assertive");
  if (!params.toast) {
    popup.setAttribute("aria-modal", "true");
  }
};
const setupRTL = (targetElement) => {
  if (window.getComputedStyle(targetElement).direction === "rtl") {
    addClass(getContainer(), swalClasses.rtl);
    globalState.isRTL = true;
  }
};
const init = (params) => {
  const oldContainerExisted = resetOldContainer();
  if (isNodeEnv()) {
    error("SweetAlert2 requires document to initialize");
    return;
  }
  const container = document.createElement("div");
  container.className = swalClasses.container;
  if (oldContainerExisted) {
    addClass(container, swalClasses["no-transition"]);
  }
  setInnerHtml(container, sweetHTML);
  container.dataset["swal2Theme"] = params.theme;
  const targetElement = getTarget$1(params.target);
  targetElement.appendChild(container);
  if (params.topLayer) {
    container.setAttribute("popover", "");
    container.showPopover();
  }
  setupAccessibility(params);
  setupRTL(targetElement);
  addInputChangeListeners();
};
const parseHtmlToContainer = (param, target) => {
  if (param instanceof HTMLElement) {
    target.appendChild(param);
  } else if (typeof param === "object") {
    handleObject(param, target);
  } else if (param) {
    setInnerHtml(target, param);
  }
};
const handleObject = (param, target) => {
  if (param.jquery) {
    handleJqueryElem(target, param);
  } else {
    setInnerHtml(target, param.toString());
  }
};
const handleJqueryElem = (target, elem) => {
  target.textContent = "";
  if (0 in elem) {
    for (let i2 = 0; i2 in elem; i2++) {
      target.appendChild(elem[i2].cloneNode(true));
    }
  } else {
    target.appendChild(elem.cloneNode(true));
  }
};
const renderActions = (instance, params) => {
  const actions = getActions();
  const loader2 = getLoader();
  if (!actions || !loader2) {
    return;
  }
  if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
    hide(actions);
  } else {
    show(actions);
  }
  applyCustomClass(actions, params, "actions");
  renderButtons(actions, loader2, params);
  setInnerHtml(loader2, params.loaderHtml || "");
  applyCustomClass(loader2, params, "loader");
};
function renderButtons(actions, loader2, params) {
  const confirmButton = getConfirmButton();
  const denyButton = getDenyButton();
  const cancelButton = getCancelButton();
  if (!confirmButton || !denyButton || !cancelButton) {
    return;
  }
  renderButton(confirmButton, "confirm", params);
  renderButton(denyButton, "deny", params);
  renderButton(cancelButton, "cancel", params);
  handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
  if (params.reverseButtons) {
    if (params.toast) {
      actions.insertBefore(cancelButton, confirmButton);
      actions.insertBefore(denyButton, confirmButton);
    } else {
      actions.insertBefore(cancelButton, loader2);
      actions.insertBefore(denyButton, loader2);
      actions.insertBefore(confirmButton, loader2);
    }
  }
}
function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
  if (!params.buttonsStyling) {
    removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
    return;
  }
  addClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
  if (params.confirmButtonColor) {
    confirmButton.style.setProperty("--swal2-confirm-button-background-color", params.confirmButtonColor);
  }
  if (params.denyButtonColor) {
    denyButton.style.setProperty("--swal2-deny-button-background-color", params.denyButtonColor);
  }
  if (params.cancelButtonColor) {
    cancelButton.style.setProperty("--swal2-cancel-button-background-color", params.cancelButtonColor);
  }
  applyOutlineColor(confirmButton);
  applyOutlineColor(denyButton);
  applyOutlineColor(cancelButton);
}
function applyOutlineColor(button) {
  const buttonStyle = window.getComputedStyle(button);
  if (buttonStyle.getPropertyValue("--swal2-action-button-focus-box-shadow")) {
    return;
  }
  const outlineColor = buttonStyle.backgroundColor.replace(/rgba?\((\d+), (\d+), (\d+).*/, "rgba($1, $2, $3, 0.5)");
  button.style.setProperty("--swal2-action-button-focus-box-shadow", buttonStyle.getPropertyValue("--swal2-outline").replace(/ rgba\(.*/, ` ${outlineColor}`));
}
function renderButton(button, buttonType, params) {
  const buttonName = (
    /** @type {'Confirm' | 'Deny' | 'Cancel'} */
    capitalizeFirstLetter(buttonType)
  );
  toggle(button, params[`show${buttonName}Button`], "inline-block");
  setInnerHtml(button, params[`${buttonType}ButtonText`] || "");
  button.setAttribute("aria-label", params[`${buttonType}ButtonAriaLabel`] || "");
  button.className = swalClasses[buttonType];
  applyCustomClass(button, params, `${buttonType}Button`);
}
const renderCloseButton = (instance, params) => {
  const closeButton = getCloseButton();
  if (!closeButton) {
    return;
  }
  setInnerHtml(closeButton, params.closeButtonHtml || "");
  applyCustomClass(closeButton, params, "closeButton");
  toggle(closeButton, params.showCloseButton);
  closeButton.setAttribute("aria-label", params.closeButtonAriaLabel || "");
};
const renderContainer = (instance, params) => {
  const container = getContainer();
  if (!container) {
    return;
  }
  handleBackdropParam(container, params.backdrop);
  handlePositionParam(container, params.position);
  handleGrowParam(container, params.grow);
  applyCustomClass(container, params, "container");
};
function handleBackdropParam(container, backdrop) {
  if (typeof backdrop === "string") {
    container.style.background = backdrop;
  } else if (!backdrop) {
    addClass([document.documentElement, document.body], swalClasses["no-backdrop"]);
  }
}
function handlePositionParam(container, position) {
  if (!position) {
    return;
  }
  if (position in swalClasses) {
    addClass(container, swalClasses[position]);
  } else {
    warn('The "position" parameter is not valid, defaulting to "center"');
    addClass(container, swalClasses.center);
  }
}
function handleGrowParam(container, grow) {
  if (!grow) {
    return;
  }
  addClass(container, swalClasses[`grow-${grow}`]);
}
var privateProps = {
  innerParams: /* @__PURE__ */ new WeakMap(),
  domCache: /* @__PURE__ */ new WeakMap()
};
const inputClasses = ["input", "file", "range", "select", "radio", "checkbox", "textarea"];
const renderInput = (instance, params) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const innerParams = privateProps.innerParams.get(instance);
  const rerender = !innerParams || params.input !== innerParams.input;
  inputClasses.forEach((inputClass) => {
    const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);
    if (!inputContainer) {
      return;
    }
    setAttributes(inputClass, params.inputAttributes);
    inputContainer.className = swalClasses[inputClass];
    if (rerender) {
      hide(inputContainer);
    }
  });
  if (params.input) {
    if (rerender) {
      showInput(params);
    }
    setCustomClass(params);
  }
};
const showInput = (params) => {
  if (!params.input) {
    return;
  }
  if (!renderInputType[params.input]) {
    error(`Unexpected type of input! Expected ${Object.keys(renderInputType).join(" | ")}, got "${params.input}"`);
    return;
  }
  const inputContainer = getInputContainer(params.input);
  if (!inputContainer) {
    return;
  }
  const input = renderInputType[params.input](inputContainer, params);
  show(inputContainer);
  if (params.inputAutoFocus) {
    setTimeout(() => {
      focusInput(input);
    });
  }
};
const removeAttributes = (input) => {
  for (let i2 = 0; i2 < input.attributes.length; i2++) {
    const attrName = input.attributes[i2].name;
    if (!["id", "type", "value", "style"].includes(attrName)) {
      input.removeAttribute(attrName);
    }
  }
};
const setAttributes = (inputClass, inputAttributes) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const input = getInput$1(popup, inputClass);
  if (!input) {
    return;
  }
  removeAttributes(input);
  for (const attr in inputAttributes) {
    input.setAttribute(attr, inputAttributes[attr]);
  }
};
const setCustomClass = (params) => {
  if (!params.input) {
    return;
  }
  const inputContainer = getInputContainer(params.input);
  if (inputContainer) {
    applyCustomClass(inputContainer, params, "input");
  }
};
const setInputPlaceholder = (input, params) => {
  if (!input.placeholder && params.inputPlaceholder) {
    input.placeholder = params.inputPlaceholder;
  }
};
const setInputLabel = (input, prependTo, params) => {
  if (params.inputLabel) {
    const label = document.createElement("label");
    const labelClass = swalClasses["input-label"];
    label.setAttribute("for", input.id);
    label.className = labelClass;
    if (typeof params.customClass === "object") {
      addClass(label, params.customClass.inputLabel);
    }
    label.innerText = params.inputLabel;
    prependTo.insertAdjacentElement("beforebegin", label);
  }
};
const getInputContainer = (inputType) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  return getDirectChildByClass(popup, swalClasses[
    /** @type {SwalClass} */
    inputType
  ] || swalClasses.input);
};
const checkAndSetInputValue = (input, inputValue) => {
  if (["string", "number"].includes(typeof inputValue)) {
    input.value = `${inputValue}`;
  } else if (!isPromise(inputValue)) {
    warn(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof inputValue}"`);
  }
};
const renderInputType = {};
renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType["datetime-local"] = renderInputType.time = renderInputType.week = renderInputType.month = /** @type {(input: Input | HTMLElement, params: SweetAlertOptions) => Input} */
(input, params) => {
  checkAndSetInputValue(input, params.inputValue);
  setInputLabel(input, input, params);
  setInputPlaceholder(input, params);
  input.type = params.input;
  return input;
};
renderInputType.file = (input, params) => {
  setInputLabel(input, input, params);
  setInputPlaceholder(input, params);
  return input;
};
renderInputType.range = (range, params) => {
  const rangeInput = range.querySelector("input");
  const rangeOutput = range.querySelector("output");
  checkAndSetInputValue(rangeInput, params.inputValue);
  rangeInput.type = params.input;
  checkAndSetInputValue(rangeOutput, params.inputValue);
  setInputLabel(rangeInput, range, params);
  return range;
};
renderInputType.select = (select, params) => {
  select.textContent = "";
  if (params.inputPlaceholder) {
    const placeholder = document.createElement("option");
    setInnerHtml(placeholder, params.inputPlaceholder);
    placeholder.value = "";
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);
  }
  setInputLabel(select, select, params);
  return select;
};
renderInputType.radio = (radio) => {
  radio.textContent = "";
  return radio;
};
renderInputType.checkbox = (checkboxContainer, params) => {
  const checkbox = getInput$1(getPopup(), "checkbox");
  checkbox.value = "1";
  checkbox.checked = Boolean(params.inputValue);
  const label = checkboxContainer.querySelector("span");
  setInnerHtml(label, params.inputPlaceholder || params.inputLabel);
  return checkbox;
};
renderInputType.textarea = (textarea, params) => {
  checkAndSetInputValue(textarea, params.inputValue);
  setInputPlaceholder(textarea, params);
  setInputLabel(textarea, textarea, params);
  const getMargin = (el) => parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);
  setTimeout(() => {
    if ("MutationObserver" in window) {
      const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
      const textareaResizeHandler = () => {
        if (!document.body.contains(textarea)) {
          return;
        }
        const textareaWidth = textarea.offsetWidth + getMargin(textarea);
        if (textareaWidth > initialPopupWidth) {
          getPopup().style.width = `${textareaWidth}px`;
        } else {
          applyNumericalStyle(getPopup(), "width", params.width);
        }
      };
      new MutationObserver(textareaResizeHandler).observe(textarea, {
        attributes: true,
        attributeFilter: ["style"]
      });
    }
  });
  return textarea;
};
const renderContent = (instance, params) => {
  const htmlContainer = getHtmlContainer();
  if (!htmlContainer) {
    return;
  }
  showWhenInnerHtmlPresent(htmlContainer);
  applyCustomClass(htmlContainer, params, "htmlContainer");
  if (params.html) {
    parseHtmlToContainer(params.html, htmlContainer);
    show(htmlContainer, "block");
  } else if (params.text) {
    htmlContainer.textContent = params.text;
    show(htmlContainer, "block");
  } else {
    hide(htmlContainer);
  }
  renderInput(instance, params);
};
const renderFooter = (instance, params) => {
  const footer = getFooter();
  if (!footer) {
    return;
  }
  showWhenInnerHtmlPresent(footer);
  toggle(footer, Boolean(params.footer), "block");
  if (params.footer) {
    parseHtmlToContainer(params.footer, footer);
  }
  applyCustomClass(footer, params, "footer");
};
const renderIcon = (instance, params) => {
  const innerParams = privateProps.innerParams.get(instance);
  const icon = getIcon();
  if (!icon) {
    return;
  }
  if (innerParams && params.icon === innerParams.icon) {
    setContent(icon, params);
    applyStyles(icon, params);
    return;
  }
  if (!params.icon && !params.iconHtml) {
    hide(icon);
    return;
  }
  if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
    error(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${params.icon}"`);
    hide(icon);
    return;
  }
  show(icon);
  setContent(icon, params);
  applyStyles(icon, params);
  addClass(icon, params.showClass && params.showClass.icon);
  const colorSchemeQueryList = window.matchMedia("(prefers-color-scheme: dark)");
  colorSchemeQueryList.addEventListener("change", adjustSuccessIconBackgroundColor);
};
const applyStyles = (icon, params) => {
  for (const [iconType, iconClassName] of Object.entries(iconTypes)) {
    if (params.icon !== iconType) {
      removeClass(icon, iconClassName);
    }
  }
  addClass(icon, params.icon && iconTypes[params.icon]);
  setColor(icon, params);
  adjustSuccessIconBackgroundColor();
  applyCustomClass(icon, params, "icon");
};
const adjustSuccessIconBackgroundColor = () => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue("background-color");
  const successIconParts = popup.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
  for (let i2 = 0; i2 < successIconParts.length; i2++) {
    successIconParts[i2].style.backgroundColor = popupBackgroundColor;
  }
};
const successIconHtml = (params) => `
  ${params.animation ? '<div class="swal2-success-circular-line-left"></div>' : ""}
  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
  <div class="swal2-success-ring"></div>
  ${params.animation ? '<div class="swal2-success-fix"></div>' : ""}
  ${params.animation ? '<div class="swal2-success-circular-line-right"></div>' : ""}
`;
const errorIconHtml = `
  <span class="swal2-x-mark">
    <span class="swal2-x-mark-line-left"></span>
    <span class="swal2-x-mark-line-right"></span>
  </span>
`;
const setContent = (icon, params) => {
  if (!params.icon && !params.iconHtml) {
    return;
  }
  let oldContent = icon.innerHTML;
  let newContent = "";
  if (params.iconHtml) {
    newContent = iconContent(params.iconHtml);
  } else if (params.icon === "success") {
    newContent = successIconHtml(params);
    oldContent = oldContent.replace(/ style=".*?"/g, "");
  } else if (params.icon === "error") {
    newContent = errorIconHtml;
  } else if (params.icon) {
    const defaultIconHtml = {
      question: "?",
      warning: "!",
      info: "i"
    };
    newContent = iconContent(defaultIconHtml[params.icon]);
  }
  if (oldContent.trim() !== newContent.trim()) {
    setInnerHtml(icon, newContent);
  }
};
const setColor = (icon, params) => {
  if (!params.iconColor) {
    return;
  }
  icon.style.color = params.iconColor;
  icon.style.borderColor = params.iconColor;
  for (const sel of [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"]) {
    setStyle(icon, sel, "background-color", params.iconColor);
  }
  setStyle(icon, ".swal2-success-ring", "border-color", params.iconColor);
};
const iconContent = (content) => `<div class="${swalClasses["icon-content"]}">${content}</div>`;
const renderImage = (instance, params) => {
  const image = getImage();
  if (!image) {
    return;
  }
  if (!params.imageUrl) {
    hide(image);
    return;
  }
  show(image, "");
  image.setAttribute("src", params.imageUrl);
  image.setAttribute("alt", params.imageAlt || "");
  applyNumericalStyle(image, "width", params.imageWidth);
  applyNumericalStyle(image, "height", params.imageHeight);
  image.className = swalClasses.image;
  applyCustomClass(image, params, "image");
};
let dragging = false;
let mousedownX = 0;
let mousedownY = 0;
let initialX = 0;
let initialY = 0;
const addDraggableListeners = (popup) => {
  popup.addEventListener("mousedown", down);
  document.body.addEventListener("mousemove", move);
  popup.addEventListener("mouseup", up);
  popup.addEventListener("touchstart", down);
  document.body.addEventListener("touchmove", move);
  popup.addEventListener("touchend", up);
};
const removeDraggableListeners = (popup) => {
  popup.removeEventListener("mousedown", down);
  document.body.removeEventListener("mousemove", move);
  popup.removeEventListener("mouseup", up);
  popup.removeEventListener("touchstart", down);
  document.body.removeEventListener("touchmove", move);
  popup.removeEventListener("touchend", up);
};
const down = (event) => {
  const popup = getPopup();
  if (event.target === popup || getIcon().contains(
    /** @type {HTMLElement} */
    event.target
  )) {
    dragging = true;
    const clientXY = getClientXY(event);
    mousedownX = clientXY.clientX;
    mousedownY = clientXY.clientY;
    initialX = parseInt(popup.style.insetInlineStart) || 0;
    initialY = parseInt(popup.style.insetBlockStart) || 0;
    addClass(popup, "swal2-dragging");
  }
};
const move = (event) => {
  const popup = getPopup();
  if (dragging) {
    let {
      clientX,
      clientY
    } = getClientXY(event);
    const deltaX = clientX - mousedownX;
    popup.style.insetInlineStart = `${initialX + (globalState.isRTL ? -deltaX : deltaX)}px`;
    popup.style.insetBlockStart = `${initialY + (clientY - mousedownY)}px`;
  }
};
const up = () => {
  const popup = getPopup();
  dragging = false;
  removeClass(popup, "swal2-dragging");
};
const getClientXY = (event) => {
  let clientX = 0, clientY = 0;
  if (event.type.startsWith("mouse")) {
    clientX = /** @type {MouseEvent} */
    event.clientX;
    clientY = /** @type {MouseEvent} */
    event.clientY;
  } else if (event.type.startsWith("touch")) {
    clientX = /** @type {TouchEvent} */
    event.touches[0].clientX;
    clientY = /** @type {TouchEvent} */
    event.touches[0].clientY;
  }
  return {
    clientX,
    clientY
  };
};
const renderPopup = (instance, params) => {
  const container = getContainer();
  const popup = getPopup();
  if (!container || !popup) {
    return;
  }
  if (params.toast) {
    applyNumericalStyle(container, "width", params.width);
    popup.style.width = "100%";
    const loader2 = getLoader();
    if (loader2) {
      popup.insertBefore(loader2, getIcon());
    }
  } else {
    applyNumericalStyle(popup, "width", params.width);
  }
  applyNumericalStyle(popup, "padding", params.padding);
  if (params.color) {
    popup.style.color = params.color;
  }
  if (params.background) {
    popup.style.background = params.background;
  }
  hide(getValidationMessage());
  addClasses$1(popup, params);
  if (params.draggable && !params.toast) {
    addClass(popup, swalClasses.draggable);
    addDraggableListeners(popup);
  } else {
    removeClass(popup, swalClasses.draggable);
    removeDraggableListeners(popup);
  }
};
const addClasses$1 = (popup, params) => {
  const showClass = params.showClass || {};
  popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? showClass.popup : ""}`;
  if (params.toast) {
    addClass([document.documentElement, document.body], swalClasses["toast-shown"]);
    addClass(popup, swalClasses.toast);
  } else {
    addClass(popup, swalClasses.modal);
  }
  applyCustomClass(popup, params, "popup");
  if (typeof params.customClass === "string") {
    addClass(popup, params.customClass);
  }
  if (params.icon) {
    addClass(popup, swalClasses[`icon-${params.icon}`]);
  }
};
const renderProgressSteps = (instance, params) => {
  const progressStepsContainer = getProgressSteps();
  if (!progressStepsContainer) {
    return;
  }
  const {
    progressSteps,
    currentProgressStep
  } = params;
  if (!progressSteps || progressSteps.length === 0 || currentProgressStep === void 0) {
    hide(progressStepsContainer);
    return;
  }
  show(progressStepsContainer);
  progressStepsContainer.textContent = "";
  if (currentProgressStep >= progressSteps.length) {
    warn("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)");
  }
  progressSteps.forEach((step, index2) => {
    const stepEl = createStepElement(step);
    progressStepsContainer.appendChild(stepEl);
    if (index2 === currentProgressStep) {
      addClass(stepEl, swalClasses["active-progress-step"]);
    }
    if (index2 !== progressSteps.length - 1) {
      const lineEl = createLineElement(params);
      progressStepsContainer.appendChild(lineEl);
    }
  });
};
const createStepElement = (step) => {
  const stepEl = document.createElement("li");
  addClass(stepEl, swalClasses["progress-step"]);
  setInnerHtml(stepEl, step);
  return stepEl;
};
const createLineElement = (params) => {
  const lineEl = document.createElement("li");
  addClass(lineEl, swalClasses["progress-step-line"]);
  if (params.progressStepsDistance) {
    applyNumericalStyle(lineEl, "width", params.progressStepsDistance);
  }
  return lineEl;
};
const renderTitle = (instance, params) => {
  const title = getTitle();
  if (!title) {
    return;
  }
  showWhenInnerHtmlPresent(title);
  toggle(title, Boolean(params.title || params.titleText), "block");
  if (params.title) {
    parseHtmlToContainer(params.title, title);
  }
  if (params.titleText) {
    title.innerText = params.titleText;
  }
  applyCustomClass(title, params, "title");
};
const render = (instance, params) => {
  renderPopup(instance, params);
  renderContainer(instance, params);
  renderProgressSteps(instance, params);
  renderIcon(instance, params);
  renderImage(instance, params);
  renderTitle(instance, params);
  renderCloseButton(instance, params);
  renderContent(instance, params);
  renderActions(instance, params);
  renderFooter(instance, params);
  const popup = getPopup();
  if (typeof params.didRender === "function" && popup) {
    params.didRender(popup);
  }
  globalState.eventEmitter.emit("didRender", popup);
};
const isVisible = () => {
  return isVisible$1(getPopup());
};
const clickConfirm = () => {
  var _dom$getConfirmButton;
  return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === void 0 ? void 0 : _dom$getConfirmButton.click();
};
const clickDeny = () => {
  var _dom$getDenyButton;
  return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === void 0 ? void 0 : _dom$getDenyButton.click();
};
const clickCancel = () => {
  var _dom$getCancelButton;
  return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === void 0 ? void 0 : _dom$getCancelButton.click();
};
const DismissReason = Object.freeze({
  cancel: "cancel",
  backdrop: "backdrop",
  close: "close",
  esc: "esc",
  timer: "timer"
});
const removeKeydownHandler = (globalState2) => {
  if (globalState2.keydownTarget && globalState2.keydownHandlerAdded) {
    globalState2.keydownTarget.removeEventListener("keydown", globalState2.keydownHandler, {
      capture: globalState2.keydownListenerCapture
    });
    globalState2.keydownHandlerAdded = false;
  }
};
const addKeydownHandler = (globalState2, innerParams, dismissWith) => {
  removeKeydownHandler(globalState2);
  if (!innerParams.toast) {
    globalState2.keydownHandler = (e2) => keydownHandler(innerParams, e2, dismissWith);
    globalState2.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
    globalState2.keydownListenerCapture = innerParams.keydownListenerCapture;
    globalState2.keydownTarget.addEventListener("keydown", globalState2.keydownHandler, {
      capture: globalState2.keydownListenerCapture
    });
    globalState2.keydownHandlerAdded = true;
  }
};
const setFocus = (index2, increment) => {
  var _dom$getPopup;
  const focusableElements2 = getFocusableElements();
  if (focusableElements2.length) {
    index2 = index2 + increment;
    if (index2 === -2) {
      index2 = focusableElements2.length - 1;
    }
    if (index2 === focusableElements2.length) {
      index2 = 0;
    } else if (index2 === -1) {
      index2 = focusableElements2.length - 1;
    }
    focusableElements2[index2].focus();
    return;
  }
  (_dom$getPopup = getPopup()) === null || _dom$getPopup === void 0 || _dom$getPopup.focus();
};
const arrowKeysNextButton = ["ArrowRight", "ArrowDown"];
const arrowKeysPreviousButton = ["ArrowLeft", "ArrowUp"];
const keydownHandler = (innerParams, event, dismissWith) => {
  if (!innerParams) {
    return;
  }
  if (event.isComposing || event.keyCode === 229) {
    return;
  }
  if (innerParams.stopKeydownPropagation) {
    event.stopPropagation();
  }
  if (event.key === "Enter") {
    handleEnter(event, innerParams);
  } else if (event.key === "Tab") {
    handleTab(event);
  } else if ([...arrowKeysNextButton, ...arrowKeysPreviousButton].includes(event.key)) {
    handleArrows(event.key);
  } else if (event.key === "Escape") {
    handleEsc(event, innerParams, dismissWith);
  }
};
const handleEnter = (event, innerParams) => {
  if (!callIfFunction(innerParams.allowEnterKey)) {
    return;
  }
  const input = getInput$1(getPopup(), innerParams.input);
  if (event.target && input && event.target instanceof HTMLElement && event.target.outerHTML === input.outerHTML) {
    if (["textarea", "file"].includes(innerParams.input)) {
      return;
    }
    clickConfirm();
    event.preventDefault();
  }
};
const handleTab = (event) => {
  const targetElement = event.target;
  const focusableElements2 = getFocusableElements();
  let btnIndex = -1;
  for (let i2 = 0; i2 < focusableElements2.length; i2++) {
    if (targetElement === focusableElements2[i2]) {
      btnIndex = i2;
      break;
    }
  }
  if (!event.shiftKey) {
    setFocus(btnIndex, 1);
  } else {
    setFocus(btnIndex, -1);
  }
  event.stopPropagation();
  event.preventDefault();
};
const handleArrows = (key) => {
  const actions = getActions();
  const confirmButton = getConfirmButton();
  const denyButton = getDenyButton();
  const cancelButton = getCancelButton();
  if (!actions || !confirmButton || !denyButton || !cancelButton) {
    return;
  }
  const buttons = [confirmButton, denyButton, cancelButton];
  if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {
    return;
  }
  const sibling = arrowKeysNextButton.includes(key) ? "nextElementSibling" : "previousElementSibling";
  let buttonToFocus = document.activeElement;
  if (!buttonToFocus) {
    return;
  }
  for (let i2 = 0; i2 < actions.children.length; i2++) {
    buttonToFocus = buttonToFocus[sibling];
    if (!buttonToFocus) {
      return;
    }
    if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {
      break;
    }
  }
  if (buttonToFocus instanceof HTMLButtonElement) {
    buttonToFocus.focus();
  }
};
const handleEsc = (event, innerParams, dismissWith) => {
  event.preventDefault();
  if (callIfFunction(innerParams.allowEscapeKey)) {
    dismissWith(DismissReason.esc);
  }
};
var privateMethods = {
  swalPromiseResolve: /* @__PURE__ */ new WeakMap(),
  swalPromiseReject: /* @__PURE__ */ new WeakMap()
};
const setAriaHidden = () => {
  const container = getContainer();
  const bodyChildren = Array.from(document.body.children);
  bodyChildren.forEach((el) => {
    if (el.contains(container)) {
      return;
    }
    if (el.hasAttribute("aria-hidden")) {
      el.setAttribute("data-previous-aria-hidden", el.getAttribute("aria-hidden") || "");
    }
    el.setAttribute("aria-hidden", "true");
  });
};
const unsetAriaHidden = () => {
  const bodyChildren = Array.from(document.body.children);
  bodyChildren.forEach((el) => {
    if (el.hasAttribute("data-previous-aria-hidden")) {
      el.setAttribute("aria-hidden", el.getAttribute("data-previous-aria-hidden") || "");
      el.removeAttribute("data-previous-aria-hidden");
    } else {
      el.removeAttribute("aria-hidden");
    }
  });
};
const isSafariOrIOS = typeof window !== "undefined" && !!window.GestureEvent;
const iOSfix = () => {
  if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {
    const offset = document.body.scrollTop;
    document.body.style.top = `${offset * -1}px`;
    addClass(document.body, swalClasses.iosfix);
    lockBodyScroll();
  }
};
const lockBodyScroll = () => {
  const container = getContainer();
  if (!container) {
    return;
  }
  let preventTouchMove;
  container.ontouchstart = (event) => {
    preventTouchMove = shouldPreventTouchMove(event);
  };
  container.ontouchmove = (event) => {
    if (preventTouchMove) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
};
const shouldPreventTouchMove = (event) => {
  const target = event.target;
  const container = getContainer();
  const htmlContainer = getHtmlContainer();
  if (!container || !htmlContainer) {
    return false;
  }
  if (isStylus(event) || isZoom(event)) {
    return false;
  }
  if (target === container) {
    return true;
  }
  if (!isScrollable(container) && target instanceof HTMLElement && !selfOrParentIsScrollable(target, htmlContainer) && // #2823
  target.tagName !== "INPUT" && // #1603
  target.tagName !== "TEXTAREA" && // #2266
  !(isScrollable(htmlContainer) && // #1944
  htmlContainer.contains(target))) {
    return true;
  }
  return false;
};
const isStylus = (event) => {
  return event.touches && event.touches.length && event.touches[0].touchType === "stylus";
};
const isZoom = (event) => {
  return event.touches && event.touches.length > 1;
};
const undoIOSfix = () => {
  if (hasClass(document.body, swalClasses.iosfix)) {
    const offset = parseInt(document.body.style.top, 10);
    removeClass(document.body, swalClasses.iosfix);
    document.body.style.top = "";
    document.body.scrollTop = offset * -1;
  }
};
const measureScrollbar = () => {
  const scrollDiv = document.createElement("div");
  scrollDiv.className = swalClasses["scrollbar-measure"];
  document.body.appendChild(scrollDiv);
  const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
};
let previousBodyPadding = null;
const replaceScrollbarWithPadding = (initialBodyOverflow) => {
  if (previousBodyPadding !== null) {
    return;
  }
  if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === "scroll") {
    previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"));
    document.body.style.paddingRight = `${previousBodyPadding + measureScrollbar()}px`;
  }
};
const undoReplaceScrollbarWithPadding = () => {
  if (previousBodyPadding !== null) {
    document.body.style.paddingRight = `${previousBodyPadding}px`;
    previousBodyPadding = null;
  }
};
function removePopupAndResetState(instance, container, returnFocus, didClose) {
  if (isToast()) {
    triggerDidCloseAndDispose(instance, didClose);
  } else {
    restoreActiveElement(returnFocus).then(() => triggerDidCloseAndDispose(instance, didClose));
    removeKeydownHandler(globalState);
  }
  if (isSafariOrIOS) {
    container.setAttribute("style", "display:none !important");
    container.removeAttribute("class");
    container.innerHTML = "";
  } else {
    container.remove();
  }
  if (isModal()) {
    undoReplaceScrollbarWithPadding();
    undoIOSfix();
    unsetAriaHidden();
  }
  removeBodyClasses();
}
function removeBodyClasses() {
  removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses["height-auto"], swalClasses["no-backdrop"], swalClasses["toast-shown"]]);
}
function close(resolveValue) {
  resolveValue = prepareResolveValue(resolveValue);
  const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
  const didClose = triggerClosePopup(this);
  if (this.isAwaitingPromise) {
    if (!resolveValue.isDismissed) {
      handleAwaitingPromise(this);
      swalPromiseResolve(resolveValue);
    }
  } else if (didClose) {
    swalPromiseResolve(resolveValue);
  }
}
const triggerClosePopup = (instance) => {
  const popup = getPopup();
  if (!popup) {
    return false;
  }
  const innerParams = privateProps.innerParams.get(instance);
  if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
    return false;
  }
  removeClass(popup, innerParams.showClass.popup);
  addClass(popup, innerParams.hideClass.popup);
  const backdrop = getContainer();
  removeClass(backdrop, innerParams.showClass.backdrop);
  addClass(backdrop, innerParams.hideClass.backdrop);
  handlePopupAnimation(instance, popup, innerParams);
  return true;
};
function rejectPromise(error2) {
  const rejectPromise2 = privateMethods.swalPromiseReject.get(this);
  handleAwaitingPromise(this);
  if (rejectPromise2) {
    rejectPromise2(error2);
  }
}
const handleAwaitingPromise = (instance) => {
  if (instance.isAwaitingPromise) {
    delete instance.isAwaitingPromise;
    if (!privateProps.innerParams.get(instance)) {
      instance._destroy();
    }
  }
};
const prepareResolveValue = (resolveValue) => {
  if (typeof resolveValue === "undefined") {
    return {
      isConfirmed: false,
      isDenied: false,
      isDismissed: true
    };
  }
  return Object.assign({
    isConfirmed: false,
    isDenied: false,
    isDismissed: false
  }, resolveValue);
};
const handlePopupAnimation = (instance, popup, innerParams) => {
  var _globalState$eventEmi;
  const container = getContainer();
  const animationIsSupported = hasCssAnimation(popup);
  if (typeof innerParams.willClose === "function") {
    innerParams.willClose(popup);
  }
  (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === void 0 || _globalState$eventEmi.emit("willClose", popup);
  if (animationIsSupported) {
    animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);
  } else {
    removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);
  }
};
const animatePopup = (instance, popup, container, returnFocus, didClose) => {
  globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
  const swalCloseAnimationFinished = function(e2) {
    if (e2.target === popup) {
      var _globalState$swalClos;
      (_globalState$swalClos = globalState.swalCloseEventFinishedCallback) === null || _globalState$swalClos === void 0 || _globalState$swalClos.call(globalState);
      delete globalState.swalCloseEventFinishedCallback;
      popup.removeEventListener("animationend", swalCloseAnimationFinished);
      popup.removeEventListener("transitionend", swalCloseAnimationFinished);
    }
  };
  popup.addEventListener("animationend", swalCloseAnimationFinished);
  popup.addEventListener("transitionend", swalCloseAnimationFinished);
};
const triggerDidCloseAndDispose = (instance, didClose) => {
  setTimeout(() => {
    var _globalState$eventEmi2;
    if (typeof didClose === "function") {
      didClose.bind(instance.params)();
    }
    (_globalState$eventEmi2 = globalState.eventEmitter) === null || _globalState$eventEmi2 === void 0 || _globalState$eventEmi2.emit("didClose");
    if (instance._destroy) {
      instance._destroy();
    }
  });
};
const showLoading = (buttonToReplace) => {
  let popup = getPopup();
  if (!popup) {
    new Swal();
  }
  popup = getPopup();
  if (!popup) {
    return;
  }
  const loader2 = getLoader();
  if (isToast()) {
    hide(getIcon());
  } else {
    replaceButton(popup, buttonToReplace);
  }
  show(loader2);
  popup.setAttribute("data-loading", "true");
  popup.setAttribute("aria-busy", "true");
  popup.focus();
};
const replaceButton = (popup, buttonToReplace) => {
  const actions = getActions();
  const loader2 = getLoader();
  if (!actions || !loader2) {
    return;
  }
  if (!buttonToReplace && isVisible$1(getConfirmButton())) {
    buttonToReplace = getConfirmButton();
  }
  show(actions);
  if (buttonToReplace) {
    hide(buttonToReplace);
    loader2.setAttribute("data-button-to-replace", buttonToReplace.className);
    actions.insertBefore(loader2, buttonToReplace);
  }
  addClass([popup, actions], swalClasses.loading);
};
const handleInputOptionsAndValue = (instance, params) => {
  if (params.input === "select" || params.input === "radio") {
    handleInputOptions(instance, params);
  } else if (["text", "email", "number", "tel", "textarea"].some((i2) => i2 === params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
    showLoading(getConfirmButton());
    handleInputValue(instance, params);
  }
};
const getInputValue = (instance, innerParams) => {
  const input = instance.getInput();
  if (!input) {
    return null;
  }
  switch (innerParams.input) {
    case "checkbox":
      return getCheckboxValue(input);
    case "radio":
      return getRadioValue(input);
    case "file":
      return getFileValue(input);
    default:
      return innerParams.inputAutoTrim ? input.value.trim() : input.value;
  }
};
const getCheckboxValue = (input) => input.checked ? 1 : 0;
const getRadioValue = (input) => input.checked ? input.value : null;
const getFileValue = (input) => input.files && input.files.length ? input.getAttribute("multiple") !== null ? input.files : input.files[0] : null;
const handleInputOptions = (instance, params) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const processInputOptions = (inputOptions) => {
    if (params.input === "select") {
      populateSelectOptions(popup, formatInputOptions(inputOptions), params);
    } else if (params.input === "radio") {
      populateRadioOptions(popup, formatInputOptions(inputOptions), params);
    }
  };
  if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
    showLoading(getConfirmButton());
    asPromise(params.inputOptions).then((inputOptions) => {
      instance.hideLoading();
      processInputOptions(inputOptions);
    });
  } else if (typeof params.inputOptions === "object") {
    processInputOptions(params.inputOptions);
  } else {
    error(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);
  }
};
const handleInputValue = (instance, params) => {
  const input = instance.getInput();
  if (!input) {
    return;
  }
  hide(input);
  asPromise(params.inputValue).then((inputValue) => {
    input.value = params.input === "number" ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;
    show(input);
    input.focus();
    instance.hideLoading();
  }).catch((err) => {
    error(`Error in inputValue promise: ${err}`);
    input.value = "";
    show(input);
    input.focus();
    instance.hideLoading();
  });
};
function populateSelectOptions(popup, inputOptions, params) {
  const select = getDirectChildByClass(popup, swalClasses.select);
  if (!select) {
    return;
  }
  const renderOption = (parent, optionLabel, optionValue) => {
    const option = document.createElement("option");
    option.value = optionValue;
    setInnerHtml(option, optionLabel);
    option.selected = isSelected(optionValue, params.inputValue);
    parent.appendChild(option);
  };
  inputOptions.forEach((inputOption) => {
    const optionValue = inputOption[0];
    const optionLabel = inputOption[1];
    if (Array.isArray(optionLabel)) {
      const optgroup = document.createElement("optgroup");
      optgroup.label = optionValue;
      optgroup.disabled = false;
      select.appendChild(optgroup);
      optionLabel.forEach((o2) => renderOption(optgroup, o2[1], o2[0]));
    } else {
      renderOption(select, optionLabel, optionValue);
    }
  });
  select.focus();
}
function populateRadioOptions(popup, inputOptions, params) {
  const radio = getDirectChildByClass(popup, swalClasses.radio);
  if (!radio) {
    return;
  }
  inputOptions.forEach((inputOption) => {
    const radioValue = inputOption[0];
    const radioLabel = inputOption[1];
    const radioInput = document.createElement("input");
    const radioLabelElement = document.createElement("label");
    radioInput.type = "radio";
    radioInput.name = swalClasses.radio;
    radioInput.value = radioValue;
    if (isSelected(radioValue, params.inputValue)) {
      radioInput.checked = true;
    }
    const label = document.createElement("span");
    setInnerHtml(label, radioLabel);
    label.className = swalClasses.label;
    radioLabelElement.appendChild(radioInput);
    radioLabelElement.appendChild(label);
    radio.appendChild(radioLabelElement);
  });
  const radios = radio.querySelectorAll("input");
  if (radios.length) {
    radios[0].focus();
  }
}
const formatInputOptions = (inputOptions) => {
  const result = [];
  if (inputOptions instanceof Map) {
    inputOptions.forEach((value, key) => {
      let valueFormatted = value;
      if (typeof valueFormatted === "object") {
        valueFormatted = formatInputOptions(valueFormatted);
      }
      result.push([key, valueFormatted]);
    });
  } else {
    Object.keys(inputOptions).forEach((key) => {
      let valueFormatted = inputOptions[key];
      if (typeof valueFormatted === "object") {
        valueFormatted = formatInputOptions(valueFormatted);
      }
      result.push([key, valueFormatted]);
    });
  }
  return result;
};
const isSelected = (optionValue, inputValue) => {
  return !!inputValue && inputValue.toString() === optionValue.toString();
};
const handleConfirmButtonClick = (instance) => {
  const innerParams = privateProps.innerParams.get(instance);
  instance.disableButtons();
  if (innerParams.input) {
    handleConfirmOrDenyWithInput(instance, "confirm");
  } else {
    confirm(instance, true);
  }
};
const handleDenyButtonClick = (instance) => {
  const innerParams = privateProps.innerParams.get(instance);
  instance.disableButtons();
  if (innerParams.returnInputValueOnDeny) {
    handleConfirmOrDenyWithInput(instance, "deny");
  } else {
    deny(instance, false);
  }
};
const handleCancelButtonClick = (instance, dismissWith) => {
  instance.disableButtons();
  dismissWith(DismissReason.cancel);
};
const handleConfirmOrDenyWithInput = (instance, type) => {
  const innerParams = privateProps.innerParams.get(instance);
  if (!innerParams.input) {
    error(`The "input" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);
    return;
  }
  const input = instance.getInput();
  const inputValue = getInputValue(instance, innerParams);
  if (innerParams.inputValidator) {
    handleInputValidator(instance, inputValue, type);
  } else if (input && !input.checkValidity()) {
    instance.enableButtons();
    instance.showValidationMessage(innerParams.validationMessage || input.validationMessage);
  } else if (type === "deny") {
    deny(instance, inputValue);
  } else {
    confirm(instance, inputValue);
  }
};
const handleInputValidator = (instance, inputValue, type) => {
  const innerParams = privateProps.innerParams.get(instance);
  instance.disableInput();
  const validationPromise = Promise.resolve().then(() => asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));
  validationPromise.then((validationMessage) => {
    instance.enableButtons();
    instance.enableInput();
    if (validationMessage) {
      instance.showValidationMessage(validationMessage);
    } else if (type === "deny") {
      deny(instance, inputValue);
    } else {
      confirm(instance, inputValue);
    }
  });
};
const deny = (instance, value) => {
  const innerParams = privateProps.innerParams.get(instance || void 0);
  if (innerParams.showLoaderOnDeny) {
    showLoading(getDenyButton());
  }
  if (innerParams.preDeny) {
    instance.isAwaitingPromise = true;
    const preDenyPromise = Promise.resolve().then(() => asPromise(innerParams.preDeny(value, innerParams.validationMessage)));
    preDenyPromise.then((preDenyValue) => {
      if (preDenyValue === false) {
        instance.hideLoading();
        handleAwaitingPromise(instance);
      } else {
        instance.close(
          /** @type SweetAlertResult */
          {
            isDenied: true,
            value: typeof preDenyValue === "undefined" ? value : preDenyValue
          }
        );
      }
    }).catch((error2) => rejectWith(instance || void 0, error2));
  } else {
    instance.close(
      /** @type SweetAlertResult */
      {
        isDenied: true,
        value
      }
    );
  }
};
const succeedWith = (instance, value) => {
  instance.close(
    /** @type SweetAlertResult */
    {
      isConfirmed: true,
      value
    }
  );
};
const rejectWith = (instance, error2) => {
  instance.rejectPromise(error2);
};
const confirm = (instance, value) => {
  const innerParams = privateProps.innerParams.get(instance || void 0);
  if (innerParams.showLoaderOnConfirm) {
    showLoading();
  }
  if (innerParams.preConfirm) {
    instance.resetValidationMessage();
    instance.isAwaitingPromise = true;
    const preConfirmPromise = Promise.resolve().then(() => asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));
    preConfirmPromise.then((preConfirmValue) => {
      if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {
        instance.hideLoading();
        handleAwaitingPromise(instance);
      } else {
        succeedWith(instance, typeof preConfirmValue === "undefined" ? value : preConfirmValue);
      }
    }).catch((error2) => rejectWith(instance || void 0, error2));
  } else {
    succeedWith(instance, value);
  }
};
function hideLoading() {
  const innerParams = privateProps.innerParams.get(this);
  if (!innerParams) {
    return;
  }
  const domCache = privateProps.domCache.get(this);
  hide(domCache.loader);
  if (isToast()) {
    if (innerParams.icon) {
      show(getIcon());
    }
  } else {
    showRelatedButton(domCache);
  }
  removeClass([domCache.popup, domCache.actions], swalClasses.loading);
  domCache.popup.removeAttribute("aria-busy");
  domCache.popup.removeAttribute("data-loading");
  domCache.confirmButton.disabled = false;
  domCache.denyButton.disabled = false;
  domCache.cancelButton.disabled = false;
}
const showRelatedButton = (domCache) => {
  const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute("data-button-to-replace"));
  if (buttonToReplace.length) {
    show(buttonToReplace[0], "inline-block");
  } else if (allButtonsAreHidden()) {
    hide(domCache.actions);
  }
};
function getInput() {
  const innerParams = privateProps.innerParams.get(this);
  const domCache = privateProps.domCache.get(this);
  if (!domCache) {
    return null;
  }
  return getInput$1(domCache.popup, innerParams.input);
}
function setButtonsDisabled(instance, buttons, disabled) {
  const domCache = privateProps.domCache.get(instance);
  buttons.forEach((button) => {
    domCache[button].disabled = disabled;
  });
}
function setInputDisabled(input, disabled) {
  const popup = getPopup();
  if (!popup || !input) {
    return;
  }
  if (input.type === "radio") {
    const radios = popup.querySelectorAll(`[name="${swalClasses.radio}"]`);
    for (let i2 = 0; i2 < radios.length; i2++) {
      radios[i2].disabled = disabled;
    }
  } else {
    input.disabled = disabled;
  }
}
function enableButtons() {
  setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], false);
}
function disableButtons() {
  setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], true);
}
function enableInput() {
  setInputDisabled(this.getInput(), false);
}
function disableInput() {
  setInputDisabled(this.getInput(), true);
}
function showValidationMessage(error2) {
  const domCache = privateProps.domCache.get(this);
  const params = privateProps.innerParams.get(this);
  setInnerHtml(domCache.validationMessage, error2);
  domCache.validationMessage.className = swalClasses["validation-message"];
  if (params.customClass && params.customClass.validationMessage) {
    addClass(domCache.validationMessage, params.customClass.validationMessage);
  }
  show(domCache.validationMessage);
  const input = this.getInput();
  if (input) {
    input.setAttribute("aria-invalid", "true");
    input.setAttribute("aria-describedby", swalClasses["validation-message"]);
    focusInput(input);
    addClass(input, swalClasses.inputerror);
  }
}
function resetValidationMessage() {
  const domCache = privateProps.domCache.get(this);
  if (domCache.validationMessage) {
    hide(domCache.validationMessage);
  }
  const input = this.getInput();
  if (input) {
    input.removeAttribute("aria-invalid");
    input.removeAttribute("aria-describedby");
    removeClass(input, swalClasses.inputerror);
  }
}
const defaultParams = {
  title: "",
  titleText: "",
  text: "",
  html: "",
  footer: "",
  icon: void 0,
  iconColor: void 0,
  iconHtml: void 0,
  template: void 0,
  toast: false,
  draggable: false,
  animation: true,
  theme: "light",
  showClass: {
    popup: "swal2-show",
    backdrop: "swal2-backdrop-show",
    icon: "swal2-icon-show"
  },
  hideClass: {
    popup: "swal2-hide",
    backdrop: "swal2-backdrop-hide",
    icon: "swal2-icon-hide"
  },
  customClass: {},
  target: "body",
  color: void 0,
  backdrop: true,
  heightAuto: true,
  allowOutsideClick: true,
  allowEscapeKey: true,
  allowEnterKey: true,
  stopKeydownPropagation: true,
  keydownListenerCapture: false,
  showConfirmButton: true,
  showDenyButton: false,
  showCancelButton: false,
  preConfirm: void 0,
  preDeny: void 0,
  confirmButtonText: "OK",
  confirmButtonAriaLabel: "",
  confirmButtonColor: void 0,
  denyButtonText: "No",
  denyButtonAriaLabel: "",
  denyButtonColor: void 0,
  cancelButtonText: "Cancel",
  cancelButtonAriaLabel: "",
  cancelButtonColor: void 0,
  buttonsStyling: true,
  reverseButtons: false,
  focusConfirm: true,
  focusDeny: false,
  focusCancel: false,
  returnFocus: true,
  showCloseButton: false,
  closeButtonHtml: "&times;",
  closeButtonAriaLabel: "Close this dialog",
  loaderHtml: "",
  showLoaderOnConfirm: false,
  showLoaderOnDeny: false,
  imageUrl: void 0,
  imageWidth: void 0,
  imageHeight: void 0,
  imageAlt: "",
  timer: void 0,
  timerProgressBar: false,
  width: void 0,
  padding: void 0,
  background: void 0,
  input: void 0,
  inputPlaceholder: "",
  inputLabel: "",
  inputValue: "",
  inputOptions: {},
  inputAutoFocus: true,
  inputAutoTrim: true,
  inputAttributes: {},
  inputValidator: void 0,
  returnInputValueOnDeny: false,
  validationMessage: void 0,
  grow: false,
  position: "center",
  progressSteps: [],
  currentProgressStep: void 0,
  progressStepsDistance: void 0,
  willOpen: void 0,
  didOpen: void 0,
  didRender: void 0,
  willClose: void 0,
  didClose: void 0,
  didDestroy: void 0,
  scrollbarPadding: true,
  topLayer: false
};
const updatableParams = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "color", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "draggable", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "preConfirm", "preDeny", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "theme", "willClose"];
const deprecatedParams = {
  allowEnterKey: void 0
};
const toastIncompatibleParams = ["allowOutsideClick", "allowEnterKey", "backdrop", "draggable", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"];
const isValidParameter = (paramName) => {
  return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
};
const isUpdatableParameter = (paramName) => {
  return updatableParams.indexOf(paramName) !== -1;
};
const isDeprecatedParameter = (paramName) => {
  return deprecatedParams[paramName];
};
const checkIfParamIsValid = (param) => {
  if (!isValidParameter(param)) {
    warn(`Unknown parameter "${param}"`);
  }
};
const checkIfToastParamIsValid = (param) => {
  if (toastIncompatibleParams.includes(param)) {
    warn(`The parameter "${param}" is incompatible with toasts`);
  }
};
const checkIfParamIsDeprecated = (param) => {
  const isDeprecated = isDeprecatedParameter(param);
  if (isDeprecated) {
    warnAboutDeprecation(param, isDeprecated);
  }
};
const showWarningsForParams = (params) => {
  if (params.backdrop === false && params.allowOutsideClick) {
    warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
  }
  if (params.theme && !["light", "dark", "auto", "minimal", "borderless", "bootstrap-4", "bootstrap-4-light", "bootstrap-4-dark", "bootstrap-5", "bootstrap-5-light", "bootstrap-5-dark", "material-ui", "material-ui-light", "material-ui-dark", "embed-iframe", "bulma", "bulma-light", "bulma-dark"].includes(params.theme)) {
    warn(`Invalid theme "${params.theme}"`);
  }
  for (const param in params) {
    checkIfParamIsValid(param);
    if (params.toast) {
      checkIfToastParamIsValid(param);
    }
    checkIfParamIsDeprecated(param);
  }
};
function update(params) {
  const container = getContainer();
  const popup = getPopup();
  const innerParams = privateProps.innerParams.get(this);
  if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
    warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);
    return;
  }
  const validUpdatableParams = filterValidParams(params);
  const updatedParams = Object.assign({}, innerParams, validUpdatableParams);
  showWarningsForParams(updatedParams);
  container.dataset["swal2Theme"] = updatedParams.theme;
  render(this, updatedParams);
  privateProps.innerParams.set(this, updatedParams);
  Object.defineProperties(this, {
    params: {
      value: Object.assign({}, this.params, params),
      writable: false,
      enumerable: true
    }
  });
}
const filterValidParams = (params) => {
  const validUpdatableParams = {};
  Object.keys(params).forEach((param) => {
    if (isUpdatableParameter(param)) {
      validUpdatableParams[param] = params[param];
    } else {
      warn(`Invalid parameter to update: ${param}`);
    }
  });
  return validUpdatableParams;
};
function _destroy() {
  const domCache = privateProps.domCache.get(this);
  const innerParams = privateProps.innerParams.get(this);
  if (!innerParams) {
    disposeWeakMaps(this);
    return;
  }
  if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
    globalState.swalCloseEventFinishedCallback();
    delete globalState.swalCloseEventFinishedCallback;
  }
  if (typeof innerParams.didDestroy === "function") {
    innerParams.didDestroy();
  }
  globalState.eventEmitter.emit("didDestroy");
  disposeSwal(this);
}
const disposeSwal = (instance) => {
  disposeWeakMaps(instance);
  delete instance.params;
  delete globalState.keydownHandler;
  delete globalState.keydownTarget;
  delete globalState.currentInstance;
};
const disposeWeakMaps = (instance) => {
  if (instance.isAwaitingPromise) {
    unsetWeakMaps(privateProps, instance);
    instance.isAwaitingPromise = true;
  } else {
    unsetWeakMaps(privateMethods, instance);
    unsetWeakMaps(privateProps, instance);
    delete instance.isAwaitingPromise;
    delete instance.disableButtons;
    delete instance.enableButtons;
    delete instance.getInput;
    delete instance.disableInput;
    delete instance.enableInput;
    delete instance.hideLoading;
    delete instance.disableLoading;
    delete instance.showValidationMessage;
    delete instance.resetValidationMessage;
    delete instance.close;
    delete instance.closePopup;
    delete instance.closeModal;
    delete instance.closeToast;
    delete instance.rejectPromise;
    delete instance.update;
    delete instance._destroy;
  }
};
const unsetWeakMaps = (obj, instance) => {
  for (const i2 in obj) {
    obj[i2].delete(instance);
  }
};
var instanceMethods = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _destroy,
  close,
  closeModal: close,
  closePopup: close,
  closeToast: close,
  disableButtons,
  disableInput,
  disableLoading: hideLoading,
  enableButtons,
  enableInput,
  getInput,
  handleAwaitingPromise,
  hideLoading,
  rejectPromise,
  resetValidationMessage,
  showValidationMessage,
  update
});
const handlePopupClick = (innerParams, domCache, dismissWith) => {
  if (innerParams.toast) {
    handleToastClick(innerParams, domCache, dismissWith);
  } else {
    handleModalMousedown(domCache);
    handleContainerMousedown(domCache);
    handleModalClick(innerParams, domCache, dismissWith);
  }
};
const handleToastClick = (innerParams, domCache, dismissWith) => {
  domCache.popup.onclick = () => {
    if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {
      return;
    }
    dismissWith(DismissReason.close);
  };
};
const isAnyButtonShown = (innerParams) => {
  return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);
};
let ignoreOutsideClick = false;
const handleModalMousedown = (domCache) => {
  domCache.popup.onmousedown = () => {
    domCache.container.onmouseup = function(e2) {
      domCache.container.onmouseup = () => {
      };
      if (e2.target === domCache.container) {
        ignoreOutsideClick = true;
      }
    };
  };
};
const handleContainerMousedown = (domCache) => {
  domCache.container.onmousedown = (e2) => {
    if (e2.target === domCache.container) {
      e2.preventDefault();
    }
    domCache.popup.onmouseup = function(e3) {
      domCache.popup.onmouseup = () => {
      };
      if (e3.target === domCache.popup || e3.target instanceof HTMLElement && domCache.popup.contains(e3.target)) {
        ignoreOutsideClick = true;
      }
    };
  };
};
const handleModalClick = (innerParams, domCache, dismissWith) => {
  domCache.container.onclick = (e2) => {
    if (ignoreOutsideClick) {
      ignoreOutsideClick = false;
      return;
    }
    if (e2.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
      dismissWith(DismissReason.backdrop);
    }
  };
};
const isJqueryElement = (elem) => typeof elem === "object" && elem.jquery;
const isElement = (elem) => elem instanceof Element || isJqueryElement(elem);
const argsToParams = (args) => {
  const params = {};
  if (typeof args[0] === "object" && !isElement(args[0])) {
    Object.assign(params, args[0]);
  } else {
    ["title", "html", "icon"].forEach((name, index2) => {
      const arg = args[index2];
      if (typeof arg === "string" || isElement(arg)) {
        params[name] = arg;
      } else if (arg !== void 0) {
        error(`Unexpected type of ${name}! Expected "string" or "Element", got ${typeof arg}`);
      }
    });
  }
  return params;
};
function fire(...args) {
  return new this(...args);
}
function mixin(mixinParams) {
  class MixinSwal extends this {
    _main(params, priorityMixinParams) {
      return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));
    }
  }
  return MixinSwal;
}
const getTimerLeft = () => {
  return globalState.timeout && globalState.timeout.getTimerLeft();
};
const stopTimer = () => {
  if (globalState.timeout) {
    stopTimerProgressBar();
    return globalState.timeout.stop();
  }
};
const resumeTimer = () => {
  if (globalState.timeout) {
    const remaining = globalState.timeout.start();
    animateTimerProgressBar(remaining);
    return remaining;
  }
};
const toggleTimer = () => {
  const timer = globalState.timeout;
  return timer && (timer.running ? stopTimer() : resumeTimer());
};
const increaseTimer = (ms) => {
  if (globalState.timeout) {
    const remaining = globalState.timeout.increase(ms);
    animateTimerProgressBar(remaining, true);
    return remaining;
  }
};
const isTimerRunning = () => {
  return !!(globalState.timeout && globalState.timeout.isRunning());
};
let bodyClickListenerAdded = false;
const clickHandlers = {};
function bindClickHandler(attr = "data-swal-template") {
  clickHandlers[attr] = this;
  if (!bodyClickListenerAdded) {
    document.body.addEventListener("click", bodyClickListener);
    bodyClickListenerAdded = true;
  }
}
const bodyClickListener = (event) => {
  for (let el = event.target; el && el !== document; el = el.parentNode) {
    for (const attr in clickHandlers) {
      const template = el.getAttribute(attr);
      if (template) {
        clickHandlers[attr].fire({
          template
        });
        return;
      }
    }
  }
};
let EventEmitter$1 = class EventEmitter {
  constructor() {
    this.events = {};
  }
  /**
   * @param {string} eventName
   * @returns {EventHandlers}
   */
  _getHandlersByEventName(eventName) {
    if (typeof this.events[eventName] === "undefined") {
      this.events[eventName] = [];
    }
    return this.events[eventName];
  }
  /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */
  on(eventName, eventHandler) {
    const currentHandlers = this._getHandlersByEventName(eventName);
    if (!currentHandlers.includes(eventHandler)) {
      currentHandlers.push(eventHandler);
    }
  }
  /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */
  once(eventName, eventHandler) {
    const onceFn = (...args) => {
      this.removeListener(eventName, onceFn);
      eventHandler.apply(this, args);
    };
    this.on(eventName, onceFn);
  }
  /**
   * @param {string} eventName
   * @param {Array} args
   */
  emit(eventName, ...args) {
    this._getHandlersByEventName(eventName).forEach(
      /**
       * @param {EventHandler} eventHandler
       */
      (eventHandler) => {
        try {
          eventHandler.apply(this, args);
        } catch (error2) {
          console.error(error2);
        }
      }
    );
  }
  /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */
  removeListener(eventName, eventHandler) {
    const currentHandlers = this._getHandlersByEventName(eventName);
    const index2 = currentHandlers.indexOf(eventHandler);
    if (index2 > -1) {
      currentHandlers.splice(index2, 1);
    }
  }
  /**
   * @param {string} eventName
   */
  removeAllListeners(eventName) {
    if (this.events[eventName] !== void 0) {
      this.events[eventName].length = 0;
    }
  }
  reset() {
    this.events = {};
  }
};
globalState.eventEmitter = new EventEmitter$1();
const on = (eventName, eventHandler) => {
  globalState.eventEmitter.on(eventName, eventHandler);
};
const once = (eventName, eventHandler) => {
  globalState.eventEmitter.once(eventName, eventHandler);
};
const off = (eventName, eventHandler) => {
  if (!eventName) {
    globalState.eventEmitter.reset();
    return;
  }
  if (eventHandler) {
    globalState.eventEmitter.removeListener(eventName, eventHandler);
  } else {
    globalState.eventEmitter.removeAllListeners(eventName);
  }
};
var staticMethods = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  argsToParams,
  bindClickHandler,
  clickCancel,
  clickConfirm,
  clickDeny,
  enableLoading: showLoading,
  fire,
  getActions,
  getCancelButton,
  getCloseButton,
  getConfirmButton,
  getContainer,
  getDenyButton,
  getFocusableElements,
  getFooter,
  getHtmlContainer,
  getIcon,
  getIconContent,
  getImage,
  getInputLabel,
  getLoader,
  getPopup,
  getProgressSteps,
  getTimerLeft,
  getTimerProgressBar,
  getTitle,
  getValidationMessage,
  increaseTimer,
  isDeprecatedParameter,
  isLoading,
  isTimerRunning,
  isUpdatableParameter,
  isValidParameter,
  isVisible,
  mixin,
  off,
  on,
  once,
  resumeTimer,
  showLoading,
  stopTimer,
  toggleTimer
});
let Timer$1 = class Timer {
  /**
   * @param {() => void} callback
   * @param {number} delay
   */
  constructor(callback, delay) {
    this.callback = callback;
    this.remaining = delay;
    this.running = false;
    this.start();
  }
  /**
   * @returns {number}
   */
  start() {
    if (!this.running) {
      this.running = true;
      this.started = /* @__PURE__ */ new Date();
      this.id = setTimeout(this.callback, this.remaining);
    }
    return this.remaining;
  }
  /**
   * @returns {number}
   */
  stop() {
    if (this.started && this.running) {
      this.running = false;
      clearTimeout(this.id);
      this.remaining -= (/* @__PURE__ */ new Date()).getTime() - this.started.getTime();
    }
    return this.remaining;
  }
  /**
   * @param {number} n
   * @returns {number}
   */
  increase(n2) {
    const running = this.running;
    if (running) {
      this.stop();
    }
    this.remaining += n2;
    if (running) {
      this.start();
    }
    return this.remaining;
  }
  /**
   * @returns {number}
   */
  getTimerLeft() {
    if (this.running) {
      this.stop();
      this.start();
    }
    return this.remaining;
  }
  /**
   * @returns {boolean}
   */
  isRunning() {
    return this.running;
  }
};
const swalStringParams = ["swal-title", "swal-html", "swal-footer"];
const getTemplateParams = (params) => {
  const template = typeof params.template === "string" ? (
    /** @type {HTMLTemplateElement} */
    document.querySelector(params.template)
  ) : params.template;
  if (!template) {
    return {};
  }
  const templateContent = template.content;
  showWarningsForElements(templateContent);
  const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
  return result;
};
const getSwalParams = (templateContent) => {
  const result = {};
  const swalParams = Array.from(templateContent.querySelectorAll("swal-param"));
  swalParams.forEach((param) => {
    showWarningsForAttributes(param, ["name", "value"]);
    const paramName = (
      /** @type {keyof SweetAlertOptions} */
      param.getAttribute("name")
    );
    const value = param.getAttribute("value");
    if (!paramName || !value) {
      return;
    }
    if (typeof defaultParams[paramName] === "boolean") {
      result[paramName] = value !== "false";
    } else if (typeof defaultParams[paramName] === "object") {
      result[paramName] = JSON.parse(value);
    } else {
      result[paramName] = value;
    }
  });
  return result;
};
const getSwalFunctionParams = (templateContent) => {
  const result = {};
  const swalFunctions = Array.from(templateContent.querySelectorAll("swal-function-param"));
  swalFunctions.forEach((param) => {
    const paramName = (
      /** @type {keyof SweetAlertOptions} */
      param.getAttribute("name")
    );
    const value = param.getAttribute("value");
    if (!paramName || !value) {
      return;
    }
    result[paramName] = new Function(`return ${value}`)();
  });
  return result;
};
const getSwalButtons = (templateContent) => {
  const result = {};
  const swalButtons = Array.from(templateContent.querySelectorAll("swal-button"));
  swalButtons.forEach((button) => {
    showWarningsForAttributes(button, ["type", "color", "aria-label"]);
    const type = button.getAttribute("type");
    if (!type || !["confirm", "cancel", "deny"].includes(type)) {
      return;
    }
    result[`${type}ButtonText`] = button.innerHTML;
    result[`show${capitalizeFirstLetter(type)}Button`] = true;
    if (button.hasAttribute("color")) {
      result[`${type}ButtonColor`] = button.getAttribute("color");
    }
    if (button.hasAttribute("aria-label")) {
      result[`${type}ButtonAriaLabel`] = button.getAttribute("aria-label");
    }
  });
  return result;
};
const getSwalImage = (templateContent) => {
  const result = {};
  const image = templateContent.querySelector("swal-image");
  if (image) {
    showWarningsForAttributes(image, ["src", "width", "height", "alt"]);
    if (image.hasAttribute("src")) {
      result.imageUrl = image.getAttribute("src") || void 0;
    }
    if (image.hasAttribute("width")) {
      result.imageWidth = image.getAttribute("width") || void 0;
    }
    if (image.hasAttribute("height")) {
      result.imageHeight = image.getAttribute("height") || void 0;
    }
    if (image.hasAttribute("alt")) {
      result.imageAlt = image.getAttribute("alt") || void 0;
    }
  }
  return result;
};
const getSwalIcon = (templateContent) => {
  const result = {};
  const icon = templateContent.querySelector("swal-icon");
  if (icon) {
    showWarningsForAttributes(icon, ["type", "color"]);
    if (icon.hasAttribute("type")) {
      result.icon = icon.getAttribute("type");
    }
    if (icon.hasAttribute("color")) {
      result.iconColor = icon.getAttribute("color");
    }
    result.iconHtml = icon.innerHTML;
  }
  return result;
};
const getSwalInput = (templateContent) => {
  const result = {};
  const input = templateContent.querySelector("swal-input");
  if (input) {
    showWarningsForAttributes(input, ["type", "label", "placeholder", "value"]);
    result.input = input.getAttribute("type") || "text";
    if (input.hasAttribute("label")) {
      result.inputLabel = input.getAttribute("label");
    }
    if (input.hasAttribute("placeholder")) {
      result.inputPlaceholder = input.getAttribute("placeholder");
    }
    if (input.hasAttribute("value")) {
      result.inputValue = input.getAttribute("value");
    }
  }
  const inputOptions = Array.from(templateContent.querySelectorAll("swal-input-option"));
  if (inputOptions.length) {
    result.inputOptions = {};
    inputOptions.forEach((option) => {
      showWarningsForAttributes(option, ["value"]);
      const optionValue = option.getAttribute("value");
      if (!optionValue) {
        return;
      }
      const optionName = option.innerHTML;
      result.inputOptions[optionValue] = optionName;
    });
  }
  return result;
};
const getSwalStringParams = (templateContent, paramNames) => {
  const result = {};
  for (const i2 in paramNames) {
    const paramName = paramNames[i2];
    const tag = templateContent.querySelector(paramName);
    if (tag) {
      showWarningsForAttributes(tag, []);
      result[paramName.replace(/^swal-/, "")] = tag.innerHTML.trim();
    }
  }
  return result;
};
const showWarningsForElements = (templateContent) => {
  const allowedElements = swalStringParams.concat(["swal-param", "swal-function-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]);
  Array.from(templateContent.children).forEach((el) => {
    const tagName = el.tagName.toLowerCase();
    if (!allowedElements.includes(tagName)) {
      warn(`Unrecognized element <${tagName}>`);
    }
  });
};
const showWarningsForAttributes = (el, allowedAttributes) => {
  Array.from(el.attributes).forEach((attribute) => {
    if (allowedAttributes.indexOf(attribute.name) === -1) {
      warn([`Unrecognized attribute "${attribute.name}" on <${el.tagName.toLowerCase()}>.`, `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(", ")}` : "To set the value, use HTML within the element."}`]);
    }
  });
};
const SHOW_CLASS_TIMEOUT = 10;
const openPopup = (params) => {
  const container = getContainer();
  const popup = getPopup();
  if (typeof params.willOpen === "function") {
    params.willOpen(popup);
  }
  globalState.eventEmitter.emit("willOpen", popup);
  const bodyStyles = window.getComputedStyle(document.body);
  const initialBodyOverflow = bodyStyles.overflowY;
  addClasses(container, popup, params);
  setTimeout(() => {
    setScrollingVisibility(container, popup);
  }, SHOW_CLASS_TIMEOUT);
  if (isModal()) {
    fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
    setAriaHidden();
  }
  if (!isToast() && !globalState.previousActiveElement) {
    globalState.previousActiveElement = document.activeElement;
  }
  if (typeof params.didOpen === "function") {
    setTimeout(() => params.didOpen(popup));
  }
  globalState.eventEmitter.emit("didOpen", popup);
};
const swalOpenAnimationFinished = (event) => {
  const popup = getPopup();
  if (event.target !== popup) {
    return;
  }
  const container = getContainer();
  popup.removeEventListener("animationend", swalOpenAnimationFinished);
  popup.removeEventListener("transitionend", swalOpenAnimationFinished);
  container.style.overflowY = "auto";
  removeClass(container, swalClasses["no-transition"]);
};
const setScrollingVisibility = (container, popup) => {
  if (hasCssAnimation(popup)) {
    container.style.overflowY = "hidden";
    popup.addEventListener("animationend", swalOpenAnimationFinished);
    popup.addEventListener("transitionend", swalOpenAnimationFinished);
  } else {
    container.style.overflowY = "auto";
  }
};
const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow) => {
  iOSfix();
  if (scrollbarPadding && initialBodyOverflow !== "hidden") {
    replaceScrollbarWithPadding(initialBodyOverflow);
  }
  setTimeout(() => {
    container.scrollTop = 0;
  });
};
const addClasses = (container, popup, params) => {
  addClass(container, params.showClass.backdrop);
  if (params.animation) {
    popup.style.setProperty("opacity", "0", "important");
    show(popup, "grid");
    setTimeout(() => {
      addClass(popup, params.showClass.popup);
      popup.style.removeProperty("opacity");
    }, SHOW_CLASS_TIMEOUT);
  } else {
    show(popup, "grid");
  }
  addClass([document.documentElement, document.body], swalClasses.shown);
  if (params.heightAuto && params.backdrop && !params.toast) {
    addClass([document.documentElement, document.body], swalClasses["height-auto"]);
  }
};
var defaultInputValidators = {
  /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */
  email: (string2, validationMessage) => {
    return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(string2) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid email address");
  },
  /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */
  url: (string2, validationMessage) => {
    return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string2) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid URL");
  }
};
function setDefaultInputValidators(params) {
  if (params.inputValidator) {
    return;
  }
  if (params.input === "email") {
    params.inputValidator = defaultInputValidators["email"];
  }
  if (params.input === "url") {
    params.inputValidator = defaultInputValidators["url"];
  }
}
function validateCustomTargetElement(params) {
  if (!params.target || typeof params.target === "string" && !document.querySelector(params.target) || typeof params.target !== "string" && !params.target.appendChild) {
    warn('Target parameter is not valid, defaulting to "body"');
    params.target = "body";
  }
}
function setParameters(params) {
  setDefaultInputValidators(params);
  if (params.showLoaderOnConfirm && !params.preConfirm) {
    warn("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request");
  }
  validateCustomTargetElement(params);
  if (typeof params.title === "string") {
    params.title = params.title.split("\n").join("<br />");
  }
  init(params);
}
let currentInstance;
var _promise = /* @__PURE__ */ new WeakMap();
class SweetAlert {
  /**
   * @param {...(SweetAlertOptions | string)} args
   * @this {SweetAlert}
   */
  constructor(...args) {
    _classPrivateFieldInitSpec(this, _promise, void 0);
    if (typeof window === "undefined") {
      return;
    }
    currentInstance = this;
    const outerParams = Object.freeze(this.constructor.argsToParams(args));
    this.params = outerParams;
    this.isAwaitingPromise = false;
    _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));
  }
  _main(userParams, mixinParams = {}) {
    showWarningsForParams(Object.assign({}, mixinParams, userParams));
    if (globalState.currentInstance) {
      const swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);
      const {
        isAwaitingPromise
      } = globalState.currentInstance;
      globalState.currentInstance._destroy();
      if (!isAwaitingPromise) {
        swalPromiseResolve({
          isDismissed: true
        });
      }
      if (isModal()) {
        unsetAriaHidden();
      }
    }
    globalState.currentInstance = currentInstance;
    const innerParams = prepareParams(userParams, mixinParams);
    setParameters(innerParams);
    Object.freeze(innerParams);
    if (globalState.timeout) {
      globalState.timeout.stop();
      delete globalState.timeout;
    }
    clearTimeout(globalState.restoreFocusTimeout);
    const domCache = populateDomCache(currentInstance);
    render(currentInstance, innerParams);
    privateProps.innerParams.set(currentInstance, innerParams);
    return swalPromise(currentInstance, domCache, innerParams);
  }
  // `catch` cannot be the name of a module export, so we define our thenable methods here instead
  then(onFulfilled) {
    return _classPrivateFieldGet2(_promise, this).then(onFulfilled);
  }
  finally(onFinally) {
    return _classPrivateFieldGet2(_promise, this).finally(onFinally);
  }
}
const swalPromise = (instance, domCache, innerParams) => {
  return new Promise((resolve, reject) => {
    const dismissWith = (dismiss) => {
      instance.close({
        isDismissed: true,
        dismiss,
        isConfirmed: false,
        isDenied: false
      });
    };
    privateMethods.swalPromiseResolve.set(instance, resolve);
    privateMethods.swalPromiseReject.set(instance, reject);
    domCache.confirmButton.onclick = () => {
      handleConfirmButtonClick(instance);
    };
    domCache.denyButton.onclick = () => {
      handleDenyButtonClick(instance);
    };
    domCache.cancelButton.onclick = () => {
      handleCancelButtonClick(instance, dismissWith);
    };
    domCache.closeButton.onclick = () => {
      dismissWith(DismissReason.close);
    };
    handlePopupClick(innerParams, domCache, dismissWith);
    addKeydownHandler(globalState, innerParams, dismissWith);
    handleInputOptionsAndValue(instance, innerParams);
    openPopup(innerParams);
    setupTimer(globalState, innerParams, dismissWith);
    initFocus(domCache, innerParams);
    setTimeout(() => {
      domCache.container.scrollTop = 0;
    });
  });
};
const prepareParams = (userParams, mixinParams) => {
  const templateParams = getTemplateParams(userParams);
  const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams);
  params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
  params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
  if (params.animation === false) {
    params.showClass = {
      backdrop: "swal2-noanimation"
    };
    params.hideClass = {};
  }
  return params;
};
const populateDomCache = (instance) => {
  const domCache = {
    popup: getPopup(),
    container: getContainer(),
    actions: getActions(),
    confirmButton: getConfirmButton(),
    denyButton: getDenyButton(),
    cancelButton: getCancelButton(),
    loader: getLoader(),
    closeButton: getCloseButton(),
    validationMessage: getValidationMessage(),
    progressSteps: getProgressSteps()
  };
  privateProps.domCache.set(instance, domCache);
  return domCache;
};
const setupTimer = (globalState2, innerParams, dismissWith) => {
  const timerProgressBar = getTimerProgressBar();
  hide(timerProgressBar);
  if (innerParams.timer) {
    globalState2.timeout = new Timer$1(() => {
      dismissWith("timer");
      delete globalState2.timeout;
    }, innerParams.timer);
    if (innerParams.timerProgressBar) {
      show(timerProgressBar);
      applyCustomClass(timerProgressBar, innerParams, "timerProgressBar");
      setTimeout(() => {
        if (globalState2.timeout && globalState2.timeout.running) {
          animateTimerProgressBar(innerParams.timer);
        }
      });
    }
  }
};
const initFocus = (domCache, innerParams) => {
  if (innerParams.toast) {
    return;
  }
  if (!callIfFunction(innerParams.allowEnterKey)) {
    warnAboutDeprecation("allowEnterKey");
    blurActiveElement();
    return;
  }
  if (focusAutofocus(domCache)) {
    return;
  }
  if (focusButton(domCache, innerParams)) {
    return;
  }
  setFocus(-1, 1);
};
const focusAutofocus = (domCache) => {
  const autofocusElements = Array.from(domCache.popup.querySelectorAll("[autofocus]"));
  for (const autofocusElement of autofocusElements) {
    if (autofocusElement instanceof HTMLElement && isVisible$1(autofocusElement)) {
      autofocusElement.focus();
      return true;
    }
  }
  return false;
};
const focusButton = (domCache, innerParams) => {
  if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {
    domCache.denyButton.focus();
    return true;
  }
  if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {
    domCache.cancelButton.focus();
    return true;
  }
  if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {
    domCache.confirmButton.focus();
    return true;
  }
  return false;
};
const blurActiveElement = () => {
  if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === "function") {
    document.activeElement.blur();
  }
};
SweetAlert.prototype.disableButtons = disableButtons;
SweetAlert.prototype.enableButtons = enableButtons;
SweetAlert.prototype.getInput = getInput;
SweetAlert.prototype.disableInput = disableInput;
SweetAlert.prototype.enableInput = enableInput;
SweetAlert.prototype.hideLoading = hideLoading;
SweetAlert.prototype.disableLoading = hideLoading;
SweetAlert.prototype.showValidationMessage = showValidationMessage;
SweetAlert.prototype.resetValidationMessage = resetValidationMessage;
SweetAlert.prototype.close = close;
SweetAlert.prototype.closePopup = close;
SweetAlert.prototype.closeModal = close;
SweetAlert.prototype.closeToast = close;
SweetAlert.prototype.rejectPromise = rejectPromise;
SweetAlert.prototype.update = update;
SweetAlert.prototype._destroy = _destroy;
Object.assign(SweetAlert, staticMethods);
Object.keys(instanceMethods).forEach((key) => {
  SweetAlert[key] = function(...args) {
    if (currentInstance && currentInstance[key]) {
      return currentInstance[key](...args);
    }
    return null;
  };
});
SweetAlert.DismissReason = DismissReason;
SweetAlert.version = "11.26.4";
const Swal = SweetAlert;
Swal.default = Swal;
"undefined" != typeof document && (function(e2, t2) {
  var n2 = e2.createElement("style");
  if (e2.getElementsByTagName("head")[0].appendChild(n2), n2.styleSheet) n2.styleSheet.disabled || (n2.styleSheet.cssText = t2);
  else try {
    n2.innerHTML = t2;
  } catch (e3) {
    n2.innerText = t2;
  }
})(document, ':root{--swal2-outline: 0 0 0 3px rgba(100, 150, 200, 0.5);--swal2-container-padding: 0.625em;--swal2-backdrop: rgba(0, 0, 0, 0.4);--swal2-backdrop-transition: background-color 0.15s;--swal2-width: 32em;--swal2-padding: 0 0 1.25em;--swal2-border: none;--swal2-border-radius: 0.3125rem;--swal2-background: white;--swal2-color: #545454;--swal2-show-animation: swal2-show 0.3s;--swal2-hide-animation: swal2-hide 0.15s forwards;--swal2-icon-zoom: 1;--swal2-icon-animations: true;--swal2-title-padding: 0.8em 1em 0;--swal2-html-container-padding: 1em 1.6em 0.3em;--swal2-input-border: 1px solid #d9d9d9;--swal2-input-border-radius: 0.1875em;--swal2-input-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-background: transparent;--swal2-input-transition: border-color 0.2s, box-shadow 0.2s;--swal2-input-hover-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-focus-border: 1px solid #b4dbed;--swal2-input-focus-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px rgba(100, 150, 200, 0.5);--swal2-progress-step-background: #add8e6;--swal2-validation-message-background: #f0f0f0;--swal2-validation-message-color: #666;--swal2-footer-border-color: #eee;--swal2-footer-background: transparent;--swal2-footer-color: inherit;--swal2-timer-progress-bar-background: rgba(0, 0, 0, 0.3);--swal2-close-button-position: initial;--swal2-close-button-inset: auto;--swal2-close-button-font-size: 2.5em;--swal2-close-button-color: #ccc;--swal2-close-button-transition: color 0.2s, box-shadow 0.2s;--swal2-close-button-outline: initial;--swal2-close-button-box-shadow: inset 0 0 0 3px transparent;--swal2-close-button-focus-box-shadow: inset var(--swal2-outline);--swal2-close-button-hover-transform: none;--swal2-actions-justify-content: center;--swal2-actions-width: auto;--swal2-actions-margin: 1.25em auto 0;--swal2-actions-padding: 0;--swal2-actions-border-radius: 0;--swal2-actions-background: transparent;--swal2-action-button-transition: background-color 0.2s, box-shadow 0.2s;--swal2-action-button-hover: black 10%;--swal2-action-button-active: black 10%;--swal2-confirm-button-box-shadow: none;--swal2-confirm-button-border-radius: 0.25em;--swal2-confirm-button-background-color: #7066e0;--swal2-confirm-button-color: #fff;--swal2-deny-button-box-shadow: none;--swal2-deny-button-border-radius: 0.25em;--swal2-deny-button-background-color: #dc3741;--swal2-deny-button-color: #fff;--swal2-cancel-button-box-shadow: none;--swal2-cancel-button-border-radius: 0.25em;--swal2-cancel-button-background-color: #6e7881;--swal2-cancel-button-color: #fff;--swal2-toast-show-animation: swal2-toast-show 0.5s;--swal2-toast-hide-animation: swal2-toast-hide 0.1s forwards;--swal2-toast-border: none;--swal2-toast-box-shadow: 0 0 1px hsl(0deg 0% 0% / 0.075), 0 1px 2px hsl(0deg 0% 0% / 0.075), 1px 2px 4px hsl(0deg 0% 0% / 0.075), 1px 3px 8px hsl(0deg 0% 0% / 0.075), 2px 4px 16px hsl(0deg 0% 0% / 0.075)}[data-swal2-theme=dark]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white);--swal2-timer-progress-bar-background: rgba(255, 255, 255, 0.7)}@media(prefers-color-scheme: dark){[data-swal2-theme=auto]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white);--swal2-timer-progress-bar-background: rgba(255, 255, 255, 0.7)}}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px var(--swal2-backdrop)}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}@media print{body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown) .swal2-container{position:static !important}}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:"top-start     top            top-end" "center-start  center         center-end" "bottom-start  bottom-center  bottom-end";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:var(--swal2-container-padding);overflow-x:hidden;transition:var(--swal2-backdrop-transition);-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:var(--swal2-backdrop)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container)[popover]{width:auto;border:0}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:var(--swal2-width);max-width:100%;padding:var(--swal2-padding);border:var(--swal2-border);border-radius:var(--swal2-border-radius);background:var(--swal2-background);color:var(--swal2-color);font-family:inherit;font-size:1rem;container-name:swal2-popup}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable{cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable div:where(.swal2-icon){cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging{cursor:grabbing}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging div:where(.swal2-icon){cursor:grabbing}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:var(--swal2-title-padding);color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;overflow-wrap:break-word;cursor:initial}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:var(--swal2-actions-justify-content);width:var(--swal2-actions-width);margin:var(--swal2-actions-margin);padding:var(--swal2-actions-padding);border-radius:var(--swal2-actions-border-radius);background:var(--swal2-actions-background)}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:var(--swal2-action-button-transition);border:none;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border-radius:var(--swal2-confirm-button-border-radius);background:initial;background-color:var(--swal2-confirm-button-background-color);box-shadow:var(--swal2-confirm-button-box-shadow);color:var(--swal2-confirm-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):hover{background-color:color-mix(in srgb, var(--swal2-confirm-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):active{background-color:color-mix(in srgb, var(--swal2-confirm-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border-radius:var(--swal2-deny-button-border-radius);background:initial;background-color:var(--swal2-deny-button-background-color);box-shadow:var(--swal2-deny-button-box-shadow);color:var(--swal2-deny-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):hover{background-color:color-mix(in srgb, var(--swal2-deny-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):active{background-color:color-mix(in srgb, var(--swal2-deny-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border-radius:var(--swal2-cancel-button-border-radius);background:initial;background-color:var(--swal2-cancel-button-background-color);box-shadow:var(--swal2-cancel-button-box-shadow);color:var(--swal2-cancel-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):hover{background-color:color-mix(in srgb, var(--swal2-cancel-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):active{background-color:color-mix(in srgb, var(--swal2-cancel-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none;box-shadow:var(--swal2-action-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-styled)[disabled]:not(.swal2-loading){opacity:.4}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid var(--swal2-footer-border-color);background:var(--swal2-footer-background);color:var(--swal2-footer-color);font-size:1em;text-align:center;cursor:initial}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:var(--swal2-border-radius);border-bottom-left-radius:var(--swal2-border-radius)}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:var(--swal2-timer-progress-bar-background)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em;cursor:initial}div:where(.swal2-container) button:where(.swal2-close){position:var(--swal2-close-button-position);inset:var(--swal2-close-button-inset);z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:var(--swal2-close-button-transition);border:none;border-radius:var(--swal2-border-radius);outline:var(--swal2-close-button-outline);background:rgba(0,0,0,0);color:var(--swal2-close-button-color);font-family:monospace;font-size:var(--swal2-close-button-font-size);cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:var(--swal2-close-button-hover-transform);background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:var(--swal2-close-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-html-container){z-index:1;justify-content:center;margin:0;padding:var(--swal2-html-container-padding);overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;overflow-wrap:break-word;word-break:break-word;cursor:initial}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:var(--swal2-input-transition);border:var(--swal2-input-border);border-radius:var(--swal2-input-border-radius);background:var(--swal2-input-background);box-shadow:var(--swal2-input-box-shadow);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):hover,div:where(.swal2-container) input:where(.swal2-file):hover,div:where(.swal2-container) textarea:where(.swal2-textarea):hover{box-shadow:var(--swal2-input-hover-box-shadow)}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:var(--swal2-input-focus-border);outline:none;box-shadow:var(--swal2-input-focus-box-shadow)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:var(--swal2-background)}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:var(--swal2-input-background);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:var(--swal2-input-background);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:var(--swal2-background);color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:var(--swal2-validation-message-background);color:var(--swal2-validation-message-color);font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:var(--swal2-progress-step-background);color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:var(--swal2-progress-step-background)}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;zoom:var(--swal2-icon-zoom);border:.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}}div:where(.swal2-icon).swal2-warning{border-color:#f8bb86;color:#f8bb86}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}}div:where(.swal2-icon).swal2-info{border-color:#3fc3ee;color:#3fc3ee}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}}div:where(.swal2-icon).swal2-question{border-color:#87adbd;color:#87adbd}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:var(--swal2-show-animation)}.swal2-hide{animation:var(--swal2-hide-animation)}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;border:var(--swal2-toast-border);background:var(--swal2-background);box-shadow:var(--swal2-toast-box-shadow);pointer-events:all}.swal2-toast>*{grid-column:2}.swal2-toast h2:where(.swal2-title){margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-toast .swal2-loading{justify-content:center}.swal2-toast input:where(.swal2-input){height:2em;margin:.5em;font-size:1em}.swal2-toast .swal2-validation-message{font-size:1em}.swal2-toast div:where(.swal2-footer){margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-toast button:where(.swal2-close){grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-toast div:where(.swal2-html-container){margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-toast div:where(.swal2-html-container):empty{padding:0}.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-toast div:where(.swal2-actions){justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-toast button:where(.swal2-styled){margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}@container swal2-popup style(--swal2-icon-animations:true){.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}}.swal2-toast.swal2-show{animation:var(--swal2-toast-show-animation)}.swal2-toast.swal2-hide{animation:var(--swal2-toast-hide-animation)}@keyframes swal2-show{0%{transform:translate3d(0, -50px, 0) scale(0.9);opacity:0}100%{transform:translate3d(0, 0, 0) scale(1);opacity:1}}@keyframes swal2-hide{0%{transform:translate3d(0, 0, 0) scale(1);opacity:1}100%{transform:translate3d(0, -50px, 0) scale(0.9);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}');
class IDomainServices {
  // ===== 2. LOGIN SYSTEM AND USER ACCOUNT MANAGEMENT =====
  // Authentication methods - maps to APIServices_old.js
  async login(credentials, dispatch) {
    throw new Error("Not implemented");
  }
  async logout() {
    throw new Error("Not implemented");
  }
  async refreshToken() {
    throw new Error("Not implemented");
  }
  // Password management - maps to APIServices_old.js
  async changePassword(payload, dispatch) {
    throw new Error("Not implemented");
  }
  async initiatePasswordRecovery(email2, dispatch) {
    throw new Error("Not implemented");
  }
  async resetPassword(payload, dispatch) {
    throw new Error("Not implemented");
  }
  async forgotPassword(data, dispatch) {
    throw new Error("Not implemented");
  }
  // Profile picture management - maps to uploadProfilePicture in APIServices_old.js
  async uploadProfilePicture(file, dispatch) {
    throw new Error("Not implemented");
  }
  // User account queries - maps to APIServices_old.js
  async getCurrentUser(dispatch) {
    throw new Error("Not implemented");
  }
  async getUser(userId, dispatch) {
    throw new Error("Not implemented");
  }
  async getAllUsers(dispatch) {
    throw new Error("Not implemented");
  }
  async getUsersByType(userType, dispatch) {
    throw new Error("Not implemented");
  }
  async searchUsers(searchQuery, dispatch) {
    throw new Error("Not implemented");
  }
  // User account commands - maps to APIServices_old.js
  async createUser(userData, dispatch) {
    throw new Error("Not implemented");
  }
  async updateUserProfile(payload, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteUser(userId, dispatch) {
    throw new Error("Not implemented");
  }
  async bulkCreateUsers(users, dispatch) {
    throw new Error("Not implemented");
  }
  // ===== 3. DASHBOARD =====
  // Profile access and self-service - maps to getUserProfile/updateUserProfile in APIServices_old.js
  async getProfile(dispatch) {
    throw new Error("Not implemented");
  }
  async updateProfile(profileData, dispatch) {
    throw new Error("Not implemented");
  }
  // Backward-compatible method names (for existing components)
  async getUserProfile(dispatch) {
    throw new Error("Not implemented");
  }
  async updateUserProfile(payload, dispatch) {
    throw new Error("Not implemented");
  }
  // ===== 5. EMPLOYEE INFORMATION MANAGER =====
  // Employee profile queries - maps to APIServices_old.js
  async getCurrentEmployee(dispatch) {
    throw new Error("Not implemented");
  }
  async getCurrentEmployeeData(dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployeeProfile(dispatch) {
    throw new Error("Not implemented");
  }
  async getAllEmployees(dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployeeById(employeeId, dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployee(employeeId, dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployeesForManager(dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployeeForManager(managerId, employeeId, dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployeesByDepartment(deptCode, dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployeesByDepartmentForManager(dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployeesByManager(managerId, dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployeesByStatus(status, dispatch) {
    throw new Error("Not implemented");
  }
  async searchEmployees(searchQuery, dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployeesByJobRole(jobRole, dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployeesByContractType(contractType, dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployees(dispatch) {
    throw new Error("Not implemented");
  }
  // Employee profile commands - maps to APIServices_old.js
  async updateEmployeeProfile(profileData, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteEmployee(employeeId, dispatch) {
    throw new Error("Not implemented");
  }
  // ===== 4. PERFORMANCE MANAGER =====
  // Department Management - maps to APIServices_old.js
  async getAllDepartments(limit, dispatch) {
    throw new Error("Not implemented");
  }
  async createDepartment(payload, dispatch) {
    throw new Error("Not implemented");
  }
  async getDepartment(departmentId, dispatch) {
    throw new Error("Not implemented");
  }
  async updateDepartment(sno, payload, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteDepartment(departmentId, dispatch) {
    throw new Error("Not implemented");
  }
  // Manager Management - maps to APIServices_old.js
  async getCurrentManager(dispatch) {
    throw new Error("Not implemented");
  }
  async createManager(managerData, dispatch) {
    throw new Error("Not implemented");
  }
  async getManager(id, dispatch) {
    throw new Error("Not implemented");
  }
  async getallmanagers(dispatch) {
    throw new Error("Not implemented");
  }
  async updateManager(id, managerData, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteManager(id, dispatch) {
    throw new Error("Not implemented");
  }
  async getManagerUsers(dispatch) {
    throw new Error("Not implemented");
  }
  async getManagersByDepartment(departmentName) {
    throw new Error("Not implemented");
  }
  async getManagerByDepartment(departmentName, dispatch) {
    throw new Error("Not implemented");
  }
  async getDepartmentManager(departmentCode, dispatch) {
    throw new Error("Not implemented");
  }
  // Goals Management - maps to APIServices_old.js
  async getAllGoals(dispatch) {
    throw new Error("Not implemented");
  }
  async createGoal(goalData, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteGoal(goalId, dispatch) {
    throw new Error("Not implemented");
  }
  async approveGoal(sno, dispatch) {
    throw new Error("Not implemented");
  }
  async rejectGoal(sno, dispatch) {
    throw new Error("Not implemented");
  }
  // Goal Progress Tracking - maps to APIServices_old.js
  async createGoalProgress(goalId, progressData, dispatch) {
    throw new Error("Not implemented");
  }
  async getGoalProgressHistory(goalId, dispatch) {
    throw new Error("Not implemented");
  }
  async getLatestGoalProgress(goalId, dispatch) {
    throw new Error("Not implemented");
  }
  async updateGoalProgress(progressId, progressData, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteGoalProgress(progressId, dispatch) {
    throw new Error("Not implemented");
  }
  // Business Goals - maps to APIServices_old.js
  async getAllBusinessGoals(dispatch) {
    throw new Error("Not implemented");
  }
  async createBusinessGoal(goalData, dispatch) {
    throw new Error("Not implemented");
  }
  async updateBusinessGoal(sno, goalData, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteBusinessGoal(sno, dispatch) {
    throw new Error("Not implemented");
  }
  // Goal Categories - maps to APIServices_old.js
  async getAllGoalCategories(dispatch) {
    throw new Error("Not implemented");
  }
  async createGoalCategory(categoryData, dispatch) {
    throw new Error("Not implemented");
  }
  async updateGoalCategory(categoryId, categoryData, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteGoalCategory(categoryId, dispatch) {
    throw new Error("Not implemented");
  }
  async getGoalCategory(categoryId, dispatch) {
    throw new Error("Not implemented");
  }
  // Performance Criteria - maps to APIServices_old.js
  async createPcriteria(payload, dispatch) {
    throw new Error("Not implemented");
  }
  async getPcriteria(sno, dispatch) {
    throw new Error("Not implemented");
  }
  async updatePcriteria(sno, payload, dispatch) {
    throw new Error("Not implemented");
  }
  async deletePcriteria(sno, dispatch) {
    throw new Error("Not implemented");
  }
  async getAllPcriteria(dispatch) {
    throw new Error("Not implemented");
  }
  // Performance Metrics - maps to APIServices_old.js
  async getAllPerformanceMetrics(dispatch) {
    throw new Error("Not implemented");
  }
  async createPerformanceMetric(metricData, dispatch) {
    throw new Error("Not implemented");
  }
  async updatePerformanceMetric(metricId, metricData, dispatch) {
    throw new Error("Not implemented");
  }
  async deletePerformanceMetric(metricId, dispatch) {
    throw new Error("Not implemented");
  }
  // Development Plans - maps to APIServices_old.js
  async getAllDevelopmentPlans(dispatch) {
    throw new Error("Not implemented");
  }
  async createDevelopmentPlan(planData, dispatch) {
    throw new Error("Not implemented");
  }
  async updateDevelopmentPlan(planId, planData, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteDevelopmentPlan(planId, dispatch) {
    throw new Error("Not implemented");
  }
  // Appraisal Periods - maps to APIServices_old.js
  async getAllAppraisalPeriods(dispatch) {
    throw new Error("Not implemented");
  }
  async createAppraisalPeriod(periodData, dispatch) {
    throw new Error("Not implemented");
  }
  async updateAppraisalPeriod(id, periodData, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteAppraisalPeriod(id, dispatch) {
    throw new Error("Not implemented");
  }
  // 360-Degree Appraisal Configuration - maps to APIServices_old.js
  async getAppraisalConfigurations(dispatch, skip, limit) {
    throw new Error("Not implemented");
  }
  async getAllAppraisalConfigurations(dispatch) {
    throw new Error("Not implemented");
  }
  async getAppraisalConfiguration(configSno, dispatch) {
    throw new Error("Not implemented");
  }
  async getActiveAppraisalConfigurations(dispatch) {
    throw new Error("Not implemented");
  }
  async createAppraisalConfiguration(configData, dispatch) {
    throw new Error("Not implemented");
  }
  async updateAppraisalConfiguration(configId, configData, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteAppraisalConfiguration(configId, dispatch) {
    throw new Error("Not implemented");
  }
  async getAppraisalConfigs(dispatch) {
    throw new Error("Not implemented");
  }
  // Assessment Criteria - maps to APIServices_old.js
  async getAssessmentCriteria(configId, dispatch) {
    throw new Error("Not implemented");
  }
  async getCriteriaByType(criteriaType, dispatch) {
    throw new Error("Not implemented");
  }
  async createAssessmentCriteria(criteriaData, dispatch) {
    throw new Error("Not implemented");
  }
  async updateAssessmentCriteria(criteriaId, criteriaData, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteAssessmentCriteria(criteriaId, dispatch) {
    throw new Error("Not implemented");
  }
  async getManagerAssessmentCriteria(configId, dispatch) {
    throw new Error("Not implemented");
  }
  async getAppraisalCriteriaByType(type, dispatch) {
    throw new Error("Not implemented");
  }
  async getPeerCriteria(dispatch) {
    throw new Error("Not implemented");
  }
  // General Assessments - maps to APIServices_old.js
  async getAssessments(filters, dispatch) {
    throw new Error("Not implemented");
  }
  async getAssessment(assessmentId, dispatch) {
    throw new Error("Not implemented");
  }
  async getAssessmentsByConfig(configSno, employeeId, skip, limit, dispatch) {
    throw new Error("Not implemented");
  }
  async getAssessmentsByEmployee(employeeId, dispatch) {
    throw new Error("Not implemented");
  }
  async createAssessment(assessmentData, dispatch) {
    throw new Error("Not implemented");
  }
  async updateAssessment(assessmentId, assessmentData, dispatch) {
    throw new Error("Not implemented");
  }
  async submitAssessment(assessmentId, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteAssessment(assessmentId, dispatch) {
    throw new Error("Not implemented");
  }
  async getAssessmentSummary(configId, dispatch) {
    throw new Error("Not implemented");
  }
  async getAssessmentTypesForEmployee(employeeId, dispatch) {
    throw new Error("Not implemented");
  }
  // Self-Assessment - maps to APIServices_old.js
  async getSelfAssessment(assessmentId, dispatch) {
    throw new Error("Not implemented");
  }
  async getSelfAssessments(dispatch) {
    throw new Error("Not implemented");
  }
  async createSelfAssessment(assessmentData, dispatch) {
    throw new Error("Not implemented");
  }
  async updateSelfAssessment(assessmentId, assessmentData, dispatch) {
    throw new Error("Not implemented");
  }
  async submitSelfAssessment(assessmentId, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteSelfAssessment(assessmentId, dispatch) {
    throw new Error("Not implemented");
  }
  async getSelfAssessmentSummary(dispatch) {
    throw new Error("Not implemented");
  }
  // Manager Assessment - maps to APIServices_old.js
  async createManagerAssessment(assessmentData, dispatch) {
    throw new Error("Not implemented");
  }
  async updateManagerAssessment(sno, assessmentData, dispatch) {
    throw new Error("Not implemented");
  }
  async getManagerAssessment(sno, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteManagerAssessment(sno, dispatch) {
    throw new Error("Not implemented");
  }
  async getManagerAssessments(params, dispatch) {
    throw new Error("Not implemented");
  }
  async submitManagerAssessment(sno, dispatch) {
    throw new Error("Not implemented");
  }
  async getManagerAssessmentSummary(dispatch) {
    throw new Error("Not implemented");
  }
  async saveOrUpdateManagerAssessment(assessmentData, dispatch) {
    throw new Error("Not implemented");
  }
  // Peer Assessment - maps to APIServices_old.js
  async createPeerAssessment(assessmentData, dispatch) {
    throw new Error("Not implemented");
  }
  async updatePeerAssessment(sno, assessmentData, dispatch) {
    throw new Error("Not implemented");
  }
  async getPeerAssessment(sno, dispatch) {
    throw new Error("Not implemented");
  }
  async deletePeerAssessment(sno, dispatch) {
    throw new Error("Not implemented");
  }
  async getPeerAssessments(params, dispatch) {
    throw new Error("Not implemented");
  }
  async submitPeerAssessment(sno, dispatch) {
    throw new Error("Not implemented");
  }
  async getPeerAssessmentSummary(dispatch) {
    throw new Error("Not implemented");
  }
  // Peer/Subordinate Selection - maps to APIServices_old.js
  async getSubordinates(dispatch) {
    throw new Error("Not implemented");
  }
  async getPeers(dispatch) {
    throw new Error("Not implemented");
  }
  // Feedback System - maps to APIServices_old.js
  async getAllFeedbacks(skip, limit, dispatch) {
    throw new Error("Not implemented");
  }
  async getFeedback(feedbackId, dispatch) {
    throw new Error("Not implemented");
  }
  async getEmployeeFeedbacks(employeeId, dispatch) {
    throw new Error("Not implemented");
  }
  async createFeedback(feedbackData, dispatch) {
    throw new Error("Not implemented");
  }
  async updateFeedback(feedbackId, feedbackData, dispatch) {
    throw new Error("Not implemented");
  }
  async deleteFeedback(feedbackId, dispatch) {
    throw new Error("Not implemented");
  }
  async getFeedbackStats(dispatch) {
    throw new Error("Not implemented");
  }
  // ===== 6. SURVEY MANAGER =====
  // Survey management methods (placeholders for future implementation)
  async getSurveys(dispatch) {
    throw new Error("Not implemented");
  }
  async createSurvey(surveyData, dispatch) {
    throw new Error("Not implemented");
  }
  async submitSurveyResponse(surveyId, responseData, dispatch) {
    throw new Error("Not implemented");
  }
  // ===== 7. REPORT MANAGER =====
  // Report generation methods (placeholders for future implementation)
  async generateUserReport(filters, dispatch) {
    throw new Error("Not implemented");
  }
  async generateEmployeeReport(filters, dispatch) {
    throw new Error("Not implemented");
  }
  async generatePerformanceReport(filters, dispatch) {
    throw new Error("Not implemented");
  }
  // ===== 8. AI POWERED FEATURES OR CHATBOT INTERFACE =====
  // AI/Chatbot methods (placeholders for future implementation)
  async sendChatMessage(message, dispatch) {
    throw new Error("Not implemented");
  }
  async getChatHistory(dispatch) {
    throw new Error("Not implemented");
  }
  // ===== UTILITY METHODS =====
  // Error handling - maps to APIServices_old.js
  createErrorHandler(translations) {
    throw new Error("Not implemented");
  }
  shouldShowRetry(error2) {
    throw new Error("Not implemented");
  }
  showError(message, showRetry) {
    throw new Error("Not implemented");
  }
  // Custom API calls - maps to APIServices_old.js
  async customApiCall(endpoint, method, data, dispatch) {
    throw new Error("Not implemented");
  }
}
const ax = axios.create({
  baseURL: "http://localhost:8000",
  headers: {
    Accept: "application/json",
    "Content-Type": "application/json",
    "X-Requested-With": "XMLHttpRequest"
  },
  withCredentials: true,
  xsrfCookieName: false,
  xsrfHeaderName: false
});
ax.interceptors.request.use(function(config2) {
  config2.withCredentials = true;
  const token = localStorage.getItem("auth_token") || sessionStorage.getItem("auth_token") || localStorage.getItem("authToken") || sessionStorage.getItem("authToken");
  console.log("Auth token found:", token ? "Yes (token exists)" : "No (token missing)");
  console.log("Token first 10 chars (if exists):", token ? token.substring(0, 10) + "..." : "N/A");
  if (token) {
    config2.headers["Authorization"] = `Bearer ${token}`;
    console.log("Adding Authorization header with Bearer token");
    console.log("Request URL:", config2.url);
    console.log("Request method:", config2.method);
  } else {
    const cookieTokenMatch = document.cookie.match(/auth_token=([^;]+)/);
    if (cookieTokenMatch && cookieTokenMatch[1]) {
      const cookieToken = cookieTokenMatch[1];
      config2.headers["Authorization"] = `Bearer ${cookieToken}`;
      console.log("Adding Authorization header with Bearer token from cookie");
      try {
        localStorage.setItem("auth_token", cookieToken);
      } catch (e2) {
        console.warn("Failed to save token to localStorage", e2);
      }
    } else {
      console.warn("No auth token found in localStorage, sessionStorage, or cookies");
    }
  }
  console.log("Cookies being sent:", document.cookie);
  console.log("Request URL:", config2.url);
  console.log("Request method:", config2.method);
  console.log("Request headers:", config2.headers);
  return config2;
}, function(error2) {
  return Promise.reject(error2);
});
ax.interceptors.response.use(
  (response) => response,
  async (error2) => {
    var _a2, _b;
    const originalRequest = error2.config;
    if (((_a2 = error2.response) == null ? void 0 : _a2.status) === 401 && !((_b = originalRequest.url) == null ? void 0 : _b.includes("/api/refresh/")) && !originalRequest._retry) {
      originalRequest._retry = true;
      try {
        console.log("Attempting to refresh token...");
        console.log("Cookies available:", document.cookie);
        const hasRefreshToken = document.cookie.includes("refresh_token=");
        console.log("refresh_token cookie present:", hasRefreshToken);
        let refreshToken = null;
        const refreshCookieMatch = document.cookie.match(/refresh_token=([^;]+)/);
        if (refreshCookieMatch && refreshCookieMatch[1]) {
          refreshToken = refreshCookieMatch[1];
        } else {
          refreshToken = localStorage.getItem("refresh_token") || sessionStorage.getItem("refresh_token");
        }
        console.log("Refresh token available:", refreshToken ? "Yes" : "No");
        const refreshResponse = await axios({
          method: "post",
          url: "http://localhost:8000/api/refresh/",
          withCredentials: true,
          headers: {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "X-Debug": "refresh-token-attempt"
          },
          ...refreshToken && {
            headers: {
              "Authorization": `Bearer ${refreshToken}`
            }
          }
        });
        console.log("Token refresh successful:", refreshResponse.data);
        if (refreshResponse.data.access_token) {
          const newAccessToken = refreshResponse.data.access_token;
          localStorage.setItem("auth_token", newAccessToken);
          console.log("New access token stored");
          originalRequest.headers["Authorization"] = `Bearer ${newAccessToken}`;
          return ax(originalRequest);
        } else {
          throw new Error("No access token in refresh response");
        }
      } catch (refreshError) {
        console.error("Token refresh failed:", refreshError);
        localStorage.removeItem("auth_token");
        localStorage.removeItem("refresh_token");
        sessionStorage.removeItem("auth_token");
        sessionStorage.removeItem("refresh_token");
        Swal.fire({
          icon: "warning",
          title: "Session Expired",
          text: "Please log in again.",
          confirmButtonText: "OK"
        }).then(() => {
          window.location.href = "/login";
        });
        return Promise.reject(refreshError);
      }
    }
    return Promise.reject(error2);
  }
);
const withLoading = async (dispatch, fn) => {
  if (dispatch) dispatch(setLoading(true));
  try {
    return await fn();
  } finally {
    if (dispatch) dispatch(setLoading(false));
  }
};
const handleError$3 = (error2, fallbackMessage = "An error occurred") => {
  var _a2, _b;
  const message = ((_b = (_a2 = error2.response) == null ? void 0 : _a2.data) == null ? void 0 : _b.detail) || fallbackMessage;
  Swal.fire({
    icon: "error",
    title: "Oops...",
    text: message
  });
  throw error2;
};
let APIServices$1 = class APIServices extends IDomainServices {
  // ============================================================================
  // MODULE 2: LOGIN AND USER MANAGEMENT
  // ============================================================================
  async login(credentials, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      console.log("Attempting login with credentials:", { email: credentials.email });
      const response = await ax.post("/api/login/", credentials);
      console.log("Login response received:", response);
      if (response.data.access_token) {
        localStorage.setItem("auth_token", response.data.access_token);
        console.log("Access token stored in localStorage");
      }
      if (response.data.refresh_token) {
        localStorage.setItem("refresh_token", response.data.refresh_token);
        console.log("Refresh token stored in localStorage");
      }
      return response.data;
    } catch (error2) {
      console.error("Login error:", error2);
      if (error2.response) {
        console.error("Response status:", error2.response.status);
        console.error("Response headers:", error2.response.headers);
        console.error("Response data:", error2.response.data);
      } else if (error2.request) {
        console.error("Request was made but no response was received", error2.request);
      } else {
        console.error("Error setting up request:", error2.message);
      }
      throw error2;
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async logout() {
    try {
      await ax.post("/api/logout/");
      localStorage.removeItem("auth_token");
      localStorage.removeItem("refresh_token");
      sessionStorage.removeItem("auth_token");
      sessionStorage.removeItem("refresh_token");
      return { success: true };
    } catch (error2) {
      console.error("Logout error:", error2);
      throw error2;
    }
  }
  async resetPassword(data, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/password-recovery/reset", data);
        Swal.fire({
          icon: "success",
          title: "Password Reset Successful",
          text: "Your password has been updated successfully."
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to reset password");
      }
    });
  }
  async forgotPassword(data, dispatch) {
    var _a2, _b, _c, _d;
    try {
      if (dispatch) dispatch(setLoading(true));
      const response = await ax.post("/api/password-recovery/initiate", data);
      console.log("Forgot password request successful:", response.data);
      return response.data;
    } catch (error2) {
      console.error("Forgot password error:", error2);
      const errorMessage = ((_b = (_a2 = error2.response) == null ? void 0 : _a2.data) == null ? void 0 : _b.detail) || ((_d = (_c = error2.response) == null ? void 0 : _c.data) == null ? void 0 : _d.message) || "Failed to send password reset request";
      throw new Error(errorMessage);
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async bulkCreateUsers(usersData, dispatch) {
    return withLoading(dispatch, async () => {
      var _a2;
      try {
        const response = await ax.post("/api/registers/bulk/", usersData);
        Swal.fire({
          icon: "success",
          title: "Users Created",
          text: `Successfully created ${((_a2 = response.data.created) == null ? void 0 : _a2.length) || 0} users`
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to bulk create users");
      }
    });
  }
  // ============================================================================
  // MODULE 3: DASHBOARD AND PROFILE MANAGEMENT
  // ============================================================================
  async getUserProfile(dispatch) {
    return this.getProfile(dispatch);
  }
  async getProfile(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/profile");
        console.log("Profile data received:", response.data);
        return response.data;
      } catch (error2) {
        console.error("Get profile error:", error2);
        handleError$3(error2, "Failed to load profile");
      }
    });
  }
  async updateUserProfile(payload, dispatch) {
    return this.updateProfile(payload, dispatch);
  }
  async updateProfile(payload, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put("/api/users/profile", payload);
        Swal.fire({
          icon: "success",
          title: "Profile Updated",
          text: "Your profile has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update profile");
      }
    });
  }
  async uploadProfilePicture(file, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const formData = new FormData();
        formData.append("file", file);
        const response = await ax.post("/api/users/profile/picture", formData, {
          headers: { "Content-Type": "multipart/form-data" }
        });
        Swal.fire({
          icon: "success",
          title: "Picture Uploaded",
          text: "Profile picture updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to upload profile picture");
      }
    });
  }
  async changePassword(oldPassword, newPassword, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/users/change-password", {
          old_password: oldPassword,
          new_password: newPassword
        });
        Swal.fire({
          icon: "success",
          title: "Password Changed",
          text: "Your password has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to change password");
      }
    });
  }
  // ============================================================================
  // MODULE 4: PERFORMANCE MANAGEMENT - DEPARTMENTS
  // ============================================================================
  async getAllDepartments(limit, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const url = limit ? `/api/department/?limit=${limit}` : "/api/department/";
        const response = await ax.get(url);
        console.log("Departments received:", response.data);
        return response.data;
      } catch (error2) {
        console.error("Get departments error:", error2);
        handleError$3(error2, "Failed to load departments");
      }
    });
  }
  async getDepartmentById(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get(`/api/department/${id}`);
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load department");
      }
    });
  }
  async createDepartment(departmentData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/department/", departmentData);
        Swal.fire({
          icon: "success",
          title: "Department Created",
          text: "New department has been created successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create department");
      }
    });
  }
  async updateDepartment(id, departmentData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/department/${id}`, departmentData);
        Swal.fire({
          icon: "success",
          title: "Department Updated",
          text: "Department has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update department");
      }
    });
  }
  async deleteDepartment(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/department/${id}`);
        Swal.fire({
          icon: "success",
          title: "Department Deleted",
          text: "Department has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete department");
      }
    });
  }
  // ============================================================================
  // MODULE 4: PERFORMANCE MANAGEMENT - MANAGERS
  // ============================================================================
  async getManagerUsers(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/users/managers");
        console.log("Manager users received:", response.data);
        return response.data;
      } catch (error2) {
        console.error("Get manager users error:", error2);
        handleError$3(error2, "Failed to load manager users");
      }
    });
  }
  async assignManager(employeeId, managerId, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/users/assign-manager", {
          employee_id: employeeId,
          manager_id: managerId
        });
        Swal.fire({
          icon: "success",
          title: "Manager Assigned",
          text: "Manager has been assigned successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to assign manager");
      }
    });
  }
  // ============================================================================
  // MODULE 4: PERFORMANCE MANAGEMENT - GOALS
  // ============================================================================
  async getAllGoals(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/goals/");
        console.log("Goals received:", response.data);
        return response.data;
      } catch (error2) {
        console.error("Get goals error:", error2);
        handleError$3(error2, "Failed to load goals");
      }
    });
  }
  async getGoalById(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get(`/api/goals/${id}`);
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load goal");
      }
    });
  }
  async createGoal(goalData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/goals/", goalData);
        Swal.fire({
          icon: "success",
          title: "Goal Created",
          text: "New goal has been created successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create goal");
      }
    });
  }
  async updateGoal(id, goalData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/goals/${id}`, goalData);
        Swal.fire({
          icon: "success",
          title: "Goal Updated",
          text: "Goal has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update goal");
      }
    });
  }
  async deleteGoal(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/goals/${id}`);
        Swal.fire({
          icon: "success",
          title: "Goal Deleted",
          text: "Goal has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete goal");
      }
    });
  }
  // ============================================================================
  // MODULE 4: PERFORMANCE MANAGEMENT - BUSINESS GOALS
  // ============================================================================
  async getAllBusinessGoals(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/business-goals/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load business goals");
      }
    });
  }
  async createBusinessGoal(goalData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/business-goals/", goalData);
        Swal.fire({
          icon: "success",
          title: "Business Goal Created",
          text: "New business goal has been created successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create business goal");
      }
    });
  }
  async updateBusinessGoal(id, goalData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/business-goals/${id}`, goalData);
        Swal.fire({
          icon: "success",
          title: "Business Goal Updated",
          text: "Business goal has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update business goal");
      }
    });
  }
  async deleteBusinessGoal(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/business-goals/${id}`);
        Swal.fire({
          icon: "success",
          title: "Business Goal Deleted",
          text: "Business goal has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete business goal");
      }
    });
  }
  // ============================================================================
  // MODULE 4: PERFORMANCE MANAGEMENT - GOAL CATEGORIES
  // ============================================================================
  async getAllGoalCategories(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/goal-categories/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load goal categories");
      }
    });
  }
  async createGoalCategory(categoryData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/goal-categories/", categoryData);
        Swal.fire({
          icon: "success",
          title: "Category Created",
          text: "New goal category has been created successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create goal category");
      }
    });
  }
  async updateGoalCategory(id, categoryData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/goal-categories/${id}`, categoryData);
        Swal.fire({
          icon: "success",
          title: "Category Updated",
          text: "Goal category has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update goal category");
      }
    });
  }
  async deleteGoalCategory(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/goal-categories/${id}`);
        Swal.fire({
          icon: "success",
          title: "Category Deleted",
          text: "Goal category has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete goal category");
      }
    });
  }
  // ============================================================================
  // MODULE 4: PERFORMANCE MANAGEMENT - PERFORMANCE CRITERIA
  // ============================================================================
  async getAllPerformanceCriteria(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/performance-criteria/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load performance criteria");
      }
    });
  }
  async createPerformanceCriteria(criteriaData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/performance-criteria/", criteriaData);
        Swal.fire({
          icon: "success",
          title: "Criteria Created",
          text: "New performance criteria has been created successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create performance criteria");
      }
    });
  }
  async updatePerformanceCriteria(id, criteriaData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/performance-criteria/${id}`, criteriaData);
        Swal.fire({
          icon: "success",
          title: "Criteria Updated",
          text: "Performance criteria has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update performance criteria");
      }
    });
  }
  async deletePerformanceCriteria(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/performance-criteria/${id}`);
        Swal.fire({
          icon: "success",
          title: "Criteria Deleted",
          text: "Performance criteria has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete performance criteria");
      }
    });
  }
  // ============================================================================
  // MODULE 4: PERFORMANCE MANAGEMENT - METRICS
  // ============================================================================
  async getAllMetrics(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/performance-metrics/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load performance metrics");
      }
    });
  }
  async createMetric(metricData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/performance-metrics/", metricData);
        Swal.fire({
          icon: "success",
          title: "Metric Created",
          text: "New performance metric has been created successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create performance metric");
      }
    });
  }
  async updateMetric(id, metricData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/performance-metrics/${id}`, metricData);
        Swal.fire({
          icon: "success",
          title: "Metric Updated",
          text: "Performance metric has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update performance metric");
      }
    });
  }
  async deleteMetric(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/performance-metrics/${id}`);
        Swal.fire({
          icon: "success",
          title: "Metric Deleted",
          text: "Performance metric has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete performance metric");
      }
    });
  }
  // ============================================================================
  // MODULE 4: PERFORMANCE MANAGEMENT - DEVELOPMENT PLANS
  // ============================================================================
  async getAllDevelopmentPlans(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/development-plans/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load development plans");
      }
    });
  }
  async createDevelopmentPlan(planData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/development-plans/", planData);
        Swal.fire({
          icon: "success",
          title: "Development Plan Created",
          text: "New development plan has been created successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create development plan");
      }
    });
  }
  async updateDevelopmentPlan(id, planData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/development-plans/${id}`, planData);
        Swal.fire({
          icon: "success",
          title: "Development Plan Updated",
          text: "Development plan has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update development plan");
      }
    });
  }
  async deleteDevelopmentPlan(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/development-plans/${id}`);
        Swal.fire({
          icon: "success",
          title: "Development Plan Deleted",
          text: "Development plan has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete development plan");
      }
    });
  }
  // ============================================================================
  // MODULE 4: PERFORMANCE MANAGEMENT - APPRAISAL PERIODS
  // ============================================================================
  async getAllAppraisalPeriods(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/appraisal-periods/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load appraisal periods");
      }
    });
  }
  async createAppraisalPeriod(periodData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/appraisal-periods/", periodData);
        Swal.fire({
          icon: "success",
          title: "Appraisal Period Created",
          text: "New appraisal period has been created successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create appraisal period");
      }
    });
  }
  async updateAppraisalPeriod(id, periodData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/appraisal-periods/${id}`, periodData);
        Swal.fire({
          icon: "success",
          title: "Appraisal Period Updated",
          text: "Appraisal period has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update appraisal period");
      }
    });
  }
  async deleteAppraisalPeriod(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/appraisal-periods/${id}`);
        Swal.fire({
          icon: "success",
          title: "Appraisal Period Deleted",
          text: "Appraisal period has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete appraisal period");
      }
    });
  }
  // ============================================================================
  // MODULE 4: 360-DEGREE APPRAISAL - CONFIGURATION
  // ============================================================================
  async getAppraisalConfigurations(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/appraisal-configurations/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load appraisal configurations");
      }
    });
  }
  async createAppraisalConfiguration(configData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/appraisal-configurations/", configData);
        Swal.fire({
          icon: "success",
          title: "Configuration Created",
          text: "New appraisal configuration has been created successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create appraisal configuration");
      }
    });
  }
  async updateAppraisalConfiguration(id, configData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/appraisal-configurations/${id}`, configData);
        Swal.fire({
          icon: "success",
          title: "Configuration Updated",
          text: "Appraisal configuration has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update appraisal configuration");
      }
    });
  }
  // ============================================================================
  // MODULE 4: 360-DEGREE APPRAISAL - ASSESSMENT CRITERIA
  // ============================================================================
  async getAllAssessmentCriteria(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/assessment-criteria/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load assessment criteria");
      }
    });
  }
  async createAssessmentCriteria(criteriaData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/assessment-criteria/", criteriaData);
        Swal.fire({
          icon: "success",
          title: "Assessment Criteria Created",
          text: "New assessment criteria has been created successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create assessment criteria");
      }
    });
  }
  async updateAssessmentCriteria(id, criteriaData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/assessment-criteria/${id}`, criteriaData);
        Swal.fire({
          icon: "success",
          title: "Assessment Criteria Updated",
          text: "Assessment criteria has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update assessment criteria");
      }
    });
  }
  async deleteAssessmentCriteria(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/assessment-criteria/${id}`);
        Swal.fire({
          icon: "success",
          title: "Assessment Criteria Deleted",
          text: "Assessment criteria has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete assessment criteria");
      }
    });
  }
  // ============================================================================
  // MODULE 4: 360-DEGREE APPRAISAL - GENERAL ASSESSMENTS
  // ============================================================================
  async getAllGeneralAssessments(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/general-assessments/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load general assessments");
      }
    });
  }
  async getGeneralAssessmentById(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get(`/api/general-assessments/${id}`);
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load general assessment");
      }
    });
  }
  async createGeneralAssessment(assessmentData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/general-assessments/", assessmentData);
        Swal.fire({
          icon: "success",
          title: "General Assessment Created",
          text: "New general assessment has been created successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create general assessment");
      }
    });
  }
  async updateGeneralAssessment(id, assessmentData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/general-assessments/${id}`, assessmentData);
        Swal.fire({
          icon: "success",
          title: "General Assessment Updated",
          text: "General assessment has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update general assessment");
      }
    });
  }
  async deleteGeneralAssessment(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/general-assessments/${id}`);
        Swal.fire({
          icon: "success",
          title: "General Assessment Deleted",
          text: "General assessment has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete general assessment");
      }
    });
  }
  // ============================================================================
  // MODULE 4: 360-DEGREE APPRAISAL - SELF ASSESSMENT
  // ============================================================================
  async getSelfAssessments(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/self-assessments/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load self assessments");
      }
    });
  }
  async createSelfAssessment(assessmentData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/self-assessments/", assessmentData);
        Swal.fire({
          icon: "success",
          title: "Self Assessment Created",
          text: "Your self assessment has been submitted successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create self assessment");
      }
    });
  }
  async updateSelfAssessment(id, assessmentData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/self-assessments/${id}`, assessmentData);
        Swal.fire({
          icon: "success",
          title: "Self Assessment Updated",
          text: "Your self assessment has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update self assessment");
      }
    });
  }
  async deleteSelfAssessment(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/self-assessments/${id}`);
        Swal.fire({
          icon: "success",
          title: "Self Assessment Deleted",
          text: "Your self assessment has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete self assessment");
      }
    });
  }
  // ============================================================================
  // MODULE 4: 360-DEGREE APPRAISAL - MANAGER ASSESSMENT
  // ============================================================================
  async getManagerAssessments(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/manager-assessments/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load manager assessments");
      }
    });
  }
  async createManagerAssessment(assessmentData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/manager-assessments/", assessmentData);
        Swal.fire({
          icon: "success",
          title: "Manager Assessment Created",
          text: "Manager assessment has been submitted successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create manager assessment");
      }
    });
  }
  async updateManagerAssessment(id, assessmentData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/manager-assessments/${id}`, assessmentData);
        Swal.fire({
          icon: "success",
          title: "Manager Assessment Updated",
          text: "Manager assessment has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update manager assessment");
      }
    });
  }
  async deleteManagerAssessment(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/manager-assessments/${id}`);
        Swal.fire({
          icon: "success",
          title: "Manager Assessment Deleted",
          text: "Manager assessment has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete manager assessment");
      }
    });
  }
  // ============================================================================
  // MODULE 4: 360-DEGREE APPRAISAL - PEER ASSESSMENT
  // ============================================================================
  async getPeerAssessments(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/peer-assessments/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load peer assessments");
      }
    });
  }
  async createPeerAssessment(assessmentData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.post("/api/peer-assessments/", assessmentData);
        Swal.fire({
          icon: "success",
          title: "Peer Assessment Created",
          text: "Peer assessment has been submitted successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to create peer assessment");
      }
    });
  }
  async updatePeerAssessment(id, assessmentData, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.put(`/api/peer-assessments/${id}`, assessmentData);
        Swal.fire({
          icon: "success",
          title: "Peer Assessment Updated",
          text: "Peer assessment has been updated successfully"
        });
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to update peer assessment");
      }
    });
  }
  async deletePeerAssessment(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        await ax.delete(`/api/peer-assessments/${id}`);
        Swal.fire({
          icon: "success",
          title: "Peer Assessment Deleted",
          text: "Peer assessment has been removed successfully"
        });
        return { success: true };
      } catch (error2) {
        handleError$3(error2, "Failed to delete peer assessment");
      }
    });
  }
  // ============================================================================
  // MODULE 5: EMPLOYEE INFORMATION MANAGEMENT
  // ============================================================================
  async getCurrentEmployeeData(dispatch) {
    return this.getProfile(dispatch);
  }
  async getEmployeeById(id, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get(`/api/users/${id}`);
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load employee data");
      }
    });
  }
  async getEmployee(id, dispatch) {
    return this.getEmployeeById(id, dispatch);
  }
  async getEmployeesForManager(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/users/manager/employees");
        console.log("Employees for manager received:", response.data);
        return response.data;
      } catch (error2) {
        console.error("Get employees for manager error:", error2);
        handleError$3(error2, "Failed to load employees");
      }
    });
  }
  async getEmployeeForManager(employeeId, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get(`/api/users/manager/employees/${employeeId}`);
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load employee data");
      }
    });
  }
  async getEmployeesByDepartmentForManager(departmentId, dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get(`/api/users/manager/department/${departmentId}/employees`);
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load employees for department");
      }
    });
  }
  async getEmployees(dispatch) {
    return withLoading(dispatch, async () => {
      try {
        const response = await ax.get("/api/users/");
        return response.data;
      } catch (error2) {
        handleError$3(error2, "Failed to load employees");
      }
    });
  }
  async getCurrentUser(dispatch) {
    return this.getProfile(dispatch);
  }
  async getUser(id, dispatch) {
    return this.getEmployeeById(id, dispatch);
  }
  async getAllUsers(dispatch) {
    return this.getEmployees(dispatch);
  }
  // ============================================================================
  // UTILITY METHODS
  // ============================================================================
  async customApiCall(method, endpoint, data = null, dispatch = null) {
    return withLoading(dispatch, async () => {
      try {
        const config2 = {
          method: method.toLowerCase(),
          url: endpoint
        };
        if (data) {
          if (method.toUpperCase() === "GET") {
            config2.params = data;
          } else {
            config2.data = data;
          }
        }
        const response = await ax(config2);
        return response.data;
      } catch (error2) {
        handleError$3(error2, `API call to ${endpoint} failed`);
      }
    });
  }
};
const apiServices = new APIServices$1();
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once2) {
      this.fn = fn;
      this.context = context;
      this.once = once2 || false;
    }
    function addListener(emitter, event, fn, context, once2) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once2), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on2(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once2(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once2) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn || once2 && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    {
      module.exports = EventEmitter3;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var eventemitter3Exports = requireEventemitter3();
const EventEmitter2 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
class EventBus extends EventEmitter2 {
  // MediatR-style "Send" for a Command/Query (Request/Response)
  // NOTE: In a true MediatR fashion, this should only have *one* handler.
  // However, event emitters naturally support multiple, so we'll treat 
  // the first response as the "return value" for simplicity.
  async send(messageName, message) {
    const handlers = this.listeners(messageName);
    if (handlers.length !== 1) {
      throw new Error(`Command ${messageName} must have exactly one handler.`);
    }
    const result = await new Promise((resolve) => {
      this.emit(messageName, message, resolve);
    });
    return result;
  }
  // MediatR-style "Publish" for a Notification (Fire-and-Forget)
  // This allows multiple handlers (subscribers/listeners).
  publish(notificationName, notification) {
    this.emit(notificationName, notification);
  }
}
class LocalStoreContext {
  constructor(typeName) {
    this.typeName = typeName;
    this.storageKey = `tldr_${typeName.toLowerCase()}`;
  }
  /**
   * Get data from localStorage
   */
  getData() {
    try {
      const data = localStorage.getItem(this.storageKey);
      return data ? JSON.parse(data) : [];
    } catch (error2) {
      console.error(`Error reading from localStorage for ${this.storageKey}:`, error2);
      return [];
    }
  }
  /**
   * Save data to localStorage
   */
  saveData(data) {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(data));
    } catch (error2) {
      console.error(`Error saving to localStorage for ${this.storageKey}:`, error2);
      throw error2;
    }
  }
  /**
   * Generate next available ID
   */
  getNextId() {
    const data = this.getData();
    if (data.length === 0) return 1;
    const maxId = Math.max(...data.map((item) => item.id || 0));
    return maxId + 1;
  }
  /**
   * Get item ID - ONLY uses lowercase 'id' property
   * Note: 'ID' (uppercase) is often used for foreign keys (e.g., Goal.ID = userID FK)
   * and should NOT be treated as the primary key
   */
  getItemId(item) {
    return item.id;
  }
  /**
   * Set item ID - uses lowercase 'id' property
   */
  setItemId(item, id) {
    const newItem = { ...item };
    newItem.id = id;
    return newItem;
  }
  async get(id) {
    const data = this.getData();
    const item = data.find((item2) => this.getItemId(item2) === id.valueOf());
    if (!item) {
      throw new Error(`Item with id ${id} not found in ${this.typeName}`);
    }
    return Promise.resolve(item);
  }
  async getAll() {
    return Promise.resolve(this.getData());
  }
  async add(item) {
    try {
      const data = this.getData();
      const itemId = this.getItemId(item);
      const newItem = itemId ? item : this.setItemId(item, this.getNextId());
      const existingIndex = data.findIndex((existing) => this.getItemId(existing) === this.getItemId(newItem));
      if (existingIndex >= 0) {
        data[existingIndex] = newItem;
      } else {
        data.push(newItem);
      }
      this.saveData(data);
      return Promise.resolve(newItem);
    } catch (error2) {
      console.error(`Error adding item to ${this.typeName}:`, error2);
      return Promise.reject(error2);
    }
  }
  async addRange(...items) {
    try {
      const data = this.getData();
      let addedCount = 0;
      for (const item of items) {
        const itemId = this.getItemId(item);
        const newItem = itemId ? item : this.setItemId(item, this.getNextId() + addedCount);
        const existingIndex = data.findIndex((existing) => this.getItemId(existing) === this.getItemId(newItem));
        if (existingIndex >= 0) {
          data[existingIndex] = newItem;
        } else {
          data.push(newItem);
          addedCount++;
        }
      }
      this.saveData(data);
      return Promise.resolve(addedCount);
    } catch (error2) {
      console.error(`Error adding items range to ${this.typeName}:`, error2);
      return Promise.reject(error2);
    }
  }
  async remove(item) {
    try {
      const data = this.getData();
      const itemId = this.getItemId(item);
      if (!itemId) {
        return Promise.resolve(0);
      }
      const initialLength = data.length;
      const filteredData = data.filter((existing) => this.getItemId(existing) !== itemId);
      this.saveData(filteredData);
      return Promise.resolve(initialLength - filteredData.length);
    } catch (error2) {
      console.error(`Error removing item from ${this.typeName}:`, error2);
      return Promise.reject(error2);
    }
  }
  async removeRange(...ids) {
    try {
      const data = this.getData();
      const initialLength = data.length;
      const filteredData = data.filter((item) => {
        const itemId = this.getItemId(item);
        return !ids.includes(itemId || 0);
      });
      this.saveData(filteredData);
      return Promise.resolve(initialLength - filteredData.length);
    } catch (error2) {
      console.error(`Error removing items range from ${this.typeName}:`, error2);
      return Promise.reject(error2);
    }
  }
  async find(query) {
    try {
      const data = this.getData();
      if (!query || Object.keys(query).length === 0) {
        return Promise.resolve(data);
      }
      const results = data.filter((item) => {
        return Object.entries(query).every(([key, value]) => {
          const itemValue = item[key];
          if (value && typeof value === "object") {
            if (value.$in && Array.isArray(value.$in)) {
              return value.$in.includes(itemValue);
            }
            if (value.$ne !== void 0) {
              return itemValue !== value.$ne;
            }
            if (value.$gt !== void 0) {
              return itemValue > value.$gt;
            }
            if (value.$lt !== void 0) {
              return itemValue < value.$lt;
            }
            if (value.$regex !== void 0) {
              const regex = new RegExp(value.$regex, value.$options || "i");
              return regex.test(String(itemValue));
            }
          }
          return itemValue === value;
        });
      });
      return Promise.resolve(results);
    } catch (error2) {
      console.error(`Error finding items in ${this.typeName}:`, error2);
      return Promise.reject(error2);
    }
  }
  async count() {
    return Promise.resolve(this.getData().length);
  }
  async serverFun(fun, gql) {
    switch (fun) {
      case "get_count":
        return this.count();
      case "clear_all":
        localStorage.removeItem(this.storageKey);
        return Promise.resolve(true);
      case "export_data":
        return Promise.resolve(this.getData());
      case "import_data":
        if (Array.isArray(gql)) {
          this.saveData(gql);
          return Promise.resolve(gql.length);
        }
        return Promise.reject(new Error("Invalid data format for import"));
      default:
        console.warn(`Server function '${fun}' not implemented in LocalStoreContext`);
        return Promise.resolve(null);
    }
  }
  /**
   * Additional utility methods for localStorage management
   */
  /**
   * Update item by ID with optional custom id field name
   * @param id - The ID value to match
   * @param updates - Partial item with fields to update
   * @param idField - Optional custom id field name (defaults to 'id' or 'ID')
   */
  async update(id, updates, idField) {
    try {
      const data = this.getData();
      const index2 = data.findIndex((item) => {
        if (idField) {
          return item[idField] === id;
        }
        return this.getItemId(item) === id;
      });
      if (index2 < 0) {
        throw new Error(`Item with ${idField || "id"} ${id} not found in ${this.typeName}`);
      }
      const updatedItem = { ...data[index2], ...updates };
      data[index2] = updatedItem;
      this.saveData(data);
      return Promise.resolve(updatedItem);
    } catch (error2) {
      console.error(`Error updating item in ${this.typeName}:`, error2);
      return Promise.reject(error2);
    }
  }
  /**
   * Delete item by ID with optional custom id field name
   * @param id - The ID value to match
   * @param idField - Optional custom id field name (defaults to 'id' or 'ID')
   */
  async deleteById(id, idField) {
    try {
      const data = this.getData();
      const initialLength = data.length;
      const filteredData = data.filter((item) => {
        if (idField) {
          return item[idField] !== id;
        }
        return this.getItemId(item) !== id;
      });
      this.saveData(filteredData);
      return Promise.resolve(filteredData.length < initialLength);
    } catch (error2) {
      console.error(`Error deleting item from ${this.typeName}:`, error2);
      return Promise.reject(error2);
    }
  }
  /**
   * Clear all data for this type
   */
  async clear() {
    localStorage.removeItem(this.storageKey);
  }
  /**
   * Get storage key for this context
   */
  getStorageKey() {
    return this.storageKey;
  }
  /**
   * Get storage size in bytes (approximate)
   */
  getStorageSize() {
    try {
      const data = localStorage.getItem(this.storageKey);
      return data ? data.length : 0;
    } catch (error2) {
      return 0;
    }
  }
  /**
   * Check if localStorage is available
   */
  static isLocalStorageAvailable() {
    try {
      const test = "__localStorage_test__";
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    } catch (error2) {
      return false;
    }
  }
}
class IndexedDBContext {
  constructor(dbName, storeName) {
    this.version = 1;
    this.dbName = dbName;
    this.storeName = storeName;
  }
  async openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store2 = db.createObjectStore(this.storeName, { keyPath: "id" });
          store2.createIndex("id", "id", { unique: true });
        }
      };
    });
  }
  async getStore(mode = "readonly") {
    const db = await this.openDB();
    const transaction = db.transaction([this.storeName], mode);
    return transaction.objectStore(this.storeName);
  }
  // IRepository interface implementation
  async get(id) {
    try {
      const store2 = await this.getStore();
      return new Promise((resolve, reject) => {
        const request = store2.get(String(id));
        request.onsuccess = () => {
          if (!request.result) {
            reject(new Error(`Item with id ${id} not found`));
          } else {
            resolve(request.result);
          }
        };
        request.onerror = () => {
          var _a2;
          return reject(new Error(`Failed to get item: ${(_a2 = request.error) == null ? void 0 : _a2.message}`));
        };
      });
    } catch (error2) {
      throw new Error(`Repository get operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async getAll() {
    try {
      const store2 = await this.getStore();
      const results = [];
      return new Promise((resolve, reject) => {
        const request = store2.openCursor();
        request.onsuccess = () => {
          const cursor = request.result;
          if (cursor) {
            results.push(cursor.value);
            cursor.continue();
          } else {
            resolve(results);
          }
        };
        request.onerror = () => {
          var _a2;
          return reject(new Error(`Failed to get all items: ${(_a2 = request.error) == null ? void 0 : _a2.message}`));
        };
      });
    } catch (error2) {
      throw new Error(`Repository getAll operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async add(item) {
    try {
      const store2 = await this.getStore("readwrite");
      return new Promise((resolve, reject) => {
        const request = store2.add(item);
        request.onsuccess = () => resolve(item);
        request.onerror = () => {
          var _a2;
          return reject(new Error(`Failed to add item: ${(_a2 = request.error) == null ? void 0 : _a2.message}`));
        };
      });
    } catch (error2) {
      throw new Error(`Repository add operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async addRange(...items) {
    try {
      if (items.length === 0) return 0;
      const store2 = await this.getStore("readwrite");
      return new Promise((resolve, reject) => {
        const transaction = store2.transaction;
        let completed = 0;
        let hasError = false;
        items.forEach((item) => {
          const request = store2.add(item);
          request.onsuccess = () => {
            completed++;
            if (completed === items.length && !hasError) {
              resolve(items.length);
            }
          };
          request.onerror = () => {
            var _a2;
            hasError = true;
            transaction.abort();
            reject(new Error(`Failed to add items: ${(_a2 = request.error) == null ? void 0 : _a2.message}`));
          };
        });
      });
    } catch (error2) {
      throw new Error(`Repository addRange operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async remove(item) {
    try {
      const store2 = await this.getStore("readwrite");
      return new Promise((resolve, reject) => {
        const request = store2.delete(item.id);
        request.onsuccess = () => resolve(1);
        request.onerror = () => {
          var _a2;
          return reject(new Error(`Failed to remove item: ${(_a2 = request.error) == null ? void 0 : _a2.message}`));
        };
      });
    } catch (error2) {
      throw new Error(`Repository remove operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async removeRange(...items) {
    try {
      if (items.length === 0) return 0;
      const store2 = await this.getStore("readwrite");
      return new Promise((resolve, reject) => {
        const transaction = store2.transaction;
        let completed = 0;
        let hasError = false;
        items.forEach((id) => {
          const request = store2.delete(String(id));
          request.onsuccess = () => {
            completed++;
            if (completed === items.length && !hasError) {
              resolve(items.length);
            }
          };
          request.onerror = () => {
            var _a2;
            hasError = true;
            transaction.abort();
            reject(new Error(`Failed to remove items: ${(_a2 = request.error) == null ? void 0 : _a2.message}`));
          };
        });
      });
    } catch (error2) {
      throw new Error(`Repository removeRange operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async find(gql) {
    try {
      if (!gql || typeof gql !== "object") {
        return this.getAll();
      }
      const store2 = await this.getStore();
      const results = [];
      return new Promise((resolve, reject) => {
        const request = store2.openCursor();
        request.onsuccess = () => {
          const cursor = request.result;
          if (cursor) {
            const item = cursor.value;
            const matches = Object.entries(gql).every(([key, value]) => {
              return item[key] === value;
            });
            if (matches) {
              results.push(item);
            }
            cursor.continue();
          } else {
            resolve(results);
          }
        };
        request.onerror = () => {
          var _a2;
          return reject(new Error(`Failed to find items: ${(_a2 = request.error) == null ? void 0 : _a2.message}`));
        };
      });
    } catch (error2) {
      throw new Error(`Repository find operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async count() {
    try {
      const store2 = await this.getStore();
      return new Promise((resolve, reject) => {
        const request = store2.count();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => {
          var _a2;
          return reject(new Error(`Failed to count items: ${(_a2 = request.error) == null ? void 0 : _a2.message}`));
        };
      });
    } catch (error2) {
      throw new Error(`Repository count operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async serverFun(fun, gql) {
    throw new Error("Server functions not supported in IndexedDB context");
  }
  /**
   * Update an item by ID with optional custom ID field name
   * @param id - The ID value to match
   * @param updates - Partial updates to apply
   * @param idField - Optional custom ID field name (defaults to 'id')
   * @returns The updated item
   */
  async update(id, updates, idField = "id") {
    try {
      const allItems = await this.getAll();
      const existingItem = allItems.find((item) => item[idField] === id);
      if (!existingItem) {
        throw new Error(`Item with ${idField}=${id} not found`);
      }
      const updatedItem = { ...existingItem, ...updates };
      const store2 = await this.getStore("readwrite");
      return new Promise((resolve, reject) => {
        const request = store2.put(updatedItem);
        request.onsuccess = () => resolve(updatedItem);
        request.onerror = () => {
          var _a2;
          return reject(new Error(`Failed to update item: ${(_a2 = request.error) == null ? void 0 : _a2.message}`));
        };
      });
    } catch (error2) {
      throw new Error(`Repository update operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  /**
   * Delete an item by ID with optional custom ID field name
   * @param id - The ID value to match
   * @param idField - Optional custom ID field name (defaults to 'id')
   * @returns True if deletion was successful
   */
  async deleteById(id, idField = "id") {
    try {
      const allItems = await this.getAll();
      const existingItem = allItems.find((item) => item[idField] === id);
      if (!existingItem) {
        return false;
      }
      const store2 = await this.getStore("readwrite");
      return new Promise((resolve, reject) => {
        const request = store2.delete(existingItem.id);
        request.onsuccess = () => resolve(true);
        request.onerror = () => {
          var _a2;
          return reject(new Error(`Failed to delete item: ${(_a2 = request.error) == null ? void 0 : _a2.message}`));
        };
      });
    } catch (error2) {
      throw new Error(`Repository deleteById operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
}
var main = {};
var SupabaseClient$1 = {};
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function") throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f2) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_2 = accept(result.get)) descriptor.get = _2;
      if (_2 = accept(result.set)) descriptor.set = _2;
      if (_2 = accept(result.init)) initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field") initializers.unshift(_2);
      else descriptor[key] = _2;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x2) {
  return typeof x2 === "symbol" ? x2 : "".concat(x2);
}
function __setFunctionName(f2, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding = Object.create ? (function(o2, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
}) : (function(o2, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  o2[k22] = m2[k2];
});
function __exportStar(m2, o2) {
  for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2)) __createBinding(o2, m2, p2);
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e2 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f2) {
    return function(v2) {
      return Promise.resolve(v2).then(f2, reject);
    };
  }
  function verb(n2, f2) {
    if (g2[n2]) {
      i2[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
      if (f2) i2[n2] = f2(i2[n2]);
    }
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f2) {
    i2[n2] = o2[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: false } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? (function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
}) : function(o2, v2) {
  o2["default"] = v2;
};
var ownKeys$7 = function(o2) {
  ownKeys$7 = Object.getOwnPropertyNames || function(o3) {
    var ar = [];
    for (var k2 in o3) if (Object.prototype.hasOwnProperty.call(o3, k2)) ar[ar.length] = k2;
    return ar;
  };
  return ownKeys$7(o2);
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k2 = ownKeys$7(mod), i2 = 0; i2 < k2.length; i2++) if (k2[i2] !== "default") __createBinding(result, mod, k2[i2]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e2) {
        return Promise.reject(e2);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
function __disposeResources(env) {
  function fail(e2) {
    env.error = env.hasError ? new _SuppressedError(e2, env.error, "An error was suppressed during disposal.") : e2;
    env.hasError = true;
  }
  var r2, s2 = 0;
  function next() {
    while (r2 = env.stack.pop()) {
      try {
        if (!r2.async && s2 === 1) return s2 = 0, env.stack.push(r2), Promise.resolve().then(next);
        if (r2.dispose) {
          var result = r2.dispose.call(r2.value);
          if (r2.async) return s2 |= 2, Promise.resolve(result).then(next, function(e2) {
            fail(e2);
            return next();
          });
        } else s2 |= 1;
      } catch (e2) {
        fail(e2);
      }
    }
    if (s2 === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m2, tsx, d2, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d2 && (!ext || !cm) ? m2 : d2 + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
const tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __rewriteRelativeImportExtension,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
const resolveFetch$3 = (customFetch) => {
  if (customFetch) {
    return (...args) => customFetch(...args);
  }
  return (...args) => fetch(...args);
};
let FunctionsError$1 = class FunctionsError extends Error {
  constructor(message, name = "FunctionsError", context) {
    super(message);
    this.name = name;
    this.context = context;
  }
};
let FunctionsFetchError$1 = class FunctionsFetchError extends FunctionsError$1 {
  constructor(context) {
    super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
  }
};
let FunctionsRelayError$1 = class FunctionsRelayError extends FunctionsError$1 {
  constructor(context) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
  }
};
let FunctionsHttpError$1 = class FunctionsHttpError extends FunctionsError$1 {
  constructor(context) {
    super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
  }
};
var FunctionRegion$1;
(function(FunctionRegion2) {
  FunctionRegion2["Any"] = "any";
  FunctionRegion2["ApNortheast1"] = "ap-northeast-1";
  FunctionRegion2["ApNortheast2"] = "ap-northeast-2";
  FunctionRegion2["ApSouth1"] = "ap-south-1";
  FunctionRegion2["ApSoutheast1"] = "ap-southeast-1";
  FunctionRegion2["ApSoutheast2"] = "ap-southeast-2";
  FunctionRegion2["CaCentral1"] = "ca-central-1";
  FunctionRegion2["EuCentral1"] = "eu-central-1";
  FunctionRegion2["EuWest1"] = "eu-west-1";
  FunctionRegion2["EuWest2"] = "eu-west-2";
  FunctionRegion2["EuWest3"] = "eu-west-3";
  FunctionRegion2["SaEast1"] = "sa-east-1";
  FunctionRegion2["UsEast1"] = "us-east-1";
  FunctionRegion2["UsWest1"] = "us-west-1";
  FunctionRegion2["UsWest2"] = "us-west-2";
})(FunctionRegion$1 || (FunctionRegion$1 = {}));
class FunctionsClient {
  /**
   * Creates a new Functions client bound to an Edge Functions URL.
   *
   * @example
   * ```ts
   * import { FunctionsClient, FunctionRegion } from '@supabase/functions-js'
   *
   * const functions = new FunctionsClient('https://xyzcompany.supabase.co/functions/v1', {
   *   headers: { apikey: 'public-anon-key' },
   *   region: FunctionRegion.UsEast1,
   * })
   * ```
   */
  constructor(url, { headers = {}, customFetch, region = FunctionRegion$1.Any } = {}) {
    this.url = url;
    this.headers = headers;
    this.region = region;
    this.fetch = resolveFetch$3(customFetch);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   * @example
   * ```ts
   * functions.setAuth(session.access_token)
   * ```
   */
  setAuth(token) {
    this.headers.Authorization = `Bearer ${token}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   * @example
   * ```ts
   * const { data, error } = await functions.invoke('hello-world', {
   *   body: { name: 'Ada' },
   * })
   * ```
   */
  invoke(functionName_1) {
    return __awaiter(this, arguments, void 0, function* (functionName, options = {}) {
      var _a2;
      let timeoutId;
      let timeoutController;
      try {
        const { headers, method, body: functionArgs, signal, timeout } = options;
        let _headers = {};
        let { region } = options;
        if (!region) {
          region = this.region;
        }
        const url = new URL(`${this.url}/${functionName}`);
        if (region && region !== "any") {
          _headers["x-region"] = region;
          url.searchParams.set("forceFunctionRegion", region);
        }
        let body;
        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers)) {
          if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
            _headers["Content-Type"] = "application/octet-stream";
            body = functionArgs;
          } else if (typeof functionArgs === "string") {
            _headers["Content-Type"] = "text/plain";
            body = functionArgs;
          } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) {
            body = functionArgs;
          } else {
            _headers["Content-Type"] = "application/json";
            body = JSON.stringify(functionArgs);
          }
        } else {
          body = functionArgs;
        }
        let effectiveSignal = signal;
        if (timeout) {
          timeoutController = new AbortController();
          timeoutId = setTimeout(() => timeoutController.abort(), timeout);
          if (signal) {
            effectiveSignal = timeoutController.signal;
            signal.addEventListener("abort", () => timeoutController.abort());
          } else {
            effectiveSignal = timeoutController.signal;
          }
        }
        const response = yield this.fetch(url.toString(), {
          method: method || "POST",
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
          body,
          signal: effectiveSignal
        }).catch((fetchError) => {
          throw new FunctionsFetchError$1(fetchError);
        });
        const isRelayError = response.headers.get("x-relay-error");
        if (isRelayError && isRelayError === "true") {
          throw new FunctionsRelayError$1(response);
        }
        if (!response.ok) {
          throw new FunctionsHttpError$1(response);
        }
        let responseType = ((_a2 = response.headers.get("Content-Type")) !== null && _a2 !== void 0 ? _a2 : "text/plain").split(";")[0].trim();
        let data;
        if (responseType === "application/json") {
          data = yield response.json();
        } else if (responseType === "application/octet-stream" || responseType === "application/pdf") {
          data = yield response.blob();
        } else if (responseType === "text/event-stream") {
          data = response;
        } else if (responseType === "multipart/form-data") {
          data = yield response.formData();
        } else {
          data = yield response.text();
        }
        return { data, error: null, response };
      } catch (error2) {
        return {
          data: null,
          error: error2,
          response: error2 instanceof FunctionsHttpError$1 || error2 instanceof FunctionsRelayError$1 ? error2.context : void 0
        };
      } finally {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
      }
    });
  }
}
const module$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get FunctionRegion() {
    return FunctionRegion$1;
  },
  FunctionsClient,
  FunctionsError: FunctionsError$1,
  FunctionsFetchError: FunctionsFetchError$1,
  FunctionsHttpError: FunctionsHttpError$1,
  FunctionsRelayError: FunctionsRelayError$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(module$4);
var cjs = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
var PostgrestClient = {};
var PostgrestQueryBuilder = {};
var PostgrestFilterBuilder = {};
var PostgrestTransformBuilder = {};
var PostgrestBuilder = {};
var PostgrestError$1 = {};
var hasRequiredPostgrestError;
function requirePostgrestError() {
  if (hasRequiredPostgrestError) return PostgrestError$1;
  hasRequiredPostgrestError = 1;
  Object.defineProperty(PostgrestError$1, "__esModule", { value: true });
  class PostgrestError2 extends Error {
    /**
     * @example
     * ```ts
     * import PostgrestError from '@supabase/postgrest-js'
     *
     * throw new PostgrestError({
     *   message: 'Row level security prevented the request',
     *   details: 'RLS denied the insert',
     *   hint: 'Check your policies',
     *   code: 'PGRST301',
     * })
     * ```
     */
    constructor(context) {
      super(context.message);
      this.name = "PostgrestError";
      this.details = context.details;
      this.hint = context.hint;
      this.code = context.code;
    }
  }
  PostgrestError$1.default = PostgrestError2;
  return PostgrestError$1;
}
var hasRequiredPostgrestBuilder;
function requirePostgrestBuilder() {
  if (hasRequiredPostgrestBuilder) return PostgrestBuilder;
  hasRequiredPostgrestBuilder = 1;
  Object.defineProperty(PostgrestBuilder, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestError_1 = tslib_1.__importDefault(requirePostgrestError());
  let PostgrestBuilder$1 = class PostgrestBuilder {
    /**
     * Creates a builder configured for a specific PostgREST request.
     *
     * @example
     * ```ts
     * import PostgrestQueryBuilder from '@supabase/postgrest-js'
     *
     * const builder = new PostgrestQueryBuilder(
     *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),
     *   { headers: new Headers({ apikey: 'public-anon-key' }) }
     * )
     * ```
     */
    constructor(builder) {
      var _a2, _b;
      this.shouldThrowOnError = false;
      this.method = builder.method;
      this.url = builder.url;
      this.headers = new Headers(builder.headers);
      this.schema = builder.schema;
      this.body = builder.body;
      this.shouldThrowOnError = (_a2 = builder.shouldThrowOnError) !== null && _a2 !== void 0 ? _a2 : false;
      this.signal = builder.signal;
      this.isMaybeSingle = (_b = builder.isMaybeSingle) !== null && _b !== void 0 ? _b : false;
      if (builder.fetch) {
        this.fetch = builder.fetch;
      } else {
        this.fetch = fetch;
      }
    }
    /**
     * If there's an error with the query, throwOnError will reject the promise by
     * throwing the error instead of returning it as part of a successful response.
     *
     * {@link https://github.com/supabase/supabase-js/issues/92}
     */
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    /**
     * Set an HTTP header for the request.
     */
    setHeader(name, value) {
      this.headers = new Headers(this.headers);
      this.headers.set(name, value);
      return this;
    }
    then(onfulfilled, onrejected) {
      if (this.schema === void 0) ;
      else if (["GET", "HEAD"].includes(this.method)) {
        this.headers.set("Accept-Profile", this.schema);
      } else {
        this.headers.set("Content-Profile", this.schema);
      }
      if (this.method !== "GET" && this.method !== "HEAD") {
        this.headers.set("Content-Type", "application/json");
      }
      const _fetch = this.fetch;
      let res = _fetch(this.url.toString(), {
        method: this.method,
        headers: this.headers,
        body: JSON.stringify(this.body),
        signal: this.signal
      }).then(async (res2) => {
        var _a2, _b, _c, _d;
        let error2 = null;
        let data = null;
        let count = null;
        let status = res2.status;
        let statusText = res2.statusText;
        if (res2.ok) {
          if (this.method !== "HEAD") {
            const body = await res2.text();
            if (body === "") ;
            else if (this.headers.get("Accept") === "text/csv") {
              data = body;
            } else if (this.headers.get("Accept") && ((_a2 = this.headers.get("Accept")) === null || _a2 === void 0 ? void 0 : _a2.includes("application/vnd.pgrst.plan+text"))) {
              data = body;
            } else {
              data = JSON.parse(body);
            }
          }
          const countHeader = (_b = this.headers.get("Prefer")) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);
          const contentRange = (_c = res2.headers.get("content-range")) === null || _c === void 0 ? void 0 : _c.split("/");
          if (countHeader && contentRange && contentRange.length > 1) {
            count = parseInt(contentRange[1]);
          }
          if (this.isMaybeSingle && this.method === "GET" && Array.isArray(data)) {
            if (data.length > 1) {
              error2 = {
                // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
                code: "PGRST116",
                details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                hint: null,
                message: "JSON object requested, multiple (or no) rows returned"
              };
              data = null;
              count = null;
              status = 406;
              statusText = "Not Acceptable";
            } else if (data.length === 1) {
              data = data[0];
            } else {
              data = null;
            }
          }
        } else {
          const body = await res2.text();
          try {
            error2 = JSON.parse(body);
            if (Array.isArray(error2) && res2.status === 404) {
              data = [];
              error2 = null;
              status = 200;
              statusText = "OK";
            }
          } catch (_e) {
            if (res2.status === 404 && body === "") {
              status = 204;
              statusText = "No Content";
            } else {
              error2 = {
                message: body
              };
            }
          }
          if (error2 && this.isMaybeSingle && ((_d = error2 === null || error2 === void 0 ? void 0 : error2.details) === null || _d === void 0 ? void 0 : _d.includes("0 rows"))) {
            error2 = null;
            status = 200;
            statusText = "OK";
          }
          if (error2 && this.shouldThrowOnError) {
            throw new PostgrestError_1.default(error2);
          }
        }
        const postgrestResponse = {
          error: error2,
          data,
          count,
          status,
          statusText
        };
        return postgrestResponse;
      });
      if (!this.shouldThrowOnError) {
        res = res.catch((fetchError) => {
          var _a2, _b, _c, _d, _e, _f;
          let errorDetails = "";
          const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;
          if (cause) {
            const causeMessage = (_a2 = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _a2 !== void 0 ? _a2 : "";
            const causeCode = (_b = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _b !== void 0 ? _b : "";
            errorDetails = `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _c !== void 0 ? _c : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;
            errorDetails += `

Caused by: ${(_d = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _d !== void 0 ? _d : "Error"}: ${causeMessage}`;
            if (causeCode) {
              errorDetails += ` (${causeCode})`;
            }
            if (cause === null || cause === void 0 ? void 0 : cause.stack) {
              errorDetails += `
${cause.stack}`;
            }
          } else {
            errorDetails = (_e = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _e !== void 0 ? _e : "";
          }
          return {
            error: {
              message: `${(_f = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _f !== void 0 ? _f : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
              details: errorDetails,
              hint: "",
              code: ""
            },
            data: null,
            count: null,
            status: 0,
            statusText: ""
          };
        });
      }
      return res.then(onfulfilled, onrejected);
    }
    /**
     * Override the type of the returned `data`.
     *
     * @typeParam NewResult - The new result type to override with
     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
     */
    returns() {
      return this;
    }
    /**
     * Override the type of the returned `data` field in the response.
     *
     * @typeParam NewResult - The new type to cast the response data to
     * @typeParam Options - Optional type configuration (defaults to { merge: true })
     * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)
     * @example
     * ```typescript
     * // Merge with existing types (default behavior)
     * const query = supabase
     *   .from('users')
     *   .select()
     *   .overrideTypes<{ custom_field: string }>()
     *
     * // Replace existing types completely
     * const replaceQuery = supabase
     *   .from('users')
     *   .select()
     *   .overrideTypes<{ id: number; name: string }, { merge: false }>()
     * ```
     * @returns A PostgrestBuilder instance with the new type
     */
    overrideTypes() {
      return this;
    }
  };
  PostgrestBuilder.default = PostgrestBuilder$1;
  return PostgrestBuilder;
}
var hasRequiredPostgrestTransformBuilder;
function requirePostgrestTransformBuilder() {
  if (hasRequiredPostgrestTransformBuilder) return PostgrestTransformBuilder;
  hasRequiredPostgrestTransformBuilder = 1;
  Object.defineProperty(PostgrestTransformBuilder, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestBuilder_1 = tslib_1.__importDefault(requirePostgrestBuilder());
  let PostgrestTransformBuilder$1 = class PostgrestTransformBuilder extends PostgrestBuilder_1.default {
    /**
     * Perform a SELECT on the query result.
     *
     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
     * return modified rows. By calling this method, modified rows are returned in
     * `data`.
     *
     * @param columns - The columns to retrieve, separated by commas
     */
    select(columns) {
      let quoted = false;
      const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c2) => {
        if (/\s/.test(c2) && !quoted) {
          return "";
        }
        if (c2 === '"') {
          quoted = !quoted;
        }
        return c2;
      }).join("");
      this.url.searchParams.set("select", cleanedColumns);
      this.headers.append("Prefer", "return=representation");
      return this;
    }
    /**
     * Order the query result by `column`.
     *
     * You can call this method multiple times to order by multiple columns.
     *
     * You can order referenced tables, but it only affects the ordering of the
     * parent table if you use `!inner` in the query.
     *
     * @param column - The column to order by
     * @param options - Named parameters
     * @param options.ascending - If `true`, the result will be in ascending order
     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
     * `null`s appear last.
     * @param options.referencedTable - Set this to order a referenced table by
     * its columns
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */
    order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
      const key = referencedTable ? `${referencedTable}.order` : "order";
      const existingOrder = this.url.searchParams.get(key);
      this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column}.${ascending ? "asc" : "desc"}${nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
      return this;
    }
    /**
     * Limit the query result by `count`.
     *
     * @param count - The maximum number of rows to return
     * @param options - Named parameters
     * @param options.referencedTable - Set this to limit rows of referenced
     * tables instead of the parent table
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */
    limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
      const key = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
      this.url.searchParams.set(key, `${count}`);
      return this;
    }
    /**
     * Limit the query result by starting at an offset `from` and ending at the offset `to`.
     * Only records within this range are returned.
     * This respects the query order and if there is no order clause the range could behave unexpectedly.
     * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
     * and fourth rows of the query.
     *
     * @param from - The starting index from which to limit the result
     * @param to - The last index to which to limit the result
     * @param options - Named parameters
     * @param options.referencedTable - Set this to limit rows of referenced
     * tables instead of the parent table
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */
    range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {
      const keyOffset = typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`;
      const keyLimit = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
      this.url.searchParams.set(keyOffset, `${from}`);
      this.url.searchParams.set(keyLimit, `${to - from + 1}`);
      return this;
    }
    /**
     * Set the AbortSignal for the fetch request.
     *
     * @param signal - The AbortSignal to use for the fetch request
     */
    abortSignal(signal) {
      this.signal = signal;
      return this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be one row (e.g. using `.limit(1)`), otherwise this
     * returns an error.
     */
    single() {
      this.headers.set("Accept", "application/vnd.pgrst.object+json");
      return this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
     * this returns an error.
     */
    maybeSingle() {
      if (this.method === "GET") {
        this.headers.set("Accept", "application/json");
      } else {
        this.headers.set("Accept", "application/vnd.pgrst.object+json");
      }
      this.isMaybeSingle = true;
      return this;
    }
    /**
     * Return `data` as a string in CSV format.
     */
    csv() {
      this.headers.set("Accept", "text/csv");
      return this;
    }
    /**
     * Return `data` as an object in [GeoJSON](https://geojson.org) format.
     */
    geojson() {
      this.headers.set("Accept", "application/geo+json");
      return this;
    }
    /**
     * Return `data` as the EXPLAIN plan for the query.
     *
     * You need to enable the
     * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
     * setting before using this method.
     *
     * @param options - Named parameters
     *
     * @param options.analyze - If `true`, the query will be executed and the
     * actual run time will be returned
     *
     * @param options.verbose - If `true`, the query identifier will be returned
     * and `data` will include the output columns of the query
     *
     * @param options.settings - If `true`, include information on configuration
     * parameters that affect query planning
     *
     * @param options.buffers - If `true`, include information on buffer usage
     *
     * @param options.wal - If `true`, include information on WAL record generation
     *
     * @param options.format - The format of the output, can be `"text"` (default)
     * or `"json"`
     */
    explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
      var _a2;
      const options = [
        analyze ? "analyze" : null,
        verbose ? "verbose" : null,
        settings ? "settings" : null,
        buffers ? "buffers" : null,
        wal ? "wal" : null
      ].filter(Boolean).join("|");
      const forMediatype = (_a2 = this.headers.get("Accept")) !== null && _a2 !== void 0 ? _a2 : "application/json";
      this.headers.set("Accept", `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`);
      if (format === "json") {
        return this;
      } else {
        return this;
      }
    }
    /**
     * Rollback the query.
     *
     * `data` will still be returned, but the query is not committed.
     */
    rollback() {
      this.headers.append("Prefer", "tx=rollback");
      return this;
    }
    /**
     * Override the type of the returned `data`.
     *
     * @typeParam NewResult - The new result type to override with
     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
     */
    returns() {
      return this;
    }
    /**
     * Set the maximum number of rows that can be affected by the query.
     * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.
     *
     * @param value - The maximum number of rows that can be affected
     */
    maxAffected(value) {
      this.headers.append("Prefer", "handling=strict");
      this.headers.append("Prefer", `max-affected=${value}`);
      return this;
    }
  };
  PostgrestTransformBuilder.default = PostgrestTransformBuilder$1;
  return PostgrestTransformBuilder;
}
var hasRequiredPostgrestFilterBuilder;
function requirePostgrestFilterBuilder() {
  if (hasRequiredPostgrestFilterBuilder) return PostgrestFilterBuilder;
  hasRequiredPostgrestFilterBuilder = 1;
  Object.defineProperty(PostgrestFilterBuilder, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestTransformBuilder_1 = tslib_1.__importDefault(requirePostgrestTransformBuilder());
  const PostgrestReservedCharsRegexp = new RegExp("[,()]");
  let PostgrestFilterBuilder$1 = class PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default {
    /**
     * Match only rows where `column` is equal to `value`.
     *
     * To check if the value of `column` is NULL, you should use `.is()` instead.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    eq(column, value) {
      this.url.searchParams.append(column, `eq.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is not equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    neq(column, value) {
      this.url.searchParams.append(column, `neq.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is greater than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    gt(column, value) {
      this.url.searchParams.append(column, `gt.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is greater than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    gte(column, value) {
      this.url.searchParams.append(column, `gte.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is less than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    lt(column, value) {
      this.url.searchParams.append(column, `lt.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is less than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    lte(column, value) {
      this.url.searchParams.append(column, `lte.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-sensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */
    like(column, pattern) {
      this.url.searchParams.append(column, `like.${pattern}`);
      return this;
    }
    /**
     * Match only rows where `column` matches all of `patterns` case-sensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    likeAllOf(column, patterns) {
      this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
      return this;
    }
    /**
     * Match only rows where `column` matches any of `patterns` case-sensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    likeAnyOf(column, patterns) {
      this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
      return this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-insensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */
    ilike(column, pattern) {
      this.url.searchParams.append(column, `ilike.${pattern}`);
      return this;
    }
    /**
     * Match only rows where `column` matches all of `patterns` case-insensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    ilikeAllOf(column, patterns) {
      this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
      return this;
    }
    /**
     * Match only rows where `column` matches any of `patterns` case-insensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    ilikeAnyOf(column, patterns) {
      this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
      return this;
    }
    /**
     * Match only rows where `column` matches the PostgreSQL regex `pattern`
     * case-sensitively (using the `~` operator).
     *
     * @param column - The column to filter on
     * @param pattern - The PostgreSQL regular expression pattern to match with
     */
    regexMatch(column, pattern) {
      this.url.searchParams.append(column, `match.${pattern}`);
      return this;
    }
    /**
     * Match only rows where `column` matches the PostgreSQL regex `pattern`
     * case-insensitively (using the `~*` operator).
     *
     * @param column - The column to filter on
     * @param pattern - The PostgreSQL regular expression pattern to match with
     */
    regexIMatch(column, pattern) {
      this.url.searchParams.append(column, `imatch.${pattern}`);
      return this;
    }
    /**
     * Match only rows where `column` IS `value`.
     *
     * For non-boolean columns, this is only relevant for checking if the value of
     * `column` is NULL by setting `value` to `null`.
     *
     * For boolean columns, you can also set `value` to `true` or `false` and it
     * will behave the same way as `.eq()`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    is(column, value) {
      this.url.searchParams.append(column, `is.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` IS DISTINCT FROM `value`.
     *
     * Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values
     * are considered equal (not distinct), and comparing `NULL` with any non-NULL
     * value returns true (distinct).
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    isDistinct(column, value) {
      this.url.searchParams.append(column, `isdistinct.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is included in the `values` array.
     *
     * @param column - The column to filter on
     * @param values - The values array to filter with
     */
    in(column, values) {
      const cleanedValues = Array.from(new Set(values)).map((s2) => {
        if (typeof s2 === "string" && PostgrestReservedCharsRegexp.test(s2))
          return `"${s2}"`;
        else
          return `${s2}`;
      }).join(",");
      this.url.searchParams.append(column, `in.(${cleanedValues})`);
      return this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * `column` contains every element appearing in `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */
    contains(column, value) {
      if (typeof value === "string") {
        this.url.searchParams.append(column, `cs.${value}`);
      } else if (Array.isArray(value)) {
        this.url.searchParams.append(column, `cs.{${value.join(",")}}`);
      } else {
        this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
      }
      return this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * every element appearing in `column` is contained by `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */
    containedBy(column, value) {
      if (typeof value === "string") {
        this.url.searchParams.append(column, `cd.${value}`);
      } else if (Array.isArray(value)) {
        this.url.searchParams.append(column, `cd.{${value.join(",")}}`);
      } else {
        this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
      }
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is greater than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeGt(column, range) {
      this.url.searchParams.append(column, `sr.${range}`);
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or greater than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeGte(column, range) {
      this.url.searchParams.append(column, `nxl.${range}`);
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is less than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeLt(column, range) {
      this.url.searchParams.append(column, `sl.${range}`);
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or less than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeLte(column, range) {
      this.url.searchParams.append(column, `nxr.${range}`);
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where `column` is
     * mutually exclusive to `range` and there can be no element between the two
     * ranges.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeAdjacent(column, range) {
      this.url.searchParams.append(column, `adj.${range}`);
      return this;
    }
    /**
     * Only relevant for array and range columns. Match only rows where
     * `column` and `value` have an element in common.
     *
     * @param column - The array or range column to filter on
     * @param value - The array or range value to filter with
     */
    overlaps(column, value) {
      if (typeof value === "string") {
        this.url.searchParams.append(column, `ov.${value}`);
      } else {
        this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
      }
      return this;
    }
    /**
     * Only relevant for text and tsvector columns. Match only rows where
     * `column` matches the query string in `query`.
     *
     * @param column - The text or tsvector column to filter on
     * @param query - The query text to match with
     * @param options - Named parameters
     * @param options.config - The text search configuration to use
     * @param options.type - Change how the `query` text is interpreted
     */
    textSearch(column, query, { config: config2, type } = {}) {
      let typePart = "";
      if (type === "plain") {
        typePart = "pl";
      } else if (type === "phrase") {
        typePart = "ph";
      } else if (type === "websearch") {
        typePart = "w";
      }
      const configPart = config2 === void 0 ? "" : `(${config2})`;
      this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
      return this;
    }
    /**
     * Match only rows where each column in `query` keys is equal to its
     * associated value. Shorthand for multiple `.eq()`s.
     *
     * @param query - The object to filter with, with column names as keys mapped
     * to their filter values
     */
    match(query) {
      Object.entries(query).forEach(([column, value]) => {
        this.url.searchParams.append(column, `eq.${value}`);
      });
      return this;
    }
    /**
     * Match only rows which doesn't satisfy the filter.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to be negated to filter with, following
     * PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */
    not(column, operator, value) {
      this.url.searchParams.append(column, `not.${operator}.${value}`);
      return this;
    }
    /**
     * Match only rows which satisfy at least one of the filters.
     *
     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure it's properly sanitized.
     *
     * It's currently not possible to do an `.or()` filter across multiple tables.
     *
     * @param filters - The filters to use, following PostgREST syntax
     * @param options - Named parameters
     * @param options.referencedTable - Set this to filter on referenced tables
     * instead of the parent table
     * @param options.foreignTable - Deprecated, use `referencedTable` instead
     */
    or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
      const key = referencedTable ? `${referencedTable}.or` : "or";
      this.url.searchParams.append(key, `(${filters})`);
      return this;
    }
    /**
     * Match only rows which satisfy the filter. This is an escape hatch - you
     * should use the specific filter methods wherever possible.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to filter with, following PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */
    filter(column, operator, value) {
      this.url.searchParams.append(column, `${operator}.${value}`);
      return this;
    }
  };
  PostgrestFilterBuilder.default = PostgrestFilterBuilder$1;
  return PostgrestFilterBuilder;
}
var hasRequiredPostgrestQueryBuilder;
function requirePostgrestQueryBuilder() {
  if (hasRequiredPostgrestQueryBuilder) return PostgrestQueryBuilder;
  hasRequiredPostgrestQueryBuilder = 1;
  Object.defineProperty(PostgrestQueryBuilder, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestFilterBuilder_1 = tslib_1.__importDefault(requirePostgrestFilterBuilder());
  let PostgrestQueryBuilder$1 = class PostgrestQueryBuilder {
    /**
     * Creates a query builder scoped to a Postgres table or view.
     *
     * @example
     * ```ts
     * import PostgrestQueryBuilder from '@supabase/postgrest-js'
     *
     * const query = new PostgrestQueryBuilder(
     *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),
     *   { headers: { apikey: 'public-anon-key' } }
     * )
     * ```
     */
    constructor(url, { headers = {}, schema, fetch: fetch2 }) {
      this.url = url;
      this.headers = new Headers(headers);
      this.schema = schema;
      this.fetch = fetch2;
    }
    /**
     * Perform a SELECT query on the table or view.
     *
     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
     *
     * @param options - Named parameters
     *
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     *
     * @param options.count - Count algorithm to use to count rows in the table or view.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    select(columns, options) {
      const { head: head2 = false, count } = options !== null && options !== void 0 ? options : {};
      const method = head2 ? "HEAD" : "GET";
      let quoted = false;
      const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c2) => {
        if (/\s/.test(c2) && !quoted) {
          return "";
        }
        if (c2 === '"') {
          quoted = !quoted;
        }
        return c2;
      }).join("");
      this.url.searchParams.set("select", cleanedColumns);
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: this.fetch
      });
    }
    /**
     * Perform an INSERT into the table or view.
     *
     * By default, inserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to insert. Pass an object to insert a single row
     * or an array to insert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count inserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     *
     * @param options.defaultToNull - Make missing fields default to `null`.
     * Otherwise, use the default value for the column. Only applies for bulk
     * inserts.
     */
    insert(values, { count, defaultToNull = true } = {}) {
      var _a2;
      const method = "POST";
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      if (!defaultToNull) {
        this.headers.append("Prefer", `missing=default`);
      }
      if (Array.isArray(values)) {
        const columns = values.reduce((acc, x2) => acc.concat(Object.keys(x2)), []);
        if (columns.length > 0) {
          const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
          this.url.searchParams.set("columns", uniqueColumns.join(","));
        }
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: values,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
    /**
    * Perform an UPSERT on the table or view. Depending on the column(s) passed
    * to `onConflict`, `.upsert()` allows you to perform the equivalent of
    * `.insert()` if a row with the corresponding `onConflict` columns doesn't
    * exist, or if it does exist, perform an alternative action depending on
    * `ignoreDuplicates`.
    *
    * By default, upserted rows are not returned. To return it, chain the call
    * with `.select()`.
    *
    * @param values - The values to upsert with. Pass an object to upsert a
    * single row or an array to upsert multiple rows.
    *
    * @param options - Named parameters
    *
    * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
    * duplicate rows are determined. Two rows are duplicates if all the
    * `onConflict` columns are equal.
    *
    * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
    * `false`, duplicate rows are merged with existing rows.
    *
    * @param options.count - Count algorithm to use to count upserted rows.
    *
    * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
    * hood.
    *
    * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
    * statistics under the hood.
    *
    * `"estimated"`: Uses exact count for low numbers and planned count for high
    * numbers.
    *
    * @param options.defaultToNull - Make missing fields default to `null`.
    * Otherwise, use the default value for the column. This only applies when
    * inserting new rows, not when merging with existing rows under
    * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
    *
    * @example Upsert a single row using a unique key
    * ```ts
    * // Upserting a single row, overwriting based on the 'username' unique column
    * const { data, error } = await supabase
    *   .from('users')
    *   .upsert({ username: 'supabot' }, { onConflict: 'username' })
    *
    * // Example response:
    * // {
    * //   data: [
    * //     { id: 4, message: 'bar', username: 'supabot' }
    * //   ],
    * //   error: null
    * // }
    * ```
    *
    * @example Upsert with conflict resolution and exact row counting
    * ```ts
    * // Upserting and returning exact count
    * const { data, error, count } = await supabase
    *   .from('users')
    *   .upsert(
    *     {
    *       id: 3,
    *       message: 'foo',
    *       username: 'supabot'
    *     },
    *     {
    *       onConflict: 'username',
    *       count: 'exact'
    *     }
    *   )
    *
    * // Example response:
    * // {
    * //   data: [
    * //     {
    * //       id: 42,
    * //       handle: "saoirse",
    * //       display_name: "Saoirse"
    * //     }
    * //   ],
    * //   count: 1,
    * //   error: null
    * // }
    * ```
    */
    upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
      var _a2;
      const method = "POST";
      this.headers.append("Prefer", `resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`);
      if (onConflict !== void 0)
        this.url.searchParams.set("on_conflict", onConflict);
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      if (!defaultToNull) {
        this.headers.append("Prefer", "missing=default");
      }
      if (Array.isArray(values)) {
        const columns = values.reduce((acc, x2) => acc.concat(Object.keys(x2)), []);
        if (columns.length > 0) {
          const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
          this.url.searchParams.set("columns", uniqueColumns.join(","));
        }
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: values,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
    /**
     * Perform an UPDATE on the table or view.
     *
     * By default, updated rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param values - The values to update with
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count updated rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    update(values, { count } = {}) {
      var _a2;
      const method = "PATCH";
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: values,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
    /**
     * Perform a DELETE on the table or view.
     *
     * By default, deleted rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count deleted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    delete({ count } = {}) {
      var _a2;
      const method = "DELETE";
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
  };
  PostgrestQueryBuilder.default = PostgrestQueryBuilder$1;
  return PostgrestQueryBuilder;
}
var hasRequiredPostgrestClient;
function requirePostgrestClient() {
  if (hasRequiredPostgrestClient) return PostgrestClient;
  hasRequiredPostgrestClient = 1;
  Object.defineProperty(PostgrestClient, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestQueryBuilder_1 = tslib_1.__importDefault(requirePostgrestQueryBuilder());
  const PostgrestFilterBuilder_1 = tslib_1.__importDefault(requirePostgrestFilterBuilder());
  let PostgrestClient$1 = class PostgrestClient2 {
    // TODO: Add back shouldThrowOnError once we figure out the typings
    /**
     * Creates a PostgREST client.
     *
     * @param url - URL of the PostgREST endpoint
     * @param options - Named parameters
     * @param options.headers - Custom headers
     * @param options.schema - Postgres schema to switch to
     * @param options.fetch - Custom fetch
     * @example
     * ```ts
     * import PostgrestClient from '@supabase/postgrest-js'
     *
     * const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {
     *   headers: { apikey: 'public-anon-key' },
     *   schema: 'public',
     * })
     * ```
     */
    constructor(url, { headers = {}, schema, fetch: fetch2 } = {}) {
      this.url = url;
      this.headers = new Headers(headers);
      this.schemaName = schema;
      this.fetch = fetch2;
    }
    /**
     * Perform a query on a table or a view.
     *
     * @param relation - The table or view name to query
     */
    from(relation) {
      if (!relation || typeof relation !== "string" || relation.trim() === "") {
        throw new Error("Invalid relation name: relation must be a non-empty string.");
      }
      const url = new URL(`${this.url}/${relation}`);
      return new PostgrestQueryBuilder_1.default(url, {
        headers: new Headers(this.headers),
        schema: this.schemaName,
        fetch: this.fetch
      });
    }
    /**
     * Select a schema to query or perform an function (rpc) call.
     *
     * The schema needs to be on the list of exposed schemas inside Supabase.
     *
     * @param schema - The schema to query
     */
    schema(schema) {
      return new PostgrestClient2(this.url, {
        headers: this.headers,
        schema,
        fetch: this.fetch
      });
    }
    /**
     * Perform a function call.
     *
     * @param fn - The function name to call
     * @param args - The arguments to pass to the function call
     * @param options - Named parameters
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     * @param options.get - When set to `true`, the function will be called with
     * read-only access mode.
     * @param options.count - Count algorithm to use to count rows returned by the
     * function. Only applicable for [set-returning
     * functions](https://www.postgresql.org/docs/current/functions-srf.html).
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     *
     * @example
     * ```ts
     * // For cross-schema functions where type inference fails, use overrideTypes:
     * const { data } = await supabase
     *   .schema('schema_b')
     *   .rpc('function_a', {})
     *   .overrideTypes<{ id: string; user_id: string }[]>()
     * ```
     */
    rpc(fn, args = {}, { head: head2 = false, get: get2 = false, count } = {}) {
      var _a2;
      let method;
      const url = new URL(`${this.url}/rpc/${fn}`);
      let body;
      if (head2 || get2) {
        method = head2 ? "HEAD" : "GET";
        Object.entries(args).filter(([_2, value]) => value !== void 0).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(",")}}` : `${value}`]).forEach(([name, value]) => {
          url.searchParams.append(name, value);
        });
      } else {
        method = "POST";
        body = args;
      }
      const headers = new Headers(this.headers);
      if (count) {
        headers.set("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url,
        headers,
        schema: this.schemaName,
        body,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
  };
  PostgrestClient.default = PostgrestClient$1;
  return PostgrestClient;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  Object.defineProperty(cjs, "__esModule", { value: true });
  cjs.PostgrestError = cjs.PostgrestBuilder = cjs.PostgrestTransformBuilder = cjs.PostgrestFilterBuilder = cjs.PostgrestQueryBuilder = cjs.PostgrestClient = void 0;
  const tslib_1 = require$$0;
  const PostgrestClient_1 = tslib_1.__importDefault(requirePostgrestClient());
  cjs.PostgrestClient = PostgrestClient_1.default;
  const PostgrestQueryBuilder_1 = tslib_1.__importDefault(requirePostgrestQueryBuilder());
  cjs.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
  const PostgrestFilterBuilder_1 = tslib_1.__importDefault(requirePostgrestFilterBuilder());
  cjs.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
  const PostgrestTransformBuilder_1 = tslib_1.__importDefault(requirePostgrestTransformBuilder());
  cjs.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;
  const PostgrestBuilder_1 = tslib_1.__importDefault(requirePostgrestBuilder());
  cjs.PostgrestBuilder = PostgrestBuilder_1.default;
  const PostgrestError_1 = tslib_1.__importDefault(requirePostgrestError());
  cjs.PostgrestError = PostgrestError_1.default;
  cjs.default = {
    PostgrestClient: PostgrestClient_1.default,
    PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,
    PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,
    PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,
    PostgrestBuilder: PostgrestBuilder_1.default,
    PostgrestError: PostgrestError_1.default
  };
  return cjs;
}
class WebSocketFactory {
  /**
   * Static-only utility  prevent instantiation.
   */
  constructor() {
  }
  static detectEnvironment() {
    var _a2;
    if (typeof WebSocket !== "undefined") {
      return { type: "native", constructor: WebSocket };
    }
    if (typeof globalThis !== "undefined" && typeof globalThis.WebSocket !== "undefined") {
      return { type: "native", constructor: globalThis.WebSocket };
    }
    if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
      return { type: "native", constructor: global.WebSocket };
    }
    if (typeof globalThis !== "undefined" && typeof globalThis.WebSocketPair !== "undefined" && typeof globalThis.WebSocket === "undefined") {
      return {
        type: "cloudflare",
        error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
        workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
      };
    }
    if (typeof globalThis !== "undefined" && globalThis.EdgeRuntime || typeof navigator !== "undefined" && ((_a2 = navigator.userAgent) === null || _a2 === void 0 ? void 0 : _a2.includes("Vercel-Edge"))) {
      return {
        type: "unsupported",
        error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
        workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
      };
    }
    if (typeof process !== "undefined") {
      const processVersions = process["versions"];
      if (processVersions && processVersions["node"]) {
        const versionString = processVersions["node"];
        const nodeVersion = parseInt(versionString.replace(/^v/, "").split(".")[0]);
        if (nodeVersion >= 22) {
          if (typeof globalThis.WebSocket !== "undefined") {
            return { type: "native", constructor: globalThis.WebSocket };
          }
          return {
            type: "unsupported",
            error: `Node.js ${nodeVersion} detected but native WebSocket not found.`,
            workaround: "Provide a WebSocket implementation via the transport option."
          };
        }
        return {
          type: "unsupported",
          error: `Node.js ${nodeVersion} detected without native WebSocket support.`,
          workaround: 'For Node.js < 22, install "ws" package and provide it via the transport option:\nimport ws from "ws"\nnew RealtimeClient(url, { transport: ws })'
        };
      }
    }
    return {
      type: "unsupported",
      error: "Unknown JavaScript runtime without WebSocket support.",
      workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
    };
  }
  /**
   * Returns the best available WebSocket constructor for the current runtime.
   *
   * @example
   * ```ts
   * const WS = WebSocketFactory.getWebSocketConstructor()
   * const socket = new WS('wss://realtime.supabase.co/socket')
   * ```
   */
  static getWebSocketConstructor() {
    const env = this.detectEnvironment();
    if (env.constructor) {
      return env.constructor;
    }
    let errorMessage = env.error || "WebSocket not supported in this environment.";
    if (env.workaround) {
      errorMessage += `

Suggested solution: ${env.workaround}`;
    }
    throw new Error(errorMessage);
  }
  /**
   * Creates a WebSocket using the detected constructor.
   *
   * @example
   * ```ts
   * const socket = WebSocketFactory.createWebSocket('wss://realtime.supabase.co/socket')
   * ```
   */
  static createWebSocket(url, protocols) {
    const WS = this.getWebSocketConstructor();
    return new WS(url, protocols);
  }
  /**
   * Detects whether the runtime can establish WebSocket connections.
   *
   * @example
   * ```ts
   * if (!WebSocketFactory.isWebSocketSupported()) {
   *   console.warn('Falling back to long polling')
   * }
   * ```
   */
  static isWebSocketSupported() {
    try {
      const env = this.detectEnvironment();
      return env.type === "native" || env.type === "ws";
    } catch (_a2) {
      return false;
    }
  }
}
const version$4 = "2.87.1";
const DEFAULT_VERSION = `realtime-js/${version$4}`;
const VSN_1_0_0 = "1.0.0";
const VSN_2_0_0 = "2.0.0";
const DEFAULT_VSN = VSN_1_0_0;
const DEFAULT_TIMEOUT = 1e4;
const WS_CLOSE_NORMAL = 1e3;
const MAX_PUSH_BUFFER_SIZE = 100;
var SOCKET_STATES;
(function(SOCKET_STATES2) {
  SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
  SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
  SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
  SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function(CHANNEL_STATES2) {
  CHANNEL_STATES2["closed"] = "closed";
  CHANNEL_STATES2["errored"] = "errored";
  CHANNEL_STATES2["joined"] = "joined";
  CHANNEL_STATES2["joining"] = "joining";
  CHANNEL_STATES2["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function(CHANNEL_EVENTS2) {
  CHANNEL_EVENTS2["close"] = "phx_close";
  CHANNEL_EVENTS2["error"] = "phx_error";
  CHANNEL_EVENTS2["join"] = "phx_join";
  CHANNEL_EVENTS2["reply"] = "phx_reply";
  CHANNEL_EVENTS2["leave"] = "phx_leave";
  CHANNEL_EVENTS2["access_token"] = "access_token";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function(TRANSPORTS2) {
  TRANSPORTS2["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));
var CONNECTION_STATE;
(function(CONNECTION_STATE2) {
  CONNECTION_STATE2["Connecting"] = "connecting";
  CONNECTION_STATE2["Open"] = "open";
  CONNECTION_STATE2["Closing"] = "closing";
  CONNECTION_STATE2["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {}));
class Serializer {
  constructor(allowedMetadataKeys) {
    this.HEADER_LENGTH = 1;
    this.USER_BROADCAST_PUSH_META_LENGTH = 6;
    this.KINDS = { userBroadcastPush: 3, userBroadcast: 4 };
    this.BINARY_ENCODING = 0;
    this.JSON_ENCODING = 1;
    this.BROADCAST_EVENT = "broadcast";
    this.allowedMetadataKeys = [];
    this.allowedMetadataKeys = allowedMetadataKeys !== null && allowedMetadataKeys !== void 0 ? allowedMetadataKeys : [];
  }
  encode(msg, callback) {
    if (msg.event === this.BROADCAST_EVENT && !(msg.payload instanceof ArrayBuffer) && typeof msg.payload.event === "string") {
      return callback(this._binaryEncodeUserBroadcastPush(msg));
    }
    let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
    return callback(JSON.stringify(payload));
  }
  _binaryEncodeUserBroadcastPush(message) {
    var _a2;
    if (this._isArrayBuffer((_a2 = message.payload) === null || _a2 === void 0 ? void 0 : _a2.payload)) {
      return this._encodeBinaryUserBroadcastPush(message);
    } else {
      return this._encodeJsonUserBroadcastPush(message);
    }
  }
  _encodeBinaryUserBroadcastPush(message) {
    var _a2, _b;
    const userPayload = (_b = (_a2 = message.payload) === null || _a2 === void 0 ? void 0 : _a2.payload) !== null && _b !== void 0 ? _b : new ArrayBuffer(0);
    return this._encodeUserBroadcastPush(message, this.BINARY_ENCODING, userPayload);
  }
  _encodeJsonUserBroadcastPush(message) {
    var _a2, _b;
    const userPayload = (_b = (_a2 = message.payload) === null || _a2 === void 0 ? void 0 : _a2.payload) !== null && _b !== void 0 ? _b : {};
    const encoder = new TextEncoder();
    const encodedUserPayload = encoder.encode(JSON.stringify(userPayload)).buffer;
    return this._encodeUserBroadcastPush(message, this.JSON_ENCODING, encodedUserPayload);
  }
  _encodeUserBroadcastPush(message, encodingType, encodedPayload) {
    var _a2, _b;
    const topic = message.topic;
    const ref = (_a2 = message.ref) !== null && _a2 !== void 0 ? _a2 : "";
    const joinRef = (_b = message.join_ref) !== null && _b !== void 0 ? _b : "";
    const userEvent = message.payload.event;
    const rest = this.allowedMetadataKeys ? this._pick(message.payload, this.allowedMetadataKeys) : {};
    const metadata = Object.keys(rest).length === 0 ? "" : JSON.stringify(rest);
    if (joinRef.length > 255) {
      throw new Error(`joinRef length ${joinRef.length} exceeds maximum of 255`);
    }
    if (ref.length > 255) {
      throw new Error(`ref length ${ref.length} exceeds maximum of 255`);
    }
    if (topic.length > 255) {
      throw new Error(`topic length ${topic.length} exceeds maximum of 255`);
    }
    if (userEvent.length > 255) {
      throw new Error(`userEvent length ${userEvent.length} exceeds maximum of 255`);
    }
    if (metadata.length > 255) {
      throw new Error(`metadata length ${metadata.length} exceeds maximum of 255`);
    }
    const metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length + metadata.length;
    const header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
    let view = new DataView(header);
    let offset = 0;
    view.setUint8(offset++, this.KINDS.userBroadcastPush);
    view.setUint8(offset++, joinRef.length);
    view.setUint8(offset++, ref.length);
    view.setUint8(offset++, topic.length);
    view.setUint8(offset++, userEvent.length);
    view.setUint8(offset++, metadata.length);
    view.setUint8(offset++, encodingType);
    Array.from(joinRef, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(userEvent, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(metadata, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    var combined = new Uint8Array(header.byteLength + encodedPayload.byteLength);
    combined.set(new Uint8Array(header), 0);
    combined.set(new Uint8Array(encodedPayload), header.byteLength);
    return combined.buffer;
  }
  decode(rawPayload, callback) {
    if (this._isArrayBuffer(rawPayload)) {
      let result = this._binaryDecode(rawPayload);
      return callback(result);
    }
    if (typeof rawPayload === "string") {
      const jsonPayload = JSON.parse(rawPayload);
      const [join_ref, ref, topic, event, payload] = jsonPayload;
      return callback({ join_ref, ref, topic, event, payload });
    }
    return callback({});
  }
  _binaryDecode(buffer) {
    const view = new DataView(buffer);
    const kind = view.getUint8(0);
    const decoder = new TextDecoder();
    switch (kind) {
      case this.KINDS.userBroadcast:
        return this._decodeUserBroadcast(buffer, view, decoder);
    }
  }
  _decodeUserBroadcast(buffer, view, decoder) {
    const topicSize = view.getUint8(1);
    const userEventSize = view.getUint8(2);
    const metadataSize = view.getUint8(3);
    const payloadEncoding = view.getUint8(4);
    let offset = this.HEADER_LENGTH + 4;
    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    const userEvent = decoder.decode(buffer.slice(offset, offset + userEventSize));
    offset = offset + userEventSize;
    const metadata = decoder.decode(buffer.slice(offset, offset + metadataSize));
    offset = offset + metadataSize;
    const payload = buffer.slice(offset, buffer.byteLength);
    const parsedPayload = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(payload)) : payload;
    const data = {
      type: this.BROADCAST_EVENT,
      event: userEvent,
      payload: parsedPayload
    };
    if (metadataSize > 0) {
      data["meta"] = JSON.parse(metadata);
    }
    return { join_ref: null, ref: null, topic, event: this.BROADCAST_EVENT, payload: data };
  }
  _isArrayBuffer(buffer) {
    var _a2;
    return buffer instanceof ArrayBuffer || ((_a2 = buffer === null || buffer === void 0 ? void 0 : buffer.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) === "ArrayBuffer";
  }
  _pick(obj, keys) {
    if (!obj || typeof obj !== "object") {
      return {};
    }
    return Object.fromEntries(Object.entries(obj).filter(([key]) => keys.includes(key)));
  }
}
class Timer2 {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = void 0;
    this.tries = 0;
    this.callback = callback;
    this.timerCalc = timerCalc;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
    this.timer = void 0;
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
}
var PostgresTypes;
(function(PostgresTypes2) {
  PostgresTypes2["abstime"] = "abstime";
  PostgresTypes2["bool"] = "bool";
  PostgresTypes2["date"] = "date";
  PostgresTypes2["daterange"] = "daterange";
  PostgresTypes2["float4"] = "float4";
  PostgresTypes2["float8"] = "float8";
  PostgresTypes2["int2"] = "int2";
  PostgresTypes2["int4"] = "int4";
  PostgresTypes2["int4range"] = "int4range";
  PostgresTypes2["int8"] = "int8";
  PostgresTypes2["int8range"] = "int8range";
  PostgresTypes2["json"] = "json";
  PostgresTypes2["jsonb"] = "jsonb";
  PostgresTypes2["money"] = "money";
  PostgresTypes2["numeric"] = "numeric";
  PostgresTypes2["oid"] = "oid";
  PostgresTypes2["reltime"] = "reltime";
  PostgresTypes2["text"] = "text";
  PostgresTypes2["time"] = "time";
  PostgresTypes2["timestamp"] = "timestamp";
  PostgresTypes2["timestamptz"] = "timestamptz";
  PostgresTypes2["timetz"] = "timetz";
  PostgresTypes2["tsrange"] = "tsrange";
  PostgresTypes2["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
const convertChangeData = (columns, record, options = {}) => {
  var _a2;
  const skipTypes = (_a2 = options.skipTypes) !== null && _a2 !== void 0 ? _a2 : [];
  if (!record) {
    return {};
  }
  return Object.keys(record).reduce((acc, rec_key) => {
    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
    return acc;
  }, {});
};
const convertColumn = (columnName, columns, record, skipTypes) => {
  const column = columns.find((x2) => x2.name === columnName);
  const colType = column === null || column === void 0 ? void 0 : column.type;
  const value = record[columnName];
  if (colType && !skipTypes.includes(colType)) {
    return convertCell(colType, value);
  }
  return noop$2(value);
};
const convertCell = (type, value) => {
  if (type.charAt(0) === "_") {
    const dataType = type.slice(1, type.length);
    return toArray(value, dataType);
  }
  switch (type) {
    case PostgresTypes.bool:
      return toBoolean(value);
    case PostgresTypes.float4:
    case PostgresTypes.float8:
    case PostgresTypes.int2:
    case PostgresTypes.int4:
    case PostgresTypes.int8:
    case PostgresTypes.numeric:
    case PostgresTypes.oid:
      return toNumber$1(value);
    case PostgresTypes.json:
    case PostgresTypes.jsonb:
      return toJson(value);
    case PostgresTypes.timestamp:
      return toTimestampString(value);
    // Format to be consistent with PostgREST
    case PostgresTypes.abstime:
    // To allow users to cast it based on Timezone
    case PostgresTypes.date:
    // To allow users to cast it based on Timezone
    case PostgresTypes.daterange:
    case PostgresTypes.int4range:
    case PostgresTypes.int8range:
    case PostgresTypes.money:
    case PostgresTypes.reltime:
    // To allow users to cast it based on Timezone
    case PostgresTypes.text:
    case PostgresTypes.time:
    // To allow users to cast it based on Timezone
    case PostgresTypes.timestamptz:
    // To allow users to cast it based on Timezone
    case PostgresTypes.timetz:
    // To allow users to cast it based on Timezone
    case PostgresTypes.tsrange:
    case PostgresTypes.tstzrange:
      return noop$2(value);
    default:
      return noop$2(value);
  }
};
const noop$2 = (value) => {
  return value;
};
const toBoolean = (value) => {
  switch (value) {
    case "t":
      return true;
    case "f":
      return false;
    default:
      return value;
  }
};
const toNumber$1 = (value) => {
  if (typeof value === "string") {
    const parsedValue = parseFloat(value);
    if (!Number.isNaN(parsedValue)) {
      return parsedValue;
    }
  }
  return value;
};
const toJson = (value) => {
  if (typeof value === "string") {
    try {
      return JSON.parse(value);
    } catch (error2) {
      console.log(`JSON parse error: ${error2}`);
      return value;
    }
  }
  return value;
};
const toArray = (value, type) => {
  if (typeof value !== "string") {
    return value;
  }
  const lastIdx = value.length - 1;
  const closeBrace = value[lastIdx];
  const openBrace = value[0];
  if (openBrace === "{" && closeBrace === "}") {
    let arr;
    const valTrim = value.slice(1, lastIdx);
    try {
      arr = JSON.parse("[" + valTrim + "]");
    } catch (_2) {
      arr = valTrim ? valTrim.split(",") : [];
    }
    return arr.map((val) => convertCell(type, val));
  }
  return value;
};
const toTimestampString = (value) => {
  if (typeof value === "string") {
    return value.replace(" ", "T");
  }
  return value;
};
const httpEndpointURL = (socketUrl) => {
  const wsUrl = new URL(socketUrl);
  wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, "http");
  wsUrl.pathname = wsUrl.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, "");
  if (wsUrl.pathname === "" || wsUrl.pathname === "/") {
    wsUrl.pathname = "/api/broadcast";
  } else {
    wsUrl.pathname = wsUrl.pathname + "/api/broadcast";
  }
  return wsUrl.href;
};
class Push {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {
    this.channel = channel;
    this.event = event;
    this.payload = payload;
    this.timeout = timeout;
    this.sent = false;
    this.timeoutTimer = void 0;
    this.ref = "";
    this.receivedResp = null;
    this.recHooks = [];
    this.refEvent = null;
  }
  resend(timeout) {
    this.timeout = timeout;
    this._cancelRefEvent();
    this.ref = "";
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
    this.send();
  }
  send() {
    if (this._hasReceived("timeout")) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    });
  }
  updatePayload(payload) {
    this.payload = Object.assign(Object.assign({}, this.payload), payload);
  }
  receive(status, callback) {
    var _a2;
    if (this._hasReceived(status)) {
      callback((_a2 = this.receivedResp) === null || _a2 === void 0 ? void 0 : _a2.response);
    }
    this.recHooks.push({ status, callback });
    return this;
  }
  startTimeout() {
    if (this.timeoutTimer) {
      return;
    }
    this.ref = this.channel.socket._makeRef();
    this.refEvent = this.channel._replyEventName(this.ref);
    const callback = (payload) => {
      this._cancelRefEvent();
      this._cancelTimeout();
      this.receivedResp = payload;
      this._matchReceive(payload);
    };
    this.channel._on(this.refEvent, {}, callback);
    this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  trigger(status, response) {
    if (this.refEvent)
      this.channel._trigger(this.refEvent, { status, response });
  }
  destroy() {
    this._cancelRefEvent();
    this._cancelTimeout();
  }
  _cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = void 0;
  }
  _matchReceive({ status, response }) {
    this.recHooks.filter((h2) => h2.status === status).forEach((h2) => h2.callback(response));
  }
  _hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
}
var REALTIME_PRESENCE_LISTEN_EVENTS$1;
(function(REALTIME_PRESENCE_LISTEN_EVENTS2) {
  REALTIME_PRESENCE_LISTEN_EVENTS2["SYNC"] = "sync";
  REALTIME_PRESENCE_LISTEN_EVENTS2["JOIN"] = "join";
  REALTIME_PRESENCE_LISTEN_EVENTS2["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS$1 || (REALTIME_PRESENCE_LISTEN_EVENTS$1 = {}));
let RealtimePresence$1 = class RealtimePresence {
  /**
   * Creates a Presence helper that keeps the local presence state in sync with the server.
   *
   * @param channel - The realtime channel to bind to.
   * @param opts - Optional custom event names, e.g. `{ events: { state: 'state', diff: 'diff' } }`.
   *
   * @example
   * ```ts
   * const presence = new RealtimePresence(channel)
   *
   * channel.on('presence', ({ event, key }) => {
   *   console.log(`Presence ${event} on ${key}`)
   * })
   * ```
   */
  constructor(channel, opts) {
    this.channel = channel;
    this.state = {};
    this.pendingDiffs = [];
    this.joinRef = null;
    this.enabled = false;
    this.caller = {
      onJoin: () => {
      },
      onLeave: () => {
      },
      onSync: () => {
      }
    };
    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
      state: "presence_state",
      diff: "presence_diff"
    };
    this.channel._on(events.state, {}, (newState) => {
      const { onJoin, onLeave, onSync } = this.caller;
      this.joinRef = this.channel._joinRef();
      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach((diff) => {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel._on(events.diff, {}, (diff) => {
      const { onJoin, onLeave, onSync } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
    this.onJoin((key, currentPresences, newPresences) => {
      this.channel._trigger("presence", {
        event: "join",
        key,
        currentPresences,
        newPresences
      });
    });
    this.onLeave((key, currentPresences, leftPresences) => {
      this.channel._trigger("presence", {
        event: "leave",
        key,
        currentPresences,
        leftPresences
      });
    });
    this.onSync(() => {
      this.channel._trigger("presence", { event: "sync" });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(currentState, newState, onJoin, onLeave) {
    const state = this.cloneDeep(currentState);
    const transformedState = this.transformState(newState);
    const joins = {};
    const leaves = {};
    this.map(state, (key, presences) => {
      if (!transformedState[key]) {
        leaves[key] = presences;
      }
    });
    this.map(transformedState, (key, newPresences) => {
      const currentPresences = state[key];
      if (currentPresences) {
        const newPresenceRefs = newPresences.map((m2) => m2.presence_ref);
        const curPresenceRefs = currentPresences.map((m2) => m2.presence_ref);
        const joinedPresences = newPresences.filter((m2) => curPresenceRefs.indexOf(m2.presence_ref) < 0);
        const leftPresences = currentPresences.filter((m2) => newPresenceRefs.indexOf(m2.presence_ref) < 0);
        if (joinedPresences.length > 0) {
          joins[key] = joinedPresences;
        }
        if (leftPresences.length > 0) {
          leaves[key] = leftPresences;
        }
      } else {
        joins[key] = newPresences;
      }
    });
    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(state, diff, onJoin, onLeave) {
    const { joins, leaves } = {
      joins: this.transformState(diff.joins),
      leaves: this.transformState(diff.leaves)
    };
    if (!onJoin) {
      onJoin = () => {
      };
    }
    if (!onLeave) {
      onLeave = () => {
      };
    }
    this.map(joins, (key, newPresences) => {
      var _a2;
      const currentPresences = (_a2 = state[key]) !== null && _a2 !== void 0 ? _a2 : [];
      state[key] = this.cloneDeep(newPresences);
      if (currentPresences.length > 0) {
        const joinedPresenceRefs = state[key].map((m2) => m2.presence_ref);
        const curPresences = currentPresences.filter((m2) => joinedPresenceRefs.indexOf(m2.presence_ref) < 0);
        state[key].unshift(...curPresences);
      }
      onJoin(key, currentPresences, newPresences);
    });
    this.map(leaves, (key, leftPresences) => {
      let currentPresences = state[key];
      if (!currentPresences)
        return;
      const presenceRefsToRemove = leftPresences.map((m2) => m2.presence_ref);
      currentPresences = currentPresences.filter((m2) => presenceRefsToRemove.indexOf(m2.presence_ref) < 0);
      state[key] = currentPresences;
      onLeave(key, currentPresences, leftPresences);
      if (currentPresences.length === 0)
        delete state[key];
    });
    return state;
  }
  /** @internal */
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(state) {
    state = this.cloneDeep(state);
    return Object.getOwnPropertyNames(state).reduce((newState, key) => {
      const presences = state[key];
      if ("metas" in presences) {
        newState[key] = presences.metas.map((presence) => {
          presence["presence_ref"] = presence["phx_ref"];
          delete presence["phx_ref"];
          delete presence["phx_ref_prev"];
          return presence;
        });
      } else {
        newState[key] = presences;
      }
      return newState;
    }, {});
  }
  /** @internal */
  static cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /** @internal */
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  /** @internal */
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  /** @internal */
  onSync(callback) {
    this.caller.onSync = callback;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
};
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT$1;
(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["ALL"] = "*";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["INSERT"] = "INSERT";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["UPDATE"] = "UPDATE";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT$1 || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT$1 = {}));
var REALTIME_LISTEN_TYPES$1;
(function(REALTIME_LISTEN_TYPES2) {
  REALTIME_LISTEN_TYPES2["BROADCAST"] = "broadcast";
  REALTIME_LISTEN_TYPES2["PRESENCE"] = "presence";
  REALTIME_LISTEN_TYPES2["POSTGRES_CHANGES"] = "postgres_changes";
  REALTIME_LISTEN_TYPES2["SYSTEM"] = "system";
})(REALTIME_LISTEN_TYPES$1 || (REALTIME_LISTEN_TYPES$1 = {}));
var REALTIME_SUBSCRIBE_STATES$1;
(function(REALTIME_SUBSCRIBE_STATES2) {
  REALTIME_SUBSCRIBE_STATES2["SUBSCRIBED"] = "SUBSCRIBED";
  REALTIME_SUBSCRIBE_STATES2["TIMED_OUT"] = "TIMED_OUT";
  REALTIME_SUBSCRIBE_STATES2["CLOSED"] = "CLOSED";
  REALTIME_SUBSCRIBE_STATES2["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES$1 || (REALTIME_SUBSCRIBE_STATES$1 = {}));
const REALTIME_CHANNEL_STATES$1 = CHANNEL_STATES;
let RealtimeChannel$1 = class RealtimeChannel {
  /**
   * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.
   *
   * The topic determines which realtime stream you are subscribing to. Config options let you
   * enable acknowledgement for broadcasts, presence tracking, or private channels.
   *
   * @example
   * ```ts
   * import RealtimeClient from '@supabase/realtime-js'
   *
   * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {
   *   params: { apikey: 'public-anon-key' },
   * })
   * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)
   * ```
   */
  constructor(topic, params = { config: {} }, socket) {
    var _a2, _b;
    this.topic = topic;
    this.params = params;
    this.socket = socket;
    this.bindings = {};
    this.state = CHANNEL_STATES.closed;
    this.joinedOnce = false;
    this.pushBuffer = [];
    this.subTopic = topic.replace(/^realtime:/i, "");
    this.params.config = Object.assign({
      broadcast: { ack: false, self: false },
      presence: { key: "", enabled: false },
      private: false
    }, params.config);
    this.timeout = this.socket.timeout;
    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
    this.rejoinTimer = new Timer2(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
    this.joinPush.receive("ok", () => {
      this.state = CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach((pushEvent) => pushEvent.send());
      this.pushBuffer = [];
    });
    this._onClose(() => {
      this.rejoinTimer.reset();
      this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
      this.state = CHANNEL_STATES.closed;
      this.socket._remove(this);
    });
    this._onError((reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("timeout", () => {
      if (!this._isJoining()) {
        return;
      }
      this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("error", (reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {
      this._trigger(this._replyEventName(ref), payload);
    });
    this.presence = new RealtimePresence$1(this);
    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint);
    this.private = this.params.config.private || false;
    if (!this.private && ((_b = (_a2 = this.params.config) === null || _a2 === void 0 ? void 0 : _a2.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {
      throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;
    }
  }
  /** Subscribe registers your client with the server */
  subscribe(callback, timeout = this.timeout) {
    var _a2, _b, _c;
    if (!this.socket.isConnected()) {
      this.socket.connect();
    }
    if (this.state == CHANNEL_STATES.closed) {
      const { config: { broadcast, presence, private: isPrivate } } = this.params;
      const postgres_changes = (_b = (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.map((r2) => r2.filter)) !== null && _b !== void 0 ? _b : [];
      const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES$1.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES$1.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;
      const accessTokenPayload = {};
      const config2 = {
        broadcast,
        presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),
        postgres_changes,
        private: isPrivate
      };
      if (this.socket.accessTokenValue) {
        accessTokenPayload.access_token = this.socket.accessTokenValue;
      }
      this._onError((e2) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES$1.CHANNEL_ERROR, e2));
      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES$1.CLOSED));
      this.updateJoinPayload(Object.assign({ config: config2 }, accessTokenPayload));
      this.joinedOnce = true;
      this._rejoin(timeout);
      this.joinPush.receive("ok", async ({ postgres_changes: postgres_changes2 }) => {
        var _a3;
        if (!this.socket._isManualToken()) {
          this.socket.setAuth();
        }
        if (postgres_changes2 === void 0) {
          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES$1.SUBSCRIBED);
          return;
        } else {
          const clientPostgresBindings = this.bindings.postgres_changes;
          const bindingsLen = (_a3 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a3 !== void 0 ? _a3 : 0;
          const newPostgresBindings = [];
          for (let i2 = 0; i2 < bindingsLen; i2++) {
            const clientPostgresBinding = clientPostgresBindings[i2];
            const { filter: { event, schema, table, filter } } = clientPostgresBinding;
            const serverPostgresFilter = postgres_changes2 && postgres_changes2[i2];
            if (serverPostgresFilter && serverPostgresFilter.event === event && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {
              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));
            } else {
              this.unsubscribe();
              this.state = CHANNEL_STATES.errored;
              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES$1.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
              return;
            }
          }
          this.bindings.postgres_changes = newPostgresBindings;
          callback && callback(REALTIME_SUBSCRIBE_STATES$1.SUBSCRIBED);
          return;
        }
      }).receive("error", (error2) => {
        this.state = CHANNEL_STATES.errored;
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES$1.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error2).join(", ") || "error")));
        return;
      }).receive("timeout", () => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES$1.TIMED_OUT);
        return;
      });
    }
    return this;
  }
  /**
   * Returns the current presence state for this channel.
   *
   * The shape is a map keyed by presence key (for example a user id) where each entry contains the
   * tracked metadata for that user.
   */
  presenceState() {
    return this.presence.state;
  }
  /**
   * Sends the supplied payload to the presence tracker so other subscribers can see that this
   * client is online. Use `untrack` to stop broadcasting presence for the same key.
   */
  async track(payload, opts = {}) {
    return await this.send({
      type: "presence",
      event: "track",
      payload
    }, opts.timeout || this.timeout);
  }
  /**
   * Removes the current presence state for this client.
   */
  async untrack(opts = {}) {
    return await this.send({
      type: "presence",
      event: "untrack"
    }, opts);
  }
  on(type, filter, callback) {
    if (this.state === CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES$1.PRESENCE) {
      this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);
      this.unsubscribe().then(async () => await this.subscribe());
    }
    return this._on(type, filter, callback);
  }
  /**
   * Sends a broadcast message explicitly via REST API.
   *
   * This method always uses the REST API endpoint regardless of WebSocket connection state.
   * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.
   *
   * @param event The name of the broadcast event
   * @param payload Payload to be sent (required)
   * @param opts Options including timeout
   * @returns Promise resolving to object with success status, and error details if failed
   */
  async httpSend(event, payload, opts = {}) {
    var _a2;
    const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
    if (payload === void 0 || payload === null) {
      return Promise.reject("Payload is required for httpSend()");
    }
    const options = {
      method: "POST",
      headers: {
        Authorization: authorization,
        apikey: this.socket.apiKey ? this.socket.apiKey : "",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        messages: [
          {
            topic: this.subTopic,
            event,
            payload,
            private: this.private
          }
        ]
      })
    };
    const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a2 = opts.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout);
    if (response.status === 202) {
      return { success: true };
    }
    let errorMessage = response.statusText;
    try {
      const errorBody = await response.json();
      errorMessage = errorBody.error || errorBody.message || errorMessage;
    } catch (_b) {
    }
    return Promise.reject(new Error(errorMessage));
  }
  /**
   * Sends a message into the channel.
   *
   * @param args Arguments to send to channel
   * @param args.type The type of event to send
   * @param args.event The name of the event being sent
   * @param args.payload Payload to be sent
   * @param opts Options to be used during the send process
   */
  async send(args, opts = {}) {
    var _a2, _b;
    if (!this._canPush() && args.type === "broadcast") {
      console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
      const { event, payload: endpoint_payload } = args;
      const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
      const options = {
        method: "POST",
        headers: {
          Authorization: authorization,
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event,
              payload: endpoint_payload,
              private: this.private
            }
          ]
        })
      };
      try {
        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a2 = opts.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout);
        await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());
        return response.ok ? "ok" : "error";
      } catch (error2) {
        if (error2.name === "AbortError") {
          return "timed out";
        } else {
          return "error";
        }
      }
    } else {
      return new Promise((resolve) => {
        var _a3, _b2, _c;
        const push = this._push(args.type, args, opts.timeout || this.timeout);
        if (args.type === "broadcast" && !((_c = (_b2 = (_a3 = this.params) === null || _a3 === void 0 ? void 0 : _a3.config) === null || _b2 === void 0 ? void 0 : _b2.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
          resolve("ok");
        }
        push.receive("ok", () => resolve("ok"));
        push.receive("error", () => resolve("error"));
        push.receive("timeout", () => resolve("timed out"));
      });
    }
  }
  /**
   * Updates the payload that will be sent the next time the channel joins (reconnects).
   * Useful for rotating access tokens or updating config without re-creating the channel.
   */
  updateJoinPayload(payload) {
    this.joinPush.updatePayload(payload);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(timeout = this.timeout) {
    this.state = CHANNEL_STATES.leaving;
    const onClose = () => {
      this.socket.log("channel", `leave ${this.topic}`);
      this._trigger(CHANNEL_EVENTS.close, "leave", this._joinRef());
    };
    this.joinPush.destroy();
    let leavePush = null;
    return new Promise((resolve) => {
      leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);
      leavePush.receive("ok", () => {
        onClose();
        resolve("ok");
      }).receive("timeout", () => {
        onClose();
        resolve("timed out");
      }).receive("error", () => {
        resolve("error");
      });
      leavePush.send();
      if (!this._canPush()) {
        leavePush.trigger("ok", {});
      }
    }).finally(() => {
      leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();
    });
  }
  /**
   * Teardown the channel.
   *
   * Destroys and stops related timers.
   */
  teardown() {
    this.pushBuffer.forEach((push) => push.destroy());
    this.pushBuffer = [];
    this.rejoinTimer.reset();
    this.joinPush.destroy();
    this.state = CHANNEL_STATES.closed;
    this.bindings = {};
  }
  /** @internal */
  async _fetchWithTimeout(url, options, timeout) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));
    clearTimeout(id);
    return response;
  }
  /** @internal */
  _push(event, payload, timeout = this.timeout) {
    if (!this.joinedOnce) {
      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    }
    let pushEvent = new Push(this, event, payload, timeout);
    if (this._canPush()) {
      pushEvent.send();
    } else {
      this._addToPushBuffer(pushEvent);
    }
    return pushEvent;
  }
  /** @internal */
  _addToPushBuffer(pushEvent) {
    pushEvent.startTimeout();
    this.pushBuffer.push(pushEvent);
    if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {
      const removedPush = this.pushBuffer.shift();
      if (removedPush) {
        removedPush.destroy();
        this.socket.log("channel", `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);
      }
    }
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(_event, payload, _ref) {
    return payload;
  }
  /** @internal */
  _isMember(topic) {
    return this.topic === topic;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(type, payload, ref) {
    var _a2, _b;
    const typeLower = type.toLocaleLowerCase();
    const { close: close2, error: error2, leave, join } = CHANNEL_EVENTS;
    const events = [close2, error2, leave, join];
    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
      return;
    }
    let handledPayload = this._onMessage(typeLower, payload, ref);
    if (payload && !handledPayload) {
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    }
    if (["insert", "update", "delete"].includes(typeLower)) {
      (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.filter((bind) => {
        var _a3, _b2, _c;
        return ((_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event) === "*" || ((_c = (_b2 = bind.filter) === null || _b2 === void 0 ? void 0 : _b2.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
      }).map((bind) => bind.callback(handledPayload, ref));
    } else {
      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {
        var _a3, _b2, _c, _d, _e, _f;
        if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
          if ("id" in bind) {
            const bindId = bind.id;
            const bindEvent = (_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event;
            return bindId && ((_b2 = payload.ids) === null || _b2 === void 0 ? void 0 : _b2.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
          } else {
            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
            return bindEvent === "*" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
          }
        } else {
          return bind.type.toLocaleLowerCase() === typeLower;
        }
      }).map((bind) => {
        if (typeof handledPayload === "object" && "ids" in handledPayload) {
          const postgresChanges = handledPayload.data;
          const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;
          const enrichedPayload = {
            schema,
            table,
            commit_timestamp,
            eventType: type2,
            new: {},
            old: {},
            errors
          };
          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
        }
        bind.callback(handledPayload, ref);
      });
    }
  }
  /** @internal */
  _isClosed() {
    return this.state === CHANNEL_STATES.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === CHANNEL_STATES.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === CHANNEL_STATES.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === CHANNEL_STATES.leaving;
  }
  /** @internal */
  _replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  /** @internal */
  _on(type, filter, callback) {
    const typeLower = type.toLocaleLowerCase();
    const binding = {
      type: typeLower,
      filter,
      callback
    };
    if (this.bindings[typeLower]) {
      this.bindings[typeLower].push(binding);
    } else {
      this.bindings[typeLower] = [binding];
    }
    return this;
  }
  /** @internal */
  _off(type, filter) {
    const typeLower = type.toLocaleLowerCase();
    if (this.bindings[typeLower]) {
      this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {
        var _a2;
        return !(((_a2 = bind.type) === null || _a2 === void 0 ? void 0 : _a2.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
      });
    }
    return this;
  }
  /** @internal */
  static isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length) {
      return false;
    }
    for (const k2 in obj1) {
      if (obj1[k2] !== obj2[k2]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Compares two optional filter values for equality.
   * Treats undefined, null, and empty string as equivalent empty values.
   * @internal
   */
  static isFilterValueEqual(serverValue, clientValue) {
    const normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : void 0;
    const normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : void 0;
    return normalizedServer === normalizedClient;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout();
    if (this.socket.isConnected()) {
      this._rejoin();
    }
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(callback) {
    this._on(CHANNEL_EVENTS.close, {}, callback);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(callback) {
    this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(timeout = this.timeout) {
    if (this._isLeaving()) {
      return;
    }
    this.socket._leaveOpenTopic(this.topic);
    this.state = CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  /** @internal */
  _getPayloadRecords(payload) {
    const records = {
      new: {},
      old: {}
    };
    if (payload.type === "INSERT" || payload.type === "UPDATE") {
      records.new = convertChangeData(payload.columns, payload.record);
    }
    if (payload.type === "UPDATE" || payload.type === "DELETE") {
      records.old = convertChangeData(payload.columns, payload.old_record);
    }
    return records;
  }
};
const noop$1 = () => {
};
const CONNECTION_TIMEOUTS = {
  HEARTBEAT_INTERVAL: 25e3,
  RECONNECT_DELAY: 10,
  HEARTBEAT_TIMEOUT_FALLBACK: 100
};
const RECONNECT_INTERVALS = [1e3, 2e3, 5e3, 1e4];
const DEFAULT_RECONNECT_FALLBACK = 1e4;
const WORKER_SCRIPT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
let RealtimeClient$1 = class RealtimeClient {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.heartbeatCallback The optional function to handle heartbeat status.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.logLevel Sets the log level for Realtime
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   * @param options.worker Use Web Worker to set a side flow. Defaults to false.
   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
   * @example
   * ```ts
   * import RealtimeClient from '@supabase/realtime-js'
   *
   * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {
   *   params: { apikey: 'public-anon-key' },
   * })
   * client.connect()
   * ```
   */
  constructor(endPoint, options) {
    var _a2;
    this.accessTokenValue = null;
    this.apiKey = null;
    this._manuallySetToken = false;
    this.channels = new Array();
    this.endPoint = "";
    this.httpEndpoint = "";
    this.headers = {};
    this.params = {};
    this.timeout = DEFAULT_TIMEOUT;
    this.transport = null;
    this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
    this.heartbeatTimer = void 0;
    this.pendingHeartbeatRef = null;
    this.heartbeatCallback = noop$1;
    this.ref = 0;
    this.reconnectTimer = null;
    this.vsn = DEFAULT_VSN;
    this.logger = noop$1;
    this.conn = null;
    this.sendBuffer = [];
    this.serializer = new Serializer();
    this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    };
    this.accessToken = null;
    this._connectionState = "disconnected";
    this._wasManualDisconnect = false;
    this._authPromise = null;
    this._resolveFetch = (customFetch) => {
      if (customFetch) {
        return (...args) => customFetch(...args);
      }
      return (...args) => fetch(...args);
    };
    if (!((_a2 = options === null || options === void 0 ? void 0 : options.params) === null || _a2 === void 0 ? void 0 : _a2.apikey)) {
      throw new Error("API key is required to connect to Realtime");
    }
    this.apiKey = options.params.apikey;
    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
    this.httpEndpoint = httpEndpointURL(endPoint);
    this._initializeOptions(options);
    this._setupReconnectionTimer();
    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {
      return;
    }
    this._setConnectionState("connecting");
    if (this.accessToken && !this._authPromise) {
      this._setAuthSafely("connect");
    }
    if (this.transport) {
      this.conn = new this.transport(this.endpointURL());
    } else {
      try {
        this.conn = WebSocketFactory.createWebSocket(this.endpointURL());
      } catch (error2) {
        this._setConnectionState("disconnected");
        const errorMessage = error2.message;
        if (errorMessage.includes("Node.js")) {
          throw new Error(`${errorMessage}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`);
        }
        throw new Error(`WebSocket not available: ${errorMessage}`);
      }
    }
    this._setupConnectionHandlers();
  }
  /**
   * Returns the URL of the websocket.
   * @returns string The URL of the websocket.
   */
  endpointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: this.vsn }));
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(code, reason) {
    if (this.isDisconnecting()) {
      return;
    }
    this._setConnectionState("disconnecting", true);
    if (this.conn) {
      const fallbackTimer = setTimeout(() => {
        this._setConnectionState("disconnected");
      }, 100);
      this.conn.onclose = () => {
        clearTimeout(fallbackTimer);
        this._setConnectionState("disconnected");
      };
      if (typeof this.conn.close === "function") {
        if (code) {
          this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
        } else {
          this.conn.close();
        }
      }
      this._teardownConnection();
    } else {
      this._setConnectionState("disconnected");
    }
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  async removeChannel(channel) {
    const status = await channel.unsubscribe();
    if (this.channels.length === 0) {
      this.disconnect();
    }
    return status;
  }
  /**
   * Unsubscribes and removes all channels
   */
  async removeAllChannels() {
    const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));
    this.channels = [];
    this.disconnect();
    return values_1;
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(kind, msg, data) {
    this.logger(kind, msg, data);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return CONNECTION_STATE.Connecting;
      case SOCKET_STATES.open:
        return CONNECTION_STATE.Open;
      case SOCKET_STATES.closing:
        return CONNECTION_STATE.Closing;
      default:
        return CONNECTION_STATE.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === CONNECTION_STATE.Open;
  }
  /**
   * Returns `true` if the connection is currently connecting.
   */
  isConnecting() {
    return this._connectionState === "connecting";
  }
  /**
   * Returns `true` if the connection is currently disconnecting.
   */
  isDisconnecting() {
    return this._connectionState === "disconnecting";
  }
  /**
   * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.
   *
   * Topics are automatically prefixed with `realtime:` to match the Realtime service.
   * If a channel with the same topic already exists it will be returned instead of creating
   * a duplicate connection.
   */
  channel(topic, params = { config: {} }) {
    const realtimeTopic = `realtime:${topic}`;
    const exists = this.getChannels().find((c2) => c2.topic === realtimeTopic);
    if (!exists) {
      const chan = new RealtimeChannel$1(`realtime:${topic}`, params, this);
      this.channels.push(chan);
      return chan;
    } else {
      return exists;
    }
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(data) {
    const { topic, event, payload, ref } = data;
    const callback = () => {
      this.encode(data, (result) => {
        var _a2;
        (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.send(result);
      });
    };
    this.log("push", `${topic} ${event} (${ref})`, payload);
    if (this.isConnected()) {
      callback();
    } else {
      this.sendBuffer.push(callback);
    }
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * If param is null it will use the `accessToken` callback function or the token set on the client.
   *
   * On callback used, it will set the value of the token internal to the client.
   *
   * When a token is explicitly provided, it will be preserved across channel operations
   * (including removeChannel and resubscribe). The `accessToken` callback will not be
   * invoked until `setAuth()` is called without arguments.
   *
   * @param token A JWT string to override the token set on the client.
   *
   * @example
   * // Use a manual token (preserved across resubscribes, ignores accessToken callback)
   * client.realtime.setAuth('my-custom-jwt')
   *
   * // Switch back to using the accessToken callback
   * client.realtime.setAuth()
   */
  async setAuth(token = null) {
    this._authPromise = this._performAuth(token);
    try {
      await this._authPromise;
    } finally {
      this._authPromise = null;
    }
  }
  /**
   * Returns true if the current access token was explicitly set via setAuth(token),
   * false if it was obtained via the accessToken callback.
   * @internal
   */
  _isManualToken() {
    return this._manuallySetToken;
  }
  /**
   * Sends a heartbeat message if the socket is connected.
   */
  async sendHeartbeat() {
    var _a2;
    if (!this.isConnected()) {
      try {
        this.heartbeatCallback("disconnected");
      } catch (e2) {
        this.log("error", "error in heartbeat callback", e2);
      }
      return;
    }
    if (this.pendingHeartbeatRef) {
      this.pendingHeartbeatRef = null;
      this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
      try {
        this.heartbeatCallback("timeout");
      } catch (e2) {
        this.log("error", "error in heartbeat callback", e2);
      }
      this._wasManualDisconnect = false;
      (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.close(WS_CLOSE_NORMAL, "heartbeat timeout");
      setTimeout(() => {
        var _a3;
        if (!this.isConnected()) {
          (_a3 = this.reconnectTimer) === null || _a3 === void 0 ? void 0 : _a3.scheduleTimeout();
        }
      }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);
      return;
    }
    this.pendingHeartbeatRef = this._makeRef();
    this.push({
      topic: "phoenix",
      event: "heartbeat",
      payload: {},
      ref: this.pendingHeartbeatRef
    });
    try {
      this.heartbeatCallback("sent");
    } catch (e2) {
      this.log("error", "error in heartbeat callback", e2);
    }
    this._setAuthSafely("heartbeat");
  }
  /**
   * Sets a callback that receives lifecycle events for internal heartbeat messages.
   * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).
   */
  onHeartbeat(callback) {
    this.heartbeatCallback = callback;
  }
  /**
   * Flushes send buffer
   */
  flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach((callback) => callback());
      this.sendBuffer = [];
    }
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(topic) {
    let dupChannel = this.channels.find((c2) => c2.topic === topic && (c2._isJoined() || c2._isJoining()));
    if (dupChannel) {
      this.log("transport", `leaving duplicate topic "${topic}"`);
      dupChannel.unsubscribe();
    }
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(channel) {
    this.channels = this.channels.filter((c2) => c2.topic !== channel.topic);
  }
  /** @internal */
  _onConnMessage(rawMessage) {
    this.decode(rawMessage.data, (msg) => {
      if (msg.topic === "phoenix" && msg.event === "phx_reply") {
        try {
          this.heartbeatCallback(msg.payload.status === "ok" ? "ok" : "error");
        } catch (e2) {
          this.log("error", "error in heartbeat callback", e2);
        }
      }
      if (msg.ref && msg.ref === this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
      }
      const { topic, event, payload, ref } = msg;
      const refString = ref ? `(${ref})` : "";
      const status = payload.status || "";
      this.log("receive", `${status} ${topic} ${event} ${refString}`.trim(), payload);
      this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));
      this._triggerStateCallbacks("message", msg);
    });
  }
  /**
   * Clear specific timer
   * @internal
   */
  _clearTimer(timer) {
    var _a2;
    if (timer === "heartbeat" && this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = void 0;
    } else if (timer === "reconnect") {
      (_a2 = this.reconnectTimer) === null || _a2 === void 0 ? void 0 : _a2.reset();
    }
  }
  /**
   * Clear all timers
   * @internal
   */
  _clearAllTimers() {
    this._clearTimer("heartbeat");
    this._clearTimer("reconnect");
  }
  /**
   * Setup connection handlers for WebSocket events
   * @internal
   */
  _setupConnectionHandlers() {
    if (!this.conn)
      return;
    if ("binaryType" in this.conn) {
      this.conn.binaryType = "arraybuffer";
    }
    this.conn.onopen = () => this._onConnOpen();
    this.conn.onerror = (error2) => this._onConnError(error2);
    this.conn.onmessage = (event) => this._onConnMessage(event);
    this.conn.onclose = (event) => this._onConnClose(event);
  }
  /**
   * Teardown connection and cleanup resources
   * @internal
   */
  _teardownConnection() {
    if (this.conn) {
      if (this.conn.readyState === SOCKET_STATES.open || this.conn.readyState === SOCKET_STATES.connecting) {
        try {
          this.conn.close();
        } catch (e2) {
          this.log("error", "Error closing connection", e2);
        }
      }
      this.conn.onopen = null;
      this.conn.onerror = null;
      this.conn.onmessage = null;
      this.conn.onclose = null;
      this.conn = null;
    }
    this._clearAllTimers();
    this.channels.forEach((channel) => channel.teardown());
  }
  /** @internal */
  _onConnOpen() {
    this._setConnectionState("connected");
    this.log("transport", `connected to ${this.endpointURL()}`);
    const authPromise = this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());
    authPromise.then(() => {
      this.flushSendBuffer();
    }).catch((e2) => {
      this.log("error", "error waiting for auth on connect", e2);
      this.flushSendBuffer();
    });
    this._clearTimer("reconnect");
    if (!this.worker) {
      this._startHeartbeat();
    } else {
      if (!this.workerRef) {
        this._startWorkerHeartbeat();
      }
    }
    this._triggerStateCallbacks("open");
  }
  /** @internal */
  _startHeartbeat() {
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
  }
  /** @internal */
  _startWorkerHeartbeat() {
    if (this.workerUrl) {
      this.log("worker", `starting worker for from ${this.workerUrl}`);
    } else {
      this.log("worker", `starting default worker`);
    }
    const objectUrl = this._workerObjectUrl(this.workerUrl);
    this.workerRef = new Worker(objectUrl);
    this.workerRef.onerror = (error2) => {
      this.log("worker", "worker error", error2.message);
      this.workerRef.terminate();
    };
    this.workerRef.onmessage = (event) => {
      if (event.data.event === "keepAlive") {
        this.sendHeartbeat();
      }
    };
    this.workerRef.postMessage({
      event: "start",
      interval: this.heartbeatIntervalMs
    });
  }
  /** @internal */
  _onConnClose(event) {
    var _a2;
    this._setConnectionState("disconnected");
    this.log("transport", "close", event);
    this._triggerChanError();
    this._clearTimer("heartbeat");
    if (!this._wasManualDisconnect) {
      (_a2 = this.reconnectTimer) === null || _a2 === void 0 ? void 0 : _a2.scheduleTimeout();
    }
    this._triggerStateCallbacks("close", event);
  }
  /** @internal */
  _onConnError(error2) {
    this._setConnectionState("disconnected");
    this.log("transport", `${error2}`);
    this._triggerChanError();
    this._triggerStateCallbacks("error", error2);
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));
  }
  /** @internal */
  _appendParams(url, params) {
    if (Object.keys(params).length === 0) {
      return url;
    }
    const prefix = url.match(/\?/) ? "&" : "?";
    const query = new URLSearchParams(params);
    return `${url}${prefix}${query}`;
  }
  _workerObjectUrl(url) {
    let result_url;
    if (url) {
      result_url = url;
    } else {
      const blob = new Blob([WORKER_SCRIPT], { type: "application/javascript" });
      result_url = URL.createObjectURL(blob);
    }
    return result_url;
  }
  /**
   * Set connection state with proper state management
   * @internal
   */
  _setConnectionState(state, manual = false) {
    this._connectionState = state;
    if (state === "connecting") {
      this._wasManualDisconnect = false;
    } else if (state === "disconnecting") {
      this._wasManualDisconnect = manual;
    }
  }
  /**
   * Perform the actual auth operation
   * @internal
   */
  async _performAuth(token = null) {
    let tokenToSend;
    let isManualToken = false;
    if (token) {
      tokenToSend = token;
      isManualToken = true;
    } else if (this.accessToken) {
      try {
        tokenToSend = await this.accessToken();
      } catch (e2) {
        this.log("error", "Error fetching access token from callback", e2);
        tokenToSend = this.accessTokenValue;
      }
    } else {
      tokenToSend = this.accessTokenValue;
    }
    if (isManualToken) {
      this._manuallySetToken = true;
    } else if (this.accessToken) {
      this._manuallySetToken = false;
    }
    if (this.accessTokenValue != tokenToSend) {
      this.accessTokenValue = tokenToSend;
      this.channels.forEach((channel) => {
        const payload = {
          access_token: tokenToSend,
          version: DEFAULT_VERSION
        };
        tokenToSend && channel.updateJoinPayload(payload);
        if (channel.joinedOnce && channel._isJoined()) {
          channel._push(CHANNEL_EVENTS.access_token, {
            access_token: tokenToSend
          });
        }
      });
    }
  }
  /**
   * Wait for any in-flight auth operations to complete
   * @internal
   */
  async _waitForAuthIfNeeded() {
    if (this._authPromise) {
      await this._authPromise;
    }
  }
  /**
   * Safely call setAuth with standardized error handling
   * @internal
   */
  _setAuthSafely(context = "general") {
    if (!this._isManualToken()) {
      this.setAuth().catch((e2) => {
        this.log("error", `Error setting auth in ${context}`, e2);
      });
    }
  }
  /**
   * Trigger state change callbacks with proper error handling
   * @internal
   */
  _triggerStateCallbacks(event, data) {
    try {
      this.stateChangeCallbacks[event].forEach((callback) => {
        try {
          callback(data);
        } catch (e2) {
          this.log("error", `error in ${event} callback`, e2);
        }
      });
    } catch (e2) {
      this.log("error", `error triggering ${event} callbacks`, e2);
    }
  }
  /**
   * Setup reconnection timer with proper configuration
   * @internal
   */
  _setupReconnectionTimer() {
    this.reconnectTimer = new Timer2(async () => {
      setTimeout(async () => {
        await this._waitForAuthIfNeeded();
        if (!this.isConnected()) {
          this.connect();
        }
      }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);
    }, this.reconnectAfterMs);
  }
  /**
   * Initialize client options with defaults
   * @internal
   */
  _initializeOptions(options) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    this.transport = (_a2 = options === null || options === void 0 ? void 0 : options.transport) !== null && _a2 !== void 0 ? _a2 : null;
    this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : DEFAULT_TIMEOUT;
    this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
    this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;
    this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;
    this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop$1;
    this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : DEFAULT_VSN;
    if (options === null || options === void 0 ? void 0 : options.params)
      this.params = options.params;
    if (options === null || options === void 0 ? void 0 : options.logger)
      this.logger = options.logger;
    if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {
      this.logLevel = options.logLevel || options.log_level;
      this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });
    }
    this.reconnectAfterMs = (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : ((tries) => {
      return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;
    });
    switch (this.vsn) {
      case VSN_1_0_0:
        this.encode = (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : ((payload, callback) => {
          return callback(JSON.stringify(payload));
        });
        this.decode = (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : ((payload, callback) => {
          return callback(JSON.parse(payload));
        });
        break;
      case VSN_2_0_0:
        this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);
        this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);
        break;
      default:
        throw new Error(`Unsupported serializer version: ${this.vsn}`);
    }
    if (this.worker) {
      if (typeof window !== "undefined" && !window.Worker) {
        throw new Error("Web Worker is not supported");
      }
      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
    }
  }
};
const module$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  REALTIME_CHANNEL_STATES: REALTIME_CHANNEL_STATES$1,
  get REALTIME_LISTEN_TYPES() {
    return REALTIME_LISTEN_TYPES$1;
  },
  get REALTIME_POSTGRES_CHANGES_LISTEN_EVENT() {
    return REALTIME_POSTGRES_CHANGES_LISTEN_EVENT$1;
  },
  get REALTIME_PRESENCE_LISTEN_EVENTS() {
    return REALTIME_PRESENCE_LISTEN_EVENTS$1;
  },
  get REALTIME_SUBSCRIBE_STATES() {
    return REALTIME_SUBSCRIBE_STATES$1;
  },
  RealtimeChannel: RealtimeChannel$1,
  RealtimeClient: RealtimeClient$1,
  RealtimePresence: RealtimePresence$1,
  WebSocketFactory
}, Symbol.toStringTag, { value: "Module" }));
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(module$3);
class StorageError extends Error {
  constructor(message) {
    super(message);
    this.__isStorageError = true;
    this.name = "StorageError";
  }
}
function isStorageError(error2) {
  return typeof error2 === "object" && error2 !== null && "__isStorageError" in error2;
}
class StorageApiError extends StorageError {
  constructor(message, status, statusCode) {
    super(message);
    this.name = "StorageApiError";
    this.status = status;
    this.statusCode = statusCode;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode
    };
  }
}
class StorageUnknownError extends StorageError {
  constructor(message, originalError) {
    super(message);
    this.name = "StorageUnknownError";
    this.originalError = originalError;
  }
}
const resolveFetch$2 = (customFetch) => {
  if (customFetch) {
    return (...args) => customFetch(...args);
  }
  return (...args) => fetch(...args);
};
const resolveResponse$1 = () => {
  return Response;
};
const recursiveToCamel = (item) => {
  if (Array.isArray(item)) {
    return item.map((el) => recursiveToCamel(el));
  } else if (typeof item === "function" || item !== Object(item)) {
    return item;
  }
  const result = {};
  Object.entries(item).forEach(([key, value]) => {
    const newKey = key.replace(/([-_][a-z])/gi, (c2) => c2.toUpperCase().replace(/[-_]/g, ""));
    result[newKey] = recursiveToCamel(value);
  });
  return result;
};
const isPlainObject$2 = (value) => {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
const isValidBucketName = (bucketName) => {
  if (!bucketName || typeof bucketName !== "string") {
    return false;
  }
  if (bucketName.length === 0 || bucketName.length > 100) {
    return false;
  }
  if (bucketName.trim() !== bucketName) {
    return false;
  }
  if (bucketName.includes("/") || bucketName.includes("\\")) {
    return false;
  }
  const bucketNameRegex = /^[\w!.\*'() &$@=;:+,?-]+$/;
  return bucketNameRegex.test(bucketName);
};
const _getErrorMessage$2 = (err) => {
  var _a2;
  return err.msg || err.message || err.error_description || (typeof err.error === "string" ? err.error : (_a2 = err.error) === null || _a2 === void 0 ? void 0 : _a2.message) || JSON.stringify(err);
};
const handleError$2 = (error2, reject, options) => __awaiter(void 0, void 0, void 0, function* () {
  const Res = yield resolveResponse$1();
  if (error2 instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
    error2.json().then((err) => {
      const status = error2.status || 500;
      const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || status + "";
      reject(new StorageApiError(_getErrorMessage$2(err), status, statusCode));
    }).catch((err) => {
      reject(new StorageUnknownError(_getErrorMessage$2(err), err));
    });
  } else {
    reject(new StorageUnknownError(_getErrorMessage$2(error2), error2));
  }
});
const _getRequestParams$2 = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET" || !body) {
    return params;
  }
  if (isPlainObject$2(body)) {
    params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
    params.body = JSON.stringify(body);
  } else {
    params.body = body;
  }
  if (options === null || options === void 0 ? void 0 : options.duplex) {
    params.duplex = options.duplex;
  }
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest$2(fetcher, method, url, options, parameters, body) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams$2(method, options, parameters, body)).then((result) => {
        if (!result.ok)
          throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson)
          return result;
        return result.json();
      }).then((data) => resolve(data)).catch((error2) => handleError$2(error2, reject, options));
    });
  });
}
function get(fetcher, url, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "GET", url, options, parameters);
  });
}
function post$1(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "POST", url, options, parameters, body);
  });
}
function put(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "PUT", url, options, parameters, body);
  });
}
function head(fetcher, url, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "HEAD", url, Object.assign(Object.assign({}, options), { noResolveJson: true }), parameters);
  });
}
function remove(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "DELETE", url, options, parameters, body);
  });
}
class StreamDownloadBuilder {
  constructor(downloadFn, shouldThrowOnError) {
    this.downloadFn = downloadFn;
    this.shouldThrowOnError = shouldThrowOnError;
  }
  then(onfulfilled, onrejected) {
    return this.execute().then(onfulfilled, onrejected);
  }
  execute() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const result = yield this.downloadFn();
        return {
          data: result.body,
          error: null
        };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
var _a$1;
class BlobDownloadBuilder {
  constructor(downloadFn, shouldThrowOnError) {
    this.downloadFn = downloadFn;
    this.shouldThrowOnError = shouldThrowOnError;
    this[_a$1] = "BlobDownloadBuilder";
    this.promise = null;
  }
  asStream() {
    return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);
  }
  then(onfulfilled, onrejected) {
    return this.getPromise().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.getPromise().catch(onrejected);
  }
  finally(onfinally) {
    return this.getPromise().finally(onfinally);
  }
  getPromise() {
    if (!this.promise) {
      this.promise = this.execute();
    }
    return this.promise;
  }
  execute() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const result = yield this.downloadFn();
        return {
          data: yield result.blob(),
          error: null
        };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
_a$1 = Symbol.toStringTag;
const DEFAULT_SEARCH_OPTIONS = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: "name",
    order: "asc"
  }
};
const DEFAULT_FILE_OPTIONS = {
  cacheControl: "3600",
  contentType: "text/plain;charset=UTF-8",
  upsert: false
};
class StorageFileApi {
  constructor(url, headers = {}, bucketId, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url;
    this.headers = headers;
    this.bucketId = bucketId;
    this.fetch = resolveFetch$2(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them.
   *
   * @category File Buckets
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadOrUpdate(method, path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let body;
        const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
        let headers = Object.assign(Object.assign({}, this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
        const metadata = options.metadata;
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body = new FormData();
          body.append("cacheControl", options.cacheControl);
          if (metadata) {
            body.append("metadata", this.encodeMetadata(metadata));
          }
          body.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body = fileBody;
          if (!body.has("cacheControl")) {
            body.append("cacheControl", options.cacheControl);
          }
          if (metadata && !body.has("metadata")) {
            body.append("metadata", this.encodeMetadata(metadata));
          }
        } else {
          body = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
          if (metadata) {
            headers["x-metadata"] = this.toBase64(this.encodeMetadata(metadata));
          }
          const isStream = typeof ReadableStream !== "undefined" && body instanceof ReadableStream || body && typeof body === "object" && "pipe" in body && typeof body.pipe === "function";
          if (isStream && !options.duplex) {
            options.duplex = "half";
          }
        }
        if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {
          headers = Object.assign(Object.assign({}, headers), fileOptions.headers);
        }
        const cleanPath = this._removeEmptyFolders(path);
        const _path = this._getFinalPath(cleanPath);
        const data = yield (method == "PUT" ? put : post$1)(this.fetch, `${this.url}/object/${_path}`, body, Object.assign({ headers }, (options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {}));
        return {
          data: { path: cleanPath, id: data.Id, fullPath: data.Key },
          error: null
        };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Uploads a file to an existing bucket.
   *
   * @category File Buckets
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   * @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.
   * @returns Promise with response containing file path, id, and fullPath or error
   *
   * @example Upload file
   * ```js
   * const avatarFile = event.target.files[0]
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .upload('public/avatar1.png', avatarFile, {
   *     cacheControl: '3600',
   *     upsert: false
   *   })
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "path": "public/avatar1.png",
   *     "fullPath": "avatars/public/avatar1.png"
   *   },
   *   "error": null
   * }
   * ```
   *
   * @example Upload file using `ArrayBuffer` from base64 file data
   * ```js
   * import { decode } from 'base64-arraybuffer'
   *
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .upload('public/avatar1.png', decode('base64FileData'), {
   *     contentType: 'image/png'
   *   })
   * ```
   */
  upload(path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
    });
  }
  /**
   * Upload a file with a token generated from `createSignedUploadUrl`.
   *
   * @category File Buckets
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param token The token generated from `createSignedUploadUrl`
   * @param fileBody The body of the file to be stored in the bucket.
   * @param fileOptions HTTP headers (cacheControl, contentType, etc.).
   * **Note:** The `upsert` option has no effect here. To enable upsert behavior,
   * pass `{ upsert: true }` when calling `createSignedUploadUrl()` instead.
   * @returns Promise with response containing file path and fullPath or error
   *
   * @example Upload to a signed URL
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "path": "folder/cat.jpg",
   *     "fullPath": "avatars/folder/cat.jpg"
   *   },
   *   "error": null
   * }
   * ```
   */
  uploadToSignedUrl(path, token, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      const cleanPath = this._removeEmptyFolders(path);
      const _path = this._getFinalPath(cleanPath);
      const url = new URL(this.url + `/object/upload/sign/${_path}`);
      url.searchParams.set("token", token);
      try {
        let body;
        const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);
        const headers = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(options.upsert) });
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body = new FormData();
          body.append("cacheControl", options.cacheControl);
          body.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body = fileBody;
          body.append("cacheControl", options.cacheControl);
        } else {
          body = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
        }
        const data = yield put(this.fetch, url.toString(), body, { headers });
        return {
          data: { path: cleanPath, fullPath: data.Key },
          error: null
        };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Creates a signed upload URL.
   * Signed upload URLs can be used to upload files to the bucket without further authentication.
   * They are valid for 2 hours.
   *
   * @category File Buckets
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
   * @returns Promise with response containing signed upload URL, token, and path or error
   *
   * @example Create Signed Upload URL
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .createSignedUploadUrl('folder/cat.jpg')
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "signedUrl": "https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>",
   *     "path": "folder/cat.jpg",
   *     "token": "<TOKEN>"
   *   },
   *   "error": null
   * }
   * ```
   */
  createSignedUploadUrl(path, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        const headers = Object.assign({}, this.headers);
        if (options === null || options === void 0 ? void 0 : options.upsert) {
          headers["x-upsert"] = "true";
        }
        const data = yield post$1(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers });
        const url = new URL(this.url + data.url);
        const token = url.searchParams.get("token");
        if (!token) {
          throw new StorageError("No token returned by API");
        }
        return { data: { signedUrl: url.toString(), path, token }, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Replaces an existing file at the specified path with a new one.
   *
   * @category File Buckets
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
   * @param fileBody The body of the file to be stored in the bucket.
   * @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.
   * @returns Promise with response containing file path, id, and fullPath or error
   *
   * @example Update file
   * ```js
   * const avatarFile = event.target.files[0]
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .update('public/avatar1.png', avatarFile, {
   *     cacheControl: '3600',
   *     upsert: true
   *   })
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "path": "public/avatar1.png",
   *     "fullPath": "avatars/public/avatar1.png"
   *   },
   *   "error": null
   * }
   * ```
   *
   * @example Update file using `ArrayBuffer` from base64 file data
   * ```js
   * import {decode} from 'base64-arraybuffer'
   *
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .update('public/avatar1.png', decode('base64FileData'), {
   *     contentType: 'image/png'
   *   })
   * ```
   */
  update(path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
    });
  }
  /**
   * Moves an existing file to a new path in the same bucket.
   *
   * @category File Buckets
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
   * @param options The destination options.
   * @returns Promise with response containing success message or error
   *
   * @example Move file
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .move('public/avatar1.png', 'private/avatar2.png')
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "message": "Successfully moved"
   *   },
   *   "error": null
   * }
   * ```
   */
  move(fromPath, toPath, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/object/move`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Copies an existing file to a new path in the same bucket.
   *
   * @category File Buckets
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
   * @param options The destination options.
   * @returns Promise with response containing copied file path or error
   *
   * @example Copy file
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .copy('public/avatar1.png', 'private/avatar2.png')
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "path": "avatars/private/avatar2.png"
   *   },
   *   "error": null
   * }
   * ```
   */
  copy(fromPath, toPath, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/object/copy`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data: { path: data.Key }, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
   *
   * @category File Buckets
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   * @returns Promise with response containing signed URL or error
   *
   * @example Create Signed URL
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .createSignedUrl('folder/avatar1.png', 60)
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>"
   *   },
   *   "error": null
   * }
   * ```
   *
   * @example Create a signed URL for an asset with transformations
   * ```js
   * const { data } = await supabase
   *   .storage
   *   .from('avatars')
   *   .createSignedUrl('folder/avatar1.png', 60, {
   *     transform: {
   *       width: 100,
   *       height: 100,
   *     }
   *   })
   * ```
   *
   * @example Create a signed URL which triggers the download of the asset
   * ```js
   * const { data } = await supabase
   *   .storage
   *   .from('avatars')
   *   .createSignedUrl('folder/avatar1.png', 60, {
   *     download: true,
   *   })
   * ```
   */
  createSignedUrl(path, expiresIn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        let data = yield post$1(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, (options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {}), { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
        data = { signedUrl };
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
   *
   * @category File Buckets
   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @returns Promise with response containing array of objects with signedUrl, path, and error or error
   *
   * @example Create Signed URLs
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": [
   *     {
   *       "error": null,
   *       "path": "folder/avatar1.png",
   *       "signedURL": "/object/sign/avatars/folder/avatar1.png?token=<TOKEN>",
   *       "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>"
   *     },
   *     {
   *       "error": null,
   *       "path": "folder/avatar2.png",
   *       "signedURL": "/object/sign/avatars/folder/avatar2.png?token=<TOKEN>",
   *       "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>"
   *     }
   *   ],
   *   "error": null
   * }
   * ```
   */
  createSignedUrls(paths, expiresIn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        return {
          data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null })),
          error: null
        };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
   *
   * @category File Buckets
   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
   * @param options.transform Transform the asset before serving it to the client.
   * @returns BlobDownloadBuilder instance for downloading the file
   *
   * @example Download file
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .download('folder/avatar1.png')
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": <BLOB>,
   *   "error": null
   * }
   * ```
   *
   * @example Download file with transformations
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .download('folder/avatar1.png', {
   *     transform: {
   *       width: 100,
   *       height: 100,
   *       quality: 80
   *     }
   *   })
   * ```
   */
  download(path, options) {
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
    const renderPath = wantsTransformation ? "render/image/authenticated" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    const queryString = transformationQuery ? `?${transformationQuery}` : "";
    const _path = this._getFinalPath(path);
    const downloadFn = () => get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
      headers: this.headers,
      noResolveJson: true
    });
    return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);
  }
  /**
   * Retrieves the details of an existing file.
   *
   * @category File Buckets
   * @param path The file path, including the file name. For example `folder/image.png`.
   * @returns Promise with response containing file metadata or error
   *
   * @example Get file info
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .info('folder/avatar1.png')
   * ```
   */
  info(path) {
    return __awaiter(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        const data = yield get(this.fetch, `${this.url}/object/info/${_path}`, {
          headers: this.headers
        });
        return { data: recursiveToCamel(data), error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Checks the existence of a file.
   *
   * @category File Buckets
   * @param path The file path, including the file name. For example `folder/image.png`.
   * @returns Promise with response containing boolean indicating file existence or error
   *
   * @example Check file existence
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .exists('folder/avatar1.png')
   * ```
   */
  exists(path) {
    return __awaiter(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        yield head(this.fetch, `${this.url}/object/${_path}`, {
          headers: this.headers
        });
        return { data: true, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2) && error2 instanceof StorageUnknownError) {
          const originalError = error2.originalError;
          if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {
            return { data: false, error: error2 };
          }
        }
        throw error2;
      }
    });
  }
  /**
   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
   *
   * @category File Buckets
   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   * @returns Object with public URL
   *
   * @example Returns the URL for an asset in a public bucket
   * ```js
   * const { data } = supabase
   *   .storage
   *   .from('public-bucket')
   *   .getPublicUrl('folder/avatar1.png')
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "publicUrl": "https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png"
   *   }
   * }
   * ```
   *
   * @example Returns the URL for an asset in a public bucket with transformations
   * ```js
   * const { data } = supabase
   *   .storage
   *   .from('public-bucket')
   *   .getPublicUrl('folder/avatar1.png', {
   *     transform: {
   *       width: 100,
   *       height: 100,
   *     }
   *   })
   * ```
   *
   * @example Returns the URL which triggers the download of an asset in a public bucket
   * ```js
   * const { data } = supabase
   *   .storage
   *   .from('public-bucket')
   *   .getPublicUrl('folder/avatar1.png', {
   *     download: true,
   *   })
   * ```
   */
  getPublicUrl(path, options) {
    const _path = this._getFinalPath(path);
    const _queryString = [];
    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
    if (downloadQueryParam !== "") {
      _queryString.push(downloadQueryParam);
    }
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
    const renderPath = wantsTransformation ? "render/image" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    if (transformationQuery !== "") {
      _queryString.push(transformationQuery);
    }
    let queryString = _queryString.join("&");
    if (queryString !== "") {
      queryString = `?${queryString}`;
    }
    return {
      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) }
    };
  }
  /**
   * Deletes files within the same bucket
   *
   * @category File Buckets
   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
   * @returns Promise with response containing array of deleted file objects or error
   *
   * @example Delete file
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .remove(['folder/avatar1.png'])
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": [],
   *   "error": null
   * }
   * ```
   */
  remove(paths) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Get file metadata
   * @param id the file id to retrieve metadata
   */
  // async getMetadata(
  //   id: string
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Update file metadata
   * @param id the file id to update metadata
   * @param meta the new file metadata
   */
  // async updateMetadata(
  //   id: string,
  //   meta: Metadata
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await post(
  //       this.fetch,
  //       `${this.url}/metadata/${id}`,
  //       { ...meta },
  //       { headers: this.headers }
  //     )
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Lists all the files and folders within a path of the bucket.
   *
   * @category File Buckets
   * @param path The folder path.
   * @param options Search options including limit (defaults to 100), offset, sortBy, and search
   * @param parameters Optional fetch parameters including signal for cancellation
   * @returns Promise with response containing array of files or error
   *
   * @example List files in a bucket
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .list('folder', {
   *     limit: 100,
   *     offset: 0,
   *     sortBy: { column: 'name', order: 'asc' },
   *   })
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": [
   *     {
   *       "name": "avatar1.png",
   *       "id": "e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2",
   *       "updated_at": "2024-05-22T23:06:05.580Z",
   *       "created_at": "2024-05-22T23:04:34.443Z",
   *       "last_accessed_at": "2024-05-22T23:04:34.443Z",
   *       "metadata": {
   *         "eTag": "\"c5e8c553235d9af30ef4f6e280790b92\"",
   *         "size": 32175,
   *         "mimetype": "image/png",
   *         "cacheControl": "max-age=3600",
   *         "lastModified": "2024-05-22T23:06:05.574Z",
   *         "contentLength": 32175,
   *         "httpStatusCode": 200
   *       }
   *     }
   *   ],
   *   "error": null
   * }
   * ```
   *
   * @example Search files in a bucket
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .from('avatars')
   *   .list('folder', {
   *     limit: 100,
   *     offset: 0,
   *     sortBy: { column: 'name', order: 'asc' },
   *     search: 'jon'
   *   })
   * ```
   */
  list(path, options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || "" });
        const data = yield post$1(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * @experimental this method signature might change in the future
   *
   * @category File Buckets
   * @param options search options
   * @param parameters
   */
  listV2(options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const body = Object.assign({}, options);
        const data = yield post$1(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, body, { headers: this.headers }, parameters);
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  encodeMetadata(metadata) {
    return JSON.stringify(metadata);
  }
  toBase64(data) {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(data).toString("base64");
    }
    return btoa(data);
  }
  _getFinalPath(path) {
    return `${this.bucketId}/${path.replace(/^\/+/, "")}`;
  }
  _removeEmptyFolders(path) {
    return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(transform2) {
    const params = [];
    if (transform2.width) {
      params.push(`width=${transform2.width}`);
    }
    if (transform2.height) {
      params.push(`height=${transform2.height}`);
    }
    if (transform2.resize) {
      params.push(`resize=${transform2.resize}`);
    }
    if (transform2.format) {
      params.push(`format=${transform2.format}`);
    }
    if (transform2.quality) {
      params.push(`quality=${transform2.quality}`);
    }
    return params.join("&");
  }
}
const version$3 = "2.87.1";
const DEFAULT_HEADERS$2 = {
  "X-Client-Info": `storage-js/${version$3}`
};
class StorageBucketApi {
  constructor(url, headers = {}, fetch2, opts) {
    this.shouldThrowOnError = false;
    const baseUrl = new URL(url);
    if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {
      const isSupabaseHost = /supabase\.(co|in|red)$/.test(baseUrl.hostname);
      if (isSupabaseHost && !baseUrl.hostname.includes("storage.supabase.")) {
        baseUrl.hostname = baseUrl.hostname.replace("supabase.", "storage.supabase.");
      }
    }
    this.url = baseUrl.href.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$2), headers);
    this.fetch = resolveFetch$2(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them.
   *
   * @category File Buckets
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   *
   * @category File Buckets
   * @param options Query parameters for listing buckets
   * @param options.limit Maximum number of buckets to return
   * @param options.offset Number of buckets to skip
   * @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')
   * @param options.sortOrder Sort order ('asc' or 'desc')
   * @param options.search Search term to filter bucket names
   * @returns Promise with response containing array of buckets or error
   *
   * @example List buckets
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .listBuckets()
   * ```
   *
   * @example List buckets with options
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .listBuckets({
   *     limit: 10,
   *     offset: 0,
   *     sortColumn: 'created_at',
   *     sortOrder: 'desc',
   *     search: 'prod'
   *   })
   * ```
   */
  listBuckets(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const queryString = this.listBucketOptionsToQueryString(options);
        const data = yield get(this.fetch, `${this.url}/bucket${queryString}`, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Retrieves the details of an existing Storage bucket.
   *
   * @category File Buckets
   * @param id The unique identifier of the bucket you would like to retrieve.
   * @returns Promise with response containing bucket details or error
   *
   * @example Get bucket
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .getBucket('avatars')
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "id": "avatars",
   *     "name": "avatars",
   *     "owner": "",
   *     "public": false,
   *     "file_size_limit": 1024,
   *     "allowed_mime_types": [
   *       "image/png"
   *     ],
   *     "created_at": "2024-05-22T22:26:05.100Z",
   *     "updated_at": "2024-05-22T22:26:05.100Z"
   *   },
   *   "error": null
   * }
   * ```
   */
  getBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Creates a new Storage bucket
   *
   * @category File Buckets
   * @param id A unique identifier for the bucket you are creating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.
   *   - default bucket type is `STANDARD`
   * @returns Promise with response containing newly created bucket name or error
   *
   * @example Create bucket
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .createBucket('avatars', {
   *     public: false,
   *     allowedMimeTypes: ['image/png'],
   *     fileSizeLimit: 1024
   *   })
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "name": "avatars"
   *   },
   *   "error": null
   * }
   * ```
   */
  createBucket(id_1) {
    return __awaiter(this, arguments, void 0, function* (id, options = {
      public: false
    }) {
      try {
        const data = yield post$1(this.fetch, `${this.url}/bucket`, {
          id,
          name: id,
          type: options.type,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Updates a Storage bucket
   *
   * @category File Buckets
   * @param id A unique identifier for the bucket you are updating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @returns Promise with response containing success message or error
   *
   * @example Update bucket
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .updateBucket('avatars', {
   *     public: false,
   *     allowedMimeTypes: ['image/png'],
   *     fileSizeLimit: 1024
   *   })
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "message": "Successfully updated"
   *   },
   *   "error": null
   * }
   * ```
   */
  updateBucket(id, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield put(this.fetch, `${this.url}/bucket/${id}`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Removes all objects inside a single bucket.
   *
   * @category File Buckets
   * @param id The unique identifier of the bucket you would like to empty.
   * @returns Promise with success message or error
   *
   * @example Empty bucket
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .emptyBucket('avatars')
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "message": "Successfully emptied"
   *   },
   *   "error": null
   * }
   * ```
   */
  emptyBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
   * You must first `empty()` the bucket.
   *
   * @category File Buckets
   * @param id The unique identifier of the bucket you would like to delete.
   * @returns Promise with success message or error
   *
   * @example Delete bucket
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .deleteBucket('avatars')
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "message": "Successfully deleted"
   *   },
   *   "error": null
   * }
   * ```
   */
  deleteBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  listBucketOptionsToQueryString(options) {
    const params = {};
    if (options) {
      if ("limit" in options) {
        params.limit = String(options.limit);
      }
      if ("offset" in options) {
        params.offset = String(options.offset);
      }
      if (options.search) {
        params.search = options.search;
      }
      if (options.sortColumn) {
        params.sortColumn = options.sortColumn;
      }
      if (options.sortOrder) {
        params.sortOrder = options.sortOrder;
      }
    }
    return Object.keys(params).length > 0 ? "?" + new URLSearchParams(params).toString() : "";
  }
}
var IcebergError = class extends Error {
  constructor(message, opts) {
    var _a2;
    super(message);
    this.name = "IcebergError";
    this.status = opts.status;
    this.icebergType = opts.icebergType;
    this.icebergCode = opts.icebergCode;
    this.details = opts.details;
    this.isCommitStateUnknown = opts.icebergType === "CommitStateUnknownException" || [500, 502, 504].includes(opts.status) && ((_a2 = opts.icebergType) == null ? void 0 : _a2.includes("CommitState")) === true;
  }
  /**
   * Returns true if the error is a 404 Not Found error.
   */
  isNotFound() {
    return this.status === 404;
  }
  /**
   * Returns true if the error is a 409 Conflict error.
   */
  isConflict() {
    return this.status === 409;
  }
  /**
   * Returns true if the error is a 419 Authentication Timeout error.
   */
  isAuthenticationTimeout() {
    return this.status === 419;
  }
};
function buildUrl(baseUrl, path, query) {
  const url = new URL(path, baseUrl);
  if (query) {
    for (const [key, value] of Object.entries(query)) {
      if (value !== void 0) {
        url.searchParams.set(key, value);
      }
    }
  }
  return url.toString();
}
async function buildAuthHeaders(auth) {
  if (!auth || auth.type === "none") {
    return {};
  }
  if (auth.type === "bearer") {
    return { Authorization: `Bearer ${auth.token}` };
  }
  if (auth.type === "header") {
    return { [auth.name]: auth.value };
  }
  if (auth.type === "custom") {
    return await auth.getHeaders();
  }
  return {};
}
function createFetchClient(options) {
  const fetchFn = options.fetchImpl ?? globalThis.fetch;
  return {
    async request({
      method,
      path,
      query,
      body,
      headers
    }) {
      const url = buildUrl(options.baseUrl, path, query);
      const authHeaders = await buildAuthHeaders(options.auth);
      const res = await fetchFn(url, {
        method,
        headers: {
          ...body ? { "Content-Type": "application/json" } : {},
          ...authHeaders,
          ...headers
        },
        body: body ? JSON.stringify(body) : void 0
      });
      const text = await res.text();
      const isJson = (res.headers.get("content-type") || "").includes("application/json");
      const data = isJson && text ? JSON.parse(text) : text;
      if (!res.ok) {
        const errBody = isJson ? data : void 0;
        const errorDetail = errBody == null ? void 0 : errBody.error;
        throw new IcebergError(
          (errorDetail == null ? void 0 : errorDetail.message) ?? `Request failed with status ${res.status}`,
          {
            status: res.status,
            icebergType: errorDetail == null ? void 0 : errorDetail.type,
            icebergCode: errorDetail == null ? void 0 : errorDetail.code,
            details: errBody
          }
        );
      }
      return { status: res.status, headers: res.headers, data };
    }
  };
}
function namespaceToPath(namespace) {
  return namespace.join("");
}
var NamespaceOperations = class {
  constructor(client2, prefix = "") {
    this.client = client2;
    this.prefix = prefix;
  }
  async listNamespaces(parent) {
    const query = parent ? { parent: namespaceToPath(parent.namespace) } : void 0;
    const response = await this.client.request({
      method: "GET",
      path: `${this.prefix}/namespaces`,
      query
    });
    return response.data.namespaces.map((ns) => ({ namespace: ns }));
  }
  async createNamespace(id, metadata) {
    const request = {
      namespace: id.namespace,
      properties: metadata == null ? void 0 : metadata.properties
    };
    const response = await this.client.request({
      method: "POST",
      path: `${this.prefix}/namespaces`,
      body: request
    });
    return response.data;
  }
  async dropNamespace(id) {
    await this.client.request({
      method: "DELETE",
      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`
    });
  }
  async loadNamespaceMetadata(id) {
    const response = await this.client.request({
      method: "GET",
      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`
    });
    return {
      properties: response.data.properties
    };
  }
  async namespaceExists(id) {
    try {
      await this.client.request({
        method: "HEAD",
        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`
      });
      return true;
    } catch (error2) {
      if (error2 instanceof IcebergError && error2.status === 404) {
        return false;
      }
      throw error2;
    }
  }
  async createNamespaceIfNotExists(id, metadata) {
    try {
      return await this.createNamespace(id, metadata);
    } catch (error2) {
      if (error2 instanceof IcebergError && error2.status === 409) {
        return;
      }
      throw error2;
    }
  }
};
function namespaceToPath2(namespace) {
  return namespace.join("");
}
var TableOperations = class {
  constructor(client2, prefix = "", accessDelegation) {
    this.client = client2;
    this.prefix = prefix;
    this.accessDelegation = accessDelegation;
  }
  async listTables(namespace) {
    const response = await this.client.request({
      method: "GET",
      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`
    });
    return response.data.identifiers;
  }
  async createTable(namespace, request) {
    const headers = {};
    if (this.accessDelegation) {
      headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
    }
    const response = await this.client.request({
      method: "POST",
      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,
      body: request,
      headers
    });
    return response.data.metadata;
  }
  async updateTable(id, request) {
    const response = await this.client.request({
      method: "POST",
      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
      body: request
    });
    return {
      "metadata-location": response.data["metadata-location"],
      metadata: response.data.metadata
    };
  }
  async dropTable(id, options) {
    await this.client.request({
      method: "DELETE",
      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
      query: { purgeRequested: String((options == null ? void 0 : options.purge) ?? false) }
    });
  }
  async loadTable(id) {
    const headers = {};
    if (this.accessDelegation) {
      headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
    }
    const response = await this.client.request({
      method: "GET",
      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
      headers
    });
    return response.data.metadata;
  }
  async tableExists(id) {
    const headers = {};
    if (this.accessDelegation) {
      headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
    }
    try {
      await this.client.request({
        method: "HEAD",
        path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
        headers
      });
      return true;
    } catch (error2) {
      if (error2 instanceof IcebergError && error2.status === 404) {
        return false;
      }
      throw error2;
    }
  }
  async createTableIfNotExists(namespace, request) {
    try {
      return await this.createTable(namespace, request);
    } catch (error2) {
      if (error2 instanceof IcebergError && error2.status === 409) {
        return await this.loadTable({ namespace: namespace.namespace, name: request.name });
      }
      throw error2;
    }
  }
};
var IcebergRestCatalog = class {
  /**
   * Creates a new Iceberg REST Catalog client.
   *
   * @param options - Configuration options for the catalog client
   */
  constructor(options) {
    var _a2;
    let prefix = "v1";
    if (options.catalogName) {
      prefix += `/${options.catalogName}`;
    }
    const baseUrl = options.baseUrl.endsWith("/") ? options.baseUrl : `${options.baseUrl}/`;
    this.client = createFetchClient({
      baseUrl,
      auth: options.auth,
      fetchImpl: options.fetch
    });
    this.accessDelegation = (_a2 = options.accessDelegation) == null ? void 0 : _a2.join(",");
    this.namespaceOps = new NamespaceOperations(this.client, prefix);
    this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);
  }
  /**
   * Lists all namespaces in the catalog.
   *
   * @param parent - Optional parent namespace to list children under
   * @returns Array of namespace identifiers
   *
   * @example
   * ```typescript
   * // List all top-level namespaces
   * const namespaces = await catalog.listNamespaces();
   *
   * // List namespaces under a parent
   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });
   * ```
   */
  async listNamespaces(parent) {
    return this.namespaceOps.listNamespaces(parent);
  }
  /**
   * Creates a new namespace in the catalog.
   *
   * @param id - Namespace identifier to create
   * @param metadata - Optional metadata properties for the namespace
   * @returns Response containing the created namespace and its properties
   *
   * @example
   * ```typescript
   * const response = await catalog.createNamespace(
   *   { namespace: ['analytics'] },
   *   { properties: { owner: 'data-team' } }
   * );
   * console.log(response.namespace); // ['analytics']
   * console.log(response.properties); // { owner: 'data-team', ... }
   * ```
   */
  async createNamespace(id, metadata) {
    return this.namespaceOps.createNamespace(id, metadata);
  }
  /**
   * Drops a namespace from the catalog.
   *
   * The namespace must be empty (contain no tables) before it can be dropped.
   *
   * @param id - Namespace identifier to drop
   *
   * @example
   * ```typescript
   * await catalog.dropNamespace({ namespace: ['analytics'] });
   * ```
   */
  async dropNamespace(id) {
    await this.namespaceOps.dropNamespace(id);
  }
  /**
   * Loads metadata for a namespace.
   *
   * @param id - Namespace identifier to load
   * @returns Namespace metadata including properties
   *
   * @example
   * ```typescript
   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });
   * console.log(metadata.properties);
   * ```
   */
  async loadNamespaceMetadata(id) {
    return this.namespaceOps.loadNamespaceMetadata(id);
  }
  /**
   * Lists all tables in a namespace.
   *
   * @param namespace - Namespace identifier to list tables from
   * @returns Array of table identifiers
   *
   * @example
   * ```typescript
   * const tables = await catalog.listTables({ namespace: ['analytics'] });
   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]
   * ```
   */
  async listTables(namespace) {
    return this.tableOps.listTables(namespace);
  }
  /**
   * Creates a new table in the catalog.
   *
   * @param namespace - Namespace to create the table in
   * @param request - Table creation request including name, schema, partition spec, etc.
   * @returns Table metadata for the created table
   *
   * @example
   * ```typescript
   * const metadata = await catalog.createTable(
   *   { namespace: ['analytics'] },
   *   {
   *     name: 'events',
   *     schema: {
   *       type: 'struct',
   *       fields: [
   *         { id: 1, name: 'id', type: 'long', required: true },
   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }
   *       ],
   *       'schema-id': 0
   *     },
   *     'partition-spec': {
   *       'spec-id': 0,
   *       fields: [
   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }
   *       ]
   *     }
   *   }
   * );
   * ```
   */
  async createTable(namespace, request) {
    return this.tableOps.createTable(namespace, request);
  }
  /**
   * Updates an existing table's metadata.
   *
   * Can update the schema, partition spec, or properties of a table.
   *
   * @param id - Table identifier to update
   * @param request - Update request with fields to modify
   * @returns Response containing the metadata location and updated table metadata
   *
   * @example
   * ```typescript
   * const response = await catalog.updateTable(
   *   { namespace: ['analytics'], name: 'events' },
   *   {
   *     properties: { 'read.split.target-size': '134217728' }
   *   }
   * );
   * console.log(response['metadata-location']); // s3://...
   * console.log(response.metadata); // TableMetadata object
   * ```
   */
  async updateTable(id, request) {
    return this.tableOps.updateTable(id, request);
  }
  /**
   * Drops a table from the catalog.
   *
   * @param id - Table identifier to drop
   *
   * @example
   * ```typescript
   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });
   * ```
   */
  async dropTable(id, options) {
    await this.tableOps.dropTable(id, options);
  }
  /**
   * Loads metadata for a table.
   *
   * @param id - Table identifier to load
   * @returns Table metadata including schema, partition spec, location, etc.
   *
   * @example
   * ```typescript
   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });
   * console.log(metadata.schema);
   * console.log(metadata.location);
   * ```
   */
  async loadTable(id) {
    return this.tableOps.loadTable(id);
  }
  /**
   * Checks if a namespace exists in the catalog.
   *
   * @param id - Namespace identifier to check
   * @returns True if the namespace exists, false otherwise
   *
   * @example
   * ```typescript
   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });
   * console.log(exists); // true or false
   * ```
   */
  async namespaceExists(id) {
    return this.namespaceOps.namespaceExists(id);
  }
  /**
   * Checks if a table exists in the catalog.
   *
   * @param id - Table identifier to check
   * @returns True if the table exists, false otherwise
   *
   * @example
   * ```typescript
   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });
   * console.log(exists); // true or false
   * ```
   */
  async tableExists(id) {
    return this.tableOps.tableExists(id);
  }
  /**
   * Creates a namespace if it does not exist.
   *
   * If the namespace already exists, returns void. If created, returns the response.
   *
   * @param id - Namespace identifier to create
   * @param metadata - Optional metadata properties for the namespace
   * @returns Response containing the created namespace and its properties, or void if it already exists
   *
   * @example
   * ```typescript
   * const response = await catalog.createNamespaceIfNotExists(
   *   { namespace: ['analytics'] },
   *   { properties: { owner: 'data-team' } }
   * );
   * if (response) {
   *   console.log('Created:', response.namespace);
   * } else {
   *   console.log('Already exists');
   * }
   * ```
   */
  async createNamespaceIfNotExists(id, metadata) {
    return this.namespaceOps.createNamespaceIfNotExists(id, metadata);
  }
  /**
   * Creates a table if it does not exist.
   *
   * If the table already exists, returns its metadata instead.
   *
   * @param namespace - Namespace to create the table in
   * @param request - Table creation request including name, schema, partition spec, etc.
   * @returns Table metadata for the created or existing table
   *
   * @example
   * ```typescript
   * const metadata = await catalog.createTableIfNotExists(
   *   { namespace: ['analytics'] },
   *   {
   *     name: 'events',
   *     schema: {
   *       type: 'struct',
   *       fields: [
   *         { id: 1, name: 'id', type: 'long', required: true },
   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }
   *       ],
   *       'schema-id': 0
   *     }
   *   }
   * );
   * ```
   */
  async createTableIfNotExists(namespace, request) {
    return this.tableOps.createTableIfNotExists(namespace, request);
  }
};
class StorageAnalyticsClient {
  /**
   * @alpha
   *
   * Creates a new StorageAnalyticsClient instance
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Analytics Buckets
   * @param url - The base URL for the storage API
   * @param headers - HTTP headers to include in requests
   * @param fetch - Optional custom fetch implementation
   *
   * @example
   * ```typescript
   * const client = new StorageAnalyticsClient(url, headers)
   * ```
   */
  constructor(url, headers = {}, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$2), headers);
    this.fetch = resolveFetch$2(fetch2);
  }
  /**
   * @alpha
   *
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Analytics Buckets
   * @returns This instance for method chaining
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * @alpha
   *
   * Creates a new analytics bucket using Iceberg tables
   * Analytics buckets are optimized for analytical queries and data processing
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Analytics Buckets
   * @param name A unique name for the bucket you are creating
   * @returns Promise with response containing newly created analytics bucket or error
   *
   * @example Create analytics bucket
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .analytics
   *   .createBucket('analytics-data')
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "name": "analytics-data",
   *     "type": "ANALYTICS",
   *     "format": "iceberg",
   *     "created_at": "2024-05-22T22:26:05.100Z",
   *     "updated_at": "2024-05-22T22:26:05.100Z"
   *   },
   *   "error": null
   * }
   * ```
   */
  createBucket(name) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/bucket`, { name }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * @alpha
   *
   * Retrieves the details of all Analytics Storage buckets within an existing project
   * Only returns buckets of type 'ANALYTICS'
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Analytics Buckets
   * @param options Query parameters for listing buckets
   * @param options.limit Maximum number of buckets to return
   * @param options.offset Number of buckets to skip
   * @param options.sortColumn Column to sort by ('name', 'created_at', 'updated_at')
   * @param options.sortOrder Sort order ('asc' or 'desc')
   * @param options.search Search term to filter bucket names
   * @returns Promise with response containing array of analytics buckets or error
   *
   * @example List analytics buckets
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .analytics
   *   .listBuckets({
   *     limit: 10,
   *     offset: 0,
   *     sortColumn: 'created_at',
   *     sortOrder: 'desc'
   *   })
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": [
   *     {
   *       "name": "analytics-data",
   *       "type": "ANALYTICS",
   *       "format": "iceberg",
   *       "created_at": "2024-05-22T22:26:05.100Z",
   *       "updated_at": "2024-05-22T22:26:05.100Z"
   *     }
   *   ],
   *   "error": null
   * }
   * ```
   */
  listBuckets(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const queryParams = new URLSearchParams();
        if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0)
          queryParams.set("limit", options.limit.toString());
        if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0)
          queryParams.set("offset", options.offset.toString());
        if (options === null || options === void 0 ? void 0 : options.sortColumn)
          queryParams.set("sortColumn", options.sortColumn);
        if (options === null || options === void 0 ? void 0 : options.sortOrder)
          queryParams.set("sortOrder", options.sortOrder);
        if (options === null || options === void 0 ? void 0 : options.search)
          queryParams.set("search", options.search);
        const queryString = queryParams.toString();
        const url = queryString ? `${this.url}/bucket?${queryString}` : `${this.url}/bucket`;
        const data = yield get(this.fetch, url, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * @alpha
   *
   * Deletes an existing analytics bucket
   * A bucket can't be deleted with existing objects inside it
   * You must first empty the bucket before deletion
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Analytics Buckets
   * @param bucketName The unique identifier of the bucket you would like to delete
   * @returns Promise with response containing success message or error
   *
   * @example Delete analytics bucket
   * ```js
   * const { data, error } = await supabase
   *   .storage
   *   .analytics
   *   .deleteBucket('analytics-data')
   * ```
   *
   * Response:
   * ```json
   * {
   *   "data": {
   *     "message": "Successfully deleted"
   *   },
   *   "error": null
   * }
   * ```
   */
  deleteBucket(bucketName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/bucket/${bucketName}`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * @alpha
   *
   * Get an Iceberg REST Catalog client configured for a specific analytics bucket
   * Use this to perform advanced table and namespace operations within the bucket
   * The returned client provides full access to the Apache Iceberg REST Catalog API
   * with the Supabase `{ data, error }` pattern for consistent error handling on all operations.
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Analytics Buckets
   * @param bucketName - The name of the analytics bucket (warehouse) to connect to
   * @returns The wrapped Iceberg catalog client
   * @throws {StorageError} If the bucket name is invalid
   *
   * @example Get catalog and create table
   * ```js
   * // First, create an analytics bucket
   * const { data: bucket, error: bucketError } = await supabase
   *   .storage
   *   .analytics
   *   .createBucket('analytics-data')
   *
   * // Get the Iceberg catalog for that bucket
   * const catalog = supabase.storage.analytics.from('analytics-data')
   *
   * // Create a namespace
   * const { error: nsError } = await catalog.createNamespace({ namespace: ['default'] })
   *
   * // Create a table with schema
   * const { data: tableMetadata, error: tableError } = await catalog.createTable(
   *   { namespace: ['default'] },
   *   {
   *     name: 'events',
   *     schema: {
   *       type: 'struct',
   *       fields: [
   *         { id: 1, name: 'id', type: 'long', required: true },
   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true },
   *         { id: 3, name: 'user_id', type: 'string', required: false }
   *       ],
   *       'schema-id': 0,
   *       'identifier-field-ids': [1]
   *     },
   *     'partition-spec': {
   *       'spec-id': 0,
   *       fields: []
   *     },
   *     'write-order': {
   *       'order-id': 0,
   *       fields: []
   *     },
   *     properties: {
   *       'write.format.default': 'parquet'
   *     }
   *   }
   * )
   * ```
   *
   * @example List tables in namespace
   * ```js
   * const catalog = supabase.storage.analytics.from('analytics-data')
   *
   * // List all tables in the default namespace
   * const { data: tables, error: listError } = await catalog.listTables({ namespace: ['default'] })
   * if (listError) {
   *   if (listError.isNotFound()) {
   *     console.log('Namespace not found')
   *   }
   *   return
   * }
   * console.log(tables) // [{ namespace: ['default'], name: 'events' }]
   * ```
   *
   * @example Working with namespaces
   * ```js
   * const catalog = supabase.storage.analytics.from('analytics-data')
   *
   * // List all namespaces
   * const { data: namespaces } = await catalog.listNamespaces()
   *
   * // Create namespace with properties
   * await catalog.createNamespace(
   *   { namespace: ['production'] },
   *   { properties: { owner: 'data-team', env: 'prod' } }
   * )
   * ```
   *
   * @example Cleanup operations
   * ```js
   * const catalog = supabase.storage.analytics.from('analytics-data')
   *
   * // Drop table with purge option (removes all data)
   * const { error: dropError } = await catalog.dropTable(
   *   { namespace: ['default'], name: 'events' },
   *   { purge: true }
   * )
   *
   * if (dropError?.isNotFound()) {
   *   console.log('Table does not exist')
   * }
   *
   * // Drop namespace (must be empty)
   * await catalog.dropNamespace({ namespace: ['default'] })
   * ```
   *
   * @remarks
   * This method provides a bridge between Supabase's bucket management and the standard
   * Apache Iceberg REST Catalog API. The bucket name maps to the Iceberg warehouse parameter.
   * All authentication and configuration is handled automatically using your Supabase credentials.
   *
   * **Error Handling**: Invalid bucket names throw immediately. All catalog
   * operations return `{ data, error }` where errors are `IcebergError` instances from iceberg-js.
   * Use helper methods like `error.isNotFound()` or check `error.status` for specific error handling.
   * Use `.throwOnError()` on the analytics client if you prefer exceptions for catalog operations.
   *
   * **Cleanup Operations**: When using `dropTable`, the `purge: true` option permanently
   * deletes all table data. Without it, the table is marked as deleted but data remains.
   *
   * **Library Dependency**: The returned catalog wraps `IcebergRestCatalog` from iceberg-js.
   * For complete API documentation and advanced usage, refer to the
   * [iceberg-js documentation](https://supabase.github.io/iceberg-js/).
   */
  from(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new StorageError("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");
    }
    const catalog = new IcebergRestCatalog({
      baseUrl: this.url,
      catalogName: bucketName,
      // Maps to the warehouse parameter in Supabase's implementation
      auth: {
        type: "custom",
        getHeaders: () => __awaiter(this, void 0, void 0, function* () {
          return this.headers;
        })
      },
      fetch: this.fetch
    });
    const shouldThrowOnError = this.shouldThrowOnError;
    const wrappedCatalog = new Proxy(catalog, {
      get(target, prop) {
        const value = target[prop];
        if (typeof value !== "function") {
          return value;
        }
        return (...args) => __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield value.apply(target, args);
            return { data, error: null };
          } catch (error2) {
            if (shouldThrowOnError) {
              throw error2;
            }
            return { data: null, error: error2 };
          }
        });
      }
    });
    return wrappedCatalog;
  }
}
const DEFAULT_HEADERS$1 = {
  "X-Client-Info": `storage-js/${version$3}`,
  "Content-Type": "application/json"
};
class StorageVectorsError extends Error {
  constructor(message) {
    super(message);
    this.__isStorageVectorsError = true;
    this.name = "StorageVectorsError";
  }
}
function isStorageVectorsError(error2) {
  return typeof error2 === "object" && error2 !== null && "__isStorageVectorsError" in error2;
}
class StorageVectorsApiError extends StorageVectorsError {
  constructor(message, status, statusCode) {
    super(message);
    this.name = "StorageVectorsApiError";
    this.status = status;
    this.statusCode = statusCode;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode
    };
  }
}
class StorageVectorsUnknownError extends StorageVectorsError {
  constructor(message, originalError) {
    super(message);
    this.name = "StorageVectorsUnknownError";
    this.originalError = originalError;
  }
}
var StorageVectorsErrorCode;
(function(StorageVectorsErrorCode2) {
  StorageVectorsErrorCode2["InternalError"] = "InternalError";
  StorageVectorsErrorCode2["S3VectorConflictException"] = "S3VectorConflictException";
  StorageVectorsErrorCode2["S3VectorNotFoundException"] = "S3VectorNotFoundException";
  StorageVectorsErrorCode2["S3VectorBucketNotEmpty"] = "S3VectorBucketNotEmpty";
  StorageVectorsErrorCode2["S3VectorMaxBucketsExceeded"] = "S3VectorMaxBucketsExceeded";
  StorageVectorsErrorCode2["S3VectorMaxIndexesExceeded"] = "S3VectorMaxIndexesExceeded";
})(StorageVectorsErrorCode || (StorageVectorsErrorCode = {}));
const resolveFetch$1 = (customFetch) => {
  if (customFetch) {
    return (...args) => customFetch(...args);
  }
  return (...args) => fetch(...args);
};
const resolveResponse = () => {
  return Response;
};
const isPlainObject$1 = (value) => {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
const normalizeToFloat32 = (values) => {
  return Array.from(new Float32Array(values));
};
const validateVectorDimension = (vector, expectedDimension) => {
  if (expectedDimension !== void 0 && vector.float32.length !== expectedDimension) {
    throw new Error(`Vector dimension mismatch: expected ${expectedDimension}, got ${vector.float32.length}`);
  }
};
const _getErrorMessage$1 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const handleError$1 = (error2, reject, options) => __awaiter(void 0, void 0, void 0, function* () {
  const isResponseLike = error2 && typeof error2 === "object" && "status" in error2 && "ok" in error2 && typeof error2.status === "number";
  if (isResponseLike && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
    const status = error2.status || 500;
    const responseError = error2;
    if (typeof responseError.json === "function") {
      responseError.json().then((err) => {
        const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + "";
        reject(new StorageVectorsApiError(_getErrorMessage$1(err), status, statusCode));
      }).catch(() => {
        const statusCode = status + "";
        const message = responseError.statusText || `HTTP ${status} error`;
        reject(new StorageVectorsApiError(message, status, statusCode));
      });
    } else {
      const statusCode = status + "";
      const message = responseError.statusText || `HTTP ${status} error`;
      reject(new StorageVectorsApiError(message, status, statusCode));
    }
  } else {
    reject(new StorageVectorsUnknownError(_getErrorMessage$1(error2), error2));
  }
});
const _getRequestParams$1 = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (!body) {
    return params;
  }
  if (isPlainObject$1(body)) {
    params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
    params.body = JSON.stringify(body);
  } else {
    params.body = body;
  }
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest$1(fetcher, method, url, options, parameters, body) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams$1(method, options, parameters, body)).then((result) => {
        if (!result.ok)
          throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson)
          return result;
        const contentType = result.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
          return {};
        }
        return result.json();
      }).then((data) => resolve(data)).catch((error2) => handleError$1(error2, reject, options));
    });
  });
}
function post(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$1(fetcher, "POST", url, options, parameters, body);
  });
}
class VectorIndexApi {
  /** Creates a new VectorIndexApi instance */
  constructor(url, headers = {}, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$1), headers);
    this.fetch = resolveFetch$1(fetch2);
  }
  /** Enable throwing errors instead of returning them in the response */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /** Creates a new vector index within a bucket */
  createIndex(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/CreateIndex`, options, {
          headers: this.headers
        });
        return { data: data || {}, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /** Retrieves metadata for a specific vector index */
  getIndex(vectorBucketName, indexName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/GetIndex`, { vectorBucketName, indexName }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /** Lists vector indexes within a bucket with optional filtering and pagination */
  listIndexes(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/ListIndexes`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /** Deletes a vector index and all its data */
  deleteIndex(vectorBucketName, indexName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/DeleteIndex`, { vectorBucketName, indexName }, { headers: this.headers });
        return { data: data || {}, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
class VectorDataApi {
  /** Creates a new VectorDataApi instance */
  constructor(url, headers = {}, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$1), headers);
    this.fetch = resolveFetch$1(fetch2);
  }
  /** Enable throwing errors instead of returning them in the response */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /** Inserts or updates vectors in batch (1-500 per request) */
  putVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (options.vectors.length < 1 || options.vectors.length > 500) {
          throw new Error("Vector batch size must be between 1 and 500 items");
        }
        const data = yield post(this.fetch, `${this.url}/PutVectors`, options, {
          headers: this.headers
        });
        return { data: data || {}, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /** Retrieves vectors by their keys in batch */
  getVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/GetVectors`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /** Lists vectors in an index with pagination */
  listVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (options.segmentCount !== void 0) {
          if (options.segmentCount < 1 || options.segmentCount > 16) {
            throw new Error("segmentCount must be between 1 and 16");
          }
          if (options.segmentIndex !== void 0) {
            if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {
              throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);
            }
          }
        }
        const data = yield post(this.fetch, `${this.url}/ListVectors`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /** Queries for similar vectors using approximate nearest neighbor search */
  queryVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/QueryVectors`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /** Deletes vectors by their keys in batch (1-500 per request) */
  deleteVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (options.keys.length < 1 || options.keys.length > 500) {
          throw new Error("Keys batch size must be between 1 and 500 items");
        }
        const data = yield post(this.fetch, `${this.url}/DeleteVectors`, options, {
          headers: this.headers
        });
        return { data: data || {}, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
class VectorBucketApi {
  /** Creates a new VectorBucketApi instance */
  constructor(url, headers = {}, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$1), headers);
    this.fetch = resolveFetch$1(fetch2);
  }
  /** Enable throwing errors instead of returning them in the response */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /** Creates a new vector bucket */
  createBucket(vectorBucketName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/CreateVectorBucket`, { vectorBucketName }, { headers: this.headers });
        return { data: data || {}, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /** Retrieves metadata for a specific vector bucket */
  getBucket(vectorBucketName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/GetVectorBucket`, { vectorBucketName }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /** Lists vector buckets with optional filtering and pagination */
  listBuckets() {
    return __awaiter(this, arguments, void 0, function* (options = {}) {
      try {
        const data = yield post(this.fetch, `${this.url}/ListVectorBuckets`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /** Deletes a vector bucket (must be empty first) */
  deleteBucket(vectorBucketName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/DeleteVectorBucket`, { vectorBucketName }, { headers: this.headers });
        return { data: data || {}, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
class StorageVectorsClient extends VectorBucketApi {
  /**
   * @alpha
   *
   * Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param url - Base URL of the Storage Vectors REST API.
   * @param options.headers - Optional headers (for example `Authorization`) applied to every request.
   * @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.
   *
   * @example
   * ```typescript
   * const client = new StorageVectorsClient(url, options)
   * ```
   */
  constructor(url, options = {}) {
    super(url, options.headers || {}, options.fetch);
  }
  /**
   *
   * @alpha
   *
   * Access operations for a specific vector bucket
   * Returns a scoped client for index and vector operations within the bucket
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param vectorBucketName - Name of the vector bucket
   * @returns Bucket-scoped client with index and vector operations
   *
   * @example
   * ```typescript
   * const bucket = supabase.storage.vectors.from('embeddings-prod')
   * ```
   */
  from(vectorBucketName) {
    return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);
  }
  /**
   *
   * @alpha
   *
   * Creates a new vector bucket
   * Vector buckets are containers for vector indexes and their data
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param vectorBucketName - Unique name for the vector bucket
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const { data, error } = await supabase
   *   .storage
   *   .vectors
   *   .createBucket('embeddings-prod')
   * ```
   */
  createBucket(vectorBucketName) {
    const _super = Object.create(null, {
      createBucket: { get: () => super.createBucket }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.createBucket.call(this, vectorBucketName);
    });
  }
  /**
   *
   * @alpha
   *
   * Retrieves metadata for a specific vector bucket
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param vectorBucketName - Name of the vector bucket
   * @returns Promise with bucket metadata or error
   *
   * @example
   * ```typescript
   * const { data, error } = await supabase
   *   .storage
   *   .vectors
   *   .getBucket('embeddings-prod')
   *
   * console.log('Bucket created:', data?.vectorBucket.creationTime)
   * ```
   */
  getBucket(vectorBucketName) {
    const _super = Object.create(null, {
      getBucket: { get: () => super.getBucket }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.getBucket.call(this, vectorBucketName);
    });
  }
  /**
   *
   * @alpha
   *
   * Lists all vector buckets with optional filtering and pagination
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param options - Optional filters (prefix, maxResults, nextToken)
   * @returns Promise with list of buckets or error
   *
   * @example
   * ```typescript
   * const { data, error } = await supabase
   *   .storage
   *   .vectors
   *   .listBuckets({ prefix: 'embeddings-' })
   *
   * data?.vectorBuckets.forEach(bucket => {
   *   console.log(bucket.vectorBucketName)
   * })
   * ```
   */
  listBuckets() {
    const _super = Object.create(null, {
      listBuckets: { get: () => super.listBuckets }
    });
    return __awaiter(this, arguments, void 0, function* (options = {}) {
      return _super.listBuckets.call(this, options);
    });
  }
  /**
   *
   * @alpha
   *
   * Deletes a vector bucket (bucket must be empty)
   * All indexes must be deleted before deleting the bucket
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param vectorBucketName - Name of the vector bucket to delete
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const { data, error } = await supabase
   *   .storage
   *   .vectors
   *   .deleteBucket('embeddings-old')
   * ```
   */
  deleteBucket(vectorBucketName) {
    const _super = Object.create(null, {
      deleteBucket: { get: () => super.deleteBucket }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.deleteBucket.call(this, vectorBucketName);
    });
  }
}
class VectorBucketScope extends VectorIndexApi {
  /**
   * @alpha
   *
   * Creates a helper that automatically scopes all index operations to the provided bucket.
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @example
   * ```typescript
   * const bucket = supabase.storage.vectors.from('embeddings-prod')
   * ```
   */
  constructor(url, headers, vectorBucketName, fetch2) {
    super(url, headers, fetch2);
    this.vectorBucketName = vectorBucketName;
  }
  /**
   *
   * @alpha
   *
   * Creates a new vector index in this bucket
   * Convenience method that automatically includes the bucket name
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param options - Index configuration (vectorBucketName is automatically set)
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const bucket = supabase.storage.vectors.from('embeddings-prod')
   * await bucket.createIndex({
   *   indexName: 'documents-openai',
   *   dataType: 'float32',
   *   dimension: 1536,
   *   distanceMetric: 'cosine',
   *   metadataConfiguration: {
   *     nonFilterableMetadataKeys: ['raw_text']
   *   }
   * })
   * ```
   */
  createIndex(options) {
    const _super = Object.create(null, {
      createIndex: { get: () => super.createIndex }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.createIndex.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName }));
    });
  }
  /**
   *
   * @alpha
   *
   * Lists indexes in this bucket
   * Convenience method that automatically includes the bucket name
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param options - Listing options (vectorBucketName is automatically set)
   * @returns Promise with response containing indexes array and pagination token or error
   *
   * @example
   * ```typescript
   * const bucket = supabase.storage.vectors.from('embeddings-prod')
   * const { data } = await bucket.listIndexes({ prefix: 'documents-' })
   * ```
   */
  listIndexes() {
    const _super = Object.create(null, {
      listIndexes: { get: () => super.listIndexes }
    });
    return __awaiter(this, arguments, void 0, function* (options = {}) {
      return _super.listIndexes.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName }));
    });
  }
  /**
   *
   * @alpha
   *
   * Retrieves metadata for a specific index in this bucket
   * Convenience method that automatically includes the bucket name
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param indexName - Name of the index to retrieve
   * @returns Promise with index metadata or error
   *
   * @example
   * ```typescript
   * const bucket = supabase.storage.vectors.from('embeddings-prod')
   * const { data } = await bucket.getIndex('documents-openai')
   * console.log('Dimension:', data?.index.dimension)
   * ```
   */
  getIndex(indexName) {
    const _super = Object.create(null, {
      getIndex: { get: () => super.getIndex }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.getIndex.call(this, this.vectorBucketName, indexName);
    });
  }
  /**
   *
   * @alpha
   *
   * Deletes an index from this bucket
   * Convenience method that automatically includes the bucket name
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param indexName - Name of the index to delete
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const bucket = supabase.storage.vectors.from('embeddings-prod')
   * await bucket.deleteIndex('old-index')
   * ```
   */
  deleteIndex(indexName) {
    const _super = Object.create(null, {
      deleteIndex: { get: () => super.deleteIndex }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.deleteIndex.call(this, this.vectorBucketName, indexName);
    });
  }
  /**
   *
   * @alpha
   *
   * Access operations for a specific index within this bucket
   * Returns a scoped client for vector data operations
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param indexName - Name of the index
   * @returns Index-scoped client with vector data operations
   *
   * @example
   * ```typescript
   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
   *
   * // Insert vectors
   * await index.putVectors({
   *   vectors: [
   *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }
   *   ]
   * })
   *
   * // Query similar vectors
   * const { data } = await index.queryVectors({
   *   queryVector: { float32: [...] },
   *   topK: 5
   * })
   * ```
   */
  index(indexName) {
    return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);
  }
}
class VectorIndexScope extends VectorDataApi {
  /**
   *
   * @alpha
   *
   * Creates a helper that automatically scopes all vector operations to the provided bucket/index names.
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @example
   * ```typescript
   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
   * ```
   */
  constructor(url, headers, vectorBucketName, indexName, fetch2) {
    super(url, headers, fetch2);
    this.vectorBucketName = vectorBucketName;
    this.indexName = indexName;
  }
  /**
   *
   * @alpha
   *
   * Inserts or updates vectors in this index
   * Convenience method that automatically includes bucket and index names
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param options - Vector insertion options (bucket and index names automatically set)
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
   * await index.putVectors({
   *   vectors: [
   *     {
   *       key: 'doc-1',
   *       data: { float32: [0.1, 0.2, ...] },
   *       metadata: { title: 'Introduction', page: 1 }
   *     }
   *   ]
   * })
   * ```
   */
  putVectors(options) {
    const _super = Object.create(null, {
      putVectors: { get: () => super.putVectors }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.putVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   *
   * @alpha
   *
   * Retrieves vectors by keys from this index
   * Convenience method that automatically includes bucket and index names
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param options - Vector retrieval options (bucket and index names automatically set)
   * @returns Promise with response containing vectors array or error
   *
   * @example
   * ```typescript
   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
   * const { data } = await index.getVectors({
   *   keys: ['doc-1', 'doc-2'],
   *   returnMetadata: true
   * })
   * ```
   */
  getVectors(options) {
    const _super = Object.create(null, {
      getVectors: { get: () => super.getVectors }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.getVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   *
   * @alpha
   *
   * Lists vectors in this index with pagination
   * Convenience method that automatically includes bucket and index names
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param options - Listing options (bucket and index names automatically set)
   * @returns Promise with response containing vectors array and pagination token or error
   *
   * @example
   * ```typescript
   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
   * const { data } = await index.listVectors({
   *   maxResults: 500,
   *   returnMetadata: true
   * })
   * ```
   */
  listVectors() {
    const _super = Object.create(null, {
      listVectors: { get: () => super.listVectors }
    });
    return __awaiter(this, arguments, void 0, function* (options = {}) {
      return _super.listVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   *
   * @alpha
   *
   * Queries for similar vectors in this index
   * Convenience method that automatically includes bucket and index names
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param options - Query options (bucket and index names automatically set)
   * @returns Promise with response containing matches array of similar vectors ordered by distance or error
   *
   * @example
   * ```typescript
   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
   * const { data } = await index.queryVectors({
   *   queryVector: { float32: [0.1, 0.2, ...] },
   *   topK: 5,
   *   filter: { category: 'technical' },
   *   returnDistance: true,
   *   returnMetadata: true
   * })
   * ```
   */
  queryVectors(options) {
    const _super = Object.create(null, {
      queryVectors: { get: () => super.queryVectors }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.queryVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   *
   * @alpha
   *
   * Deletes vectors by keys from this index
   * Convenience method that automatically includes bucket and index names
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @param options - Deletion options (bucket and index names automatically set)
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
   * await index.deleteVectors({
   *   keys: ['doc-1', 'doc-2', 'doc-3']
   * })
   * ```
   */
  deleteVectors(options) {
    const _super = Object.create(null, {
      deleteVectors: { get: () => super.deleteVectors }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.deleteVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
}
class StorageClient extends StorageBucketApi {
  /**
   * Creates a client for Storage buckets, files, analytics, and vectors.
   *
   * @category File Buckets
   * @example
   * ```ts
   * import { StorageClient } from '@supabase/storage-js'
   *
   * const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {
   *   apikey: 'public-anon-key',
   * })
   * const avatars = storage.from('avatars')
   * ```
   */
  constructor(url, headers = {}, fetch2, opts) {
    super(url, headers, fetch2, opts);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @category File Buckets
   * @param id The bucket id to operate on.
   *
   * @example
   * ```typescript
   * const avatars = supabase.storage.from('avatars')
   * ```
   */
  from(id) {
    return new StorageFileApi(this.url, this.headers, id, this.fetch);
  }
  /**
   *
   * @alpha
   *
   * Access vector storage operations.
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Vector Buckets
   * @returns A StorageVectorsClient instance configured with the current storage settings.
   */
  get vectors() {
    return new StorageVectorsClient(this.url + "/vector", {
      headers: this.headers,
      fetch: this.fetch
    });
  }
  /**
   *
   * @alpha
   *
   * Access analytics storage operations using Iceberg tables.
   *
   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
   *
   * @category Analytics Buckets
   * @returns A StorageAnalyticsClient instance configured with the current storage settings.
   */
  get analytics() {
    return new StorageAnalyticsClient(this.url + "/iceberg", this.headers, this.fetch);
  }
}
const module$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StorageAnalyticsClient,
  StorageApiError,
  StorageClient,
  StorageError,
  StorageUnknownError,
  StorageVectorsApiError,
  StorageVectorsClient,
  StorageVectorsError,
  get StorageVectorsErrorCode() {
    return StorageVectorsErrorCode;
  },
  StorageVectorsUnknownError,
  VectorBucketApi,
  VectorBucketScope,
  VectorDataApi,
  VectorIndexApi,
  VectorIndexScope,
  isPlainObject: isPlainObject$1,
  isStorageError,
  isStorageVectorsError,
  normalizeToFloat32,
  resolveFetch: resolveFetch$1,
  resolveResponse,
  validateVectorDimension
}, Symbol.toStringTag, { value: "Module" }));
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(module$2);
var constants = {};
var version$2 = {};
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion) return version$2;
  hasRequiredVersion = 1;
  Object.defineProperty(version$2, "__esModule", { value: true });
  version$2.version = void 0;
  version$2.version = "2.87.1";
  return version$2;
}
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DEFAULT_REALTIME_OPTIONS = exports$1.DEFAULT_AUTH_OPTIONS = exports$1.DEFAULT_DB_OPTIONS = exports$1.DEFAULT_GLOBAL_OPTIONS = exports$1.DEFAULT_HEADERS = void 0;
    const version_1 = /* @__PURE__ */ requireVersion();
    let JS_ENV = "";
    if (typeof Deno !== "undefined") {
      JS_ENV = "deno";
    } else if (typeof document !== "undefined") {
      JS_ENV = "web";
    } else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
      JS_ENV = "react-native";
    } else {
      JS_ENV = "node";
    }
    exports$1.DEFAULT_HEADERS = { "X-Client-Info": `supabase-js-${JS_ENV}/${version_1.version}` };
    exports$1.DEFAULT_GLOBAL_OPTIONS = {
      headers: exports$1.DEFAULT_HEADERS
    };
    exports$1.DEFAULT_DB_OPTIONS = {
      schema: "public"
    };
    exports$1.DEFAULT_AUTH_OPTIONS = {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      flowType: "implicit"
    };
    exports$1.DEFAULT_REALTIME_OPTIONS = {};
  })(constants);
  return constants;
}
var fetch$1 = {};
var hasRequiredFetch;
function requireFetch() {
  if (hasRequiredFetch) return fetch$1;
  hasRequiredFetch = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.fetchWithAuth = exports$1.resolveHeadersConstructor = exports$1.resolveFetch = void 0;
    const resolveFetch2 = (customFetch) => {
      if (customFetch) {
        return (...args) => customFetch(...args);
      }
      return (...args) => fetch(...args);
    };
    exports$1.resolveFetch = resolveFetch2;
    const resolveHeadersConstructor = () => {
      return Headers;
    };
    exports$1.resolveHeadersConstructor = resolveHeadersConstructor;
    const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
      const fetch2 = (0, exports$1.resolveFetch)(customFetch);
      const HeadersConstructor = (0, exports$1.resolveHeadersConstructor)();
      return async (input, init2) => {
        var _a2;
        const accessToken = (_a2 = await getAccessToken()) !== null && _a2 !== void 0 ? _a2 : supabaseKey;
        let headers = new HeadersConstructor(init2 === null || init2 === void 0 ? void 0 : init2.headers);
        if (!headers.has("apikey")) {
          headers.set("apikey", supabaseKey);
        }
        if (!headers.has("Authorization")) {
          headers.set("Authorization", `Bearer ${accessToken}`);
        }
        return fetch2(input, Object.assign(Object.assign({}, init2), { headers }));
      };
    };
    exports$1.fetchWithAuth = fetchWithAuth;
  })(fetch$1);
  return fetch$1;
}
var helpers = {};
var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return helpers;
  hasRequiredHelpers = 1;
  Object.defineProperty(helpers, "__esModule", { value: true });
  helpers.isBrowser = void 0;
  helpers.uuid = uuid2;
  helpers.ensureTrailingSlash = ensureTrailingSlash;
  helpers.applySettingDefaults = applySettingDefaults;
  helpers.validateSupabaseUrl = validateSupabaseUrl;
  function uuid2() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
      var r2 = Math.random() * 16 | 0, v2 = c2 == "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    });
  }
  function ensureTrailingSlash(url) {
    return url.endsWith("/") ? url : url + "/";
  }
  const isBrowser2 = () => typeof window !== "undefined";
  helpers.isBrowser = isBrowser2;
  function applySettingDefaults(options, defaults) {
    var _a2, _b;
    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
    const { db: DEFAULT_DB_OPTIONS, auth: DEFAULT_AUTH_OPTIONS, realtime: DEFAULT_REALTIME_OPTIONS, global: DEFAULT_GLOBAL_OPTIONS } = defaults;
    const result = {
      db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS), dbOptions),
      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), authOptions),
      realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS), realtimeOptions),
      storage: {},
      global: Object.assign(Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS), globalOptions), { headers: Object.assign(Object.assign({}, (_a2 = DEFAULT_GLOBAL_OPTIONS === null || DEFAULT_GLOBAL_OPTIONS === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS.headers) !== null && _a2 !== void 0 ? _a2 : {}), (_b = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _b !== void 0 ? _b : {}) }),
      accessToken: async () => ""
    };
    if (options.accessToken) {
      result.accessToken = options.accessToken;
    } else {
      delete result.accessToken;
    }
    return result;
  }
  function validateSupabaseUrl(supabaseUrl) {
    const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();
    if (!trimmedUrl) {
      throw new Error("supabaseUrl is required.");
    }
    if (!trimmedUrl.match(/^https?:\/\//i)) {
      throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
    }
    try {
      return new URL(ensureTrailingSlash(trimmedUrl));
    } catch (_a2) {
      throw Error("Invalid supabaseUrl: Provided URL is malformed.");
    }
  }
  return helpers;
}
var SupabaseAuthClient = {};
const version$1 = "2.87.1";
const AUTO_REFRESH_TICK_DURATION_MS = 30 * 1e3;
const AUTO_REFRESH_TICK_THRESHOLD = 3;
const EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;
const GOTRUE_URL = "http://localhost:9999";
const STORAGE_KEY = "supabase.auth.token";
const DEFAULT_HEADERS = { "X-Client-Info": `gotrue-js/${version$1}` };
const API_VERSION_HEADER_NAME = "X-Supabase-Api-Version";
const API_VERSIONS = {
  "2024-01-01": {
    timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
    name: "2024-01-01"
  }
};
const BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;
const JWKS_TTL = 10 * 60 * 1e3;
let AuthError$1 = class AuthError extends Error {
  constructor(message, status, code) {
    super(message);
    this.__isAuthError = true;
    this.name = "AuthError";
    this.status = status;
    this.code = code;
  }
};
function isAuthError$1(error2) {
  return typeof error2 === "object" && error2 !== null && "__isAuthError" in error2;
}
let AuthApiError$1 = class AuthApiError extends AuthError$1 {
  constructor(message, status, code) {
    super(message, status, code);
    this.name = "AuthApiError";
    this.status = status;
    this.code = code;
  }
};
function isAuthApiError$1(error2) {
  return isAuthError$1(error2) && error2.name === "AuthApiError";
}
let AuthUnknownError$1 = class AuthUnknownError extends AuthError$1 {
  constructor(message, originalError) {
    super(message);
    this.name = "AuthUnknownError";
    this.originalError = originalError;
  }
};
let CustomAuthError$1 = class CustomAuthError extends AuthError$1 {
  constructor(message, name, status, code) {
    super(message, status, code);
    this.name = name;
    this.status = status;
  }
};
let AuthSessionMissingError$1 = class AuthSessionMissingError extends CustomAuthError$1 {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
};
function isAuthSessionMissingError$1(error2) {
  return isAuthError$1(error2) && error2.name === "AuthSessionMissingError";
}
let AuthInvalidTokenResponseError$1 = class AuthInvalidTokenResponseError extends CustomAuthError$1 {
  constructor() {
    super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0);
  }
};
let AuthInvalidCredentialsError$1 = class AuthInvalidCredentialsError extends CustomAuthError$1 {
  constructor(message) {
    super(message, "AuthInvalidCredentialsError", 400, void 0);
  }
};
let AuthImplicitGrantRedirectError$1 = class AuthImplicitGrantRedirectError extends CustomAuthError$1 {
  constructor(message, details = null) {
    super(message, "AuthImplicitGrantRedirectError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
};
function isAuthImplicitGrantRedirectError$1(error2) {
  return isAuthError$1(error2) && error2.name === "AuthImplicitGrantRedirectError";
}
let AuthPKCEGrantCodeExchangeError$1 = class AuthPKCEGrantCodeExchangeError extends CustomAuthError$1 {
  constructor(message, details = null) {
    super(message, "AuthPKCEGrantCodeExchangeError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
};
let AuthRetryableFetchError$1 = class AuthRetryableFetchError extends CustomAuthError$1 {
  constructor(message, status) {
    super(message, "AuthRetryableFetchError", status, void 0);
  }
};
function isAuthRetryableFetchError$1(error2) {
  return isAuthError$1(error2) && error2.name === "AuthRetryableFetchError";
}
let AuthWeakPasswordError$1 = class AuthWeakPasswordError extends CustomAuthError$1 {
  constructor(message, status, reasons) {
    super(message, "AuthWeakPasswordError", status, "weak_password");
    this.reasons = reasons;
  }
};
function isAuthWeakPasswordError$1(error2) {
  return isAuthError$1(error2) && error2.name === "AuthWeakPasswordError";
}
let AuthInvalidJwtError$1 = class AuthInvalidJwtError extends CustomAuthError$1 {
  constructor(message) {
    super(message, "AuthInvalidJwtError", 400, "invalid_jwt");
  }
};
const TO_BASE64URL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("");
const IGNORE_BASE64URL = " 	\n\r=".split("");
const FROM_BASE64URL = (() => {
  const charMap = new Array(128);
  for (let i2 = 0; i2 < charMap.length; i2 += 1) {
    charMap[i2] = -1;
  }
  for (let i2 = 0; i2 < IGNORE_BASE64URL.length; i2 += 1) {
    charMap[IGNORE_BASE64URL[i2].charCodeAt(0)] = -2;
  }
  for (let i2 = 0; i2 < TO_BASE64URL.length; i2 += 1) {
    charMap[TO_BASE64URL[i2].charCodeAt(0)] = i2;
  }
  return charMap;
})();
function byteToBase64URL(byte, state, emit) {
  if (byte !== null) {
    state.queue = state.queue << 8 | byte;
    state.queuedBits += 8;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  } else if (state.queuedBits > 0) {
    state.queue = state.queue << 6 - state.queuedBits;
    state.queuedBits = 6;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  }
}
function byteFromBase64URL(charCode, state, emit) {
  const bits = FROM_BASE64URL[charCode];
  if (bits > -1) {
    state.queue = state.queue << 6 | bits;
    state.queuedBits += 6;
    while (state.queuedBits >= 8) {
      emit(state.queue >> state.queuedBits - 8 & 255);
      state.queuedBits -= 8;
    }
  } else if (bits === -2) {
    return;
  } else {
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`);
  }
}
function stringFromBase64URL(str) {
  const conv = [];
  const utf8Emit = (codepoint) => {
    conv.push(String.fromCodePoint(codepoint));
  };
  const utf8State = {
    utf8seq: 0,
    codepoint: 0
  };
  const b64State = { queue: 0, queuedBits: 0 };
  const byteEmit = (byte) => {
    stringFromUTF8(byte, utf8State, utf8Emit);
  };
  for (let i2 = 0; i2 < str.length; i2 += 1) {
    byteFromBase64URL(str.charCodeAt(i2), b64State, byteEmit);
  }
  return conv.join("");
}
function codepointToUTF8(codepoint, emit) {
  if (codepoint <= 127) {
    emit(codepoint);
    return;
  } else if (codepoint <= 2047) {
    emit(192 | codepoint >> 6);
    emit(128 | codepoint & 63);
    return;
  } else if (codepoint <= 65535) {
    emit(224 | codepoint >> 12);
    emit(128 | codepoint >> 6 & 63);
    emit(128 | codepoint & 63);
    return;
  } else if (codepoint <= 1114111) {
    emit(240 | codepoint >> 18);
    emit(128 | codepoint >> 12 & 63);
    emit(128 | codepoint >> 6 & 63);
    emit(128 | codepoint & 63);
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);
}
function stringToUTF8(str, emit) {
  for (let i2 = 0; i2 < str.length; i2 += 1) {
    let codepoint = str.charCodeAt(i2);
    if (codepoint > 55295 && codepoint <= 56319) {
      const highSurrogate = (codepoint - 55296) * 1024 & 65535;
      const lowSurrogate = str.charCodeAt(i2 + 1) - 56320 & 65535;
      codepoint = (lowSurrogate | highSurrogate) + 65536;
      i2 += 1;
    }
    codepointToUTF8(codepoint, emit);
  }
}
function stringFromUTF8(byte, state, emit) {
  if (state.utf8seq === 0) {
    if (byte <= 127) {
      emit(byte);
      return;
    }
    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {
      if ((byte >> 7 - leadingBit & 1) === 0) {
        state.utf8seq = leadingBit;
        break;
      }
    }
    if (state.utf8seq === 2) {
      state.codepoint = byte & 31;
    } else if (state.utf8seq === 3) {
      state.codepoint = byte & 15;
    } else if (state.utf8seq === 4) {
      state.codepoint = byte & 7;
    } else {
      throw new Error("Invalid UTF-8 sequence");
    }
    state.utf8seq -= 1;
  } else if (state.utf8seq > 0) {
    if (byte <= 127) {
      throw new Error("Invalid UTF-8 sequence");
    }
    state.codepoint = state.codepoint << 6 | byte & 63;
    state.utf8seq -= 1;
    if (state.utf8seq === 0) {
      emit(state.codepoint);
    }
  }
}
function base64UrlToUint8Array(str) {
  const result = [];
  const state = { queue: 0, queuedBits: 0 };
  const onByte = (byte) => {
    result.push(byte);
  };
  for (let i2 = 0; i2 < str.length; i2 += 1) {
    byteFromBase64URL(str.charCodeAt(i2), state, onByte);
  }
  return new Uint8Array(result);
}
function stringToUint8Array(str) {
  const result = [];
  stringToUTF8(str, (byte) => result.push(byte));
  return new Uint8Array(result);
}
function bytesToBase64URL(bytes) {
  const result = [];
  const state = { queue: 0, queuedBits: 0 };
  const onChar = (char) => {
    result.push(char);
  };
  bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));
  byteToBase64URL(null, state, onChar);
  return result.join("");
}
function expiresAt(expiresIn) {
  const timeNow = Math.round(Date.now() / 1e3);
  return timeNow + expiresIn;
}
function generateCallbackId() {
  return Symbol("auth-callback");
}
const isBrowser = () => typeof window !== "undefined" && typeof document !== "undefined";
const localStorageWriteTests = {
  tested: false,
  writable: false
};
const supportsLocalStorage = () => {
  if (!isBrowser()) {
    return false;
  }
  try {
    if (typeof globalThis.localStorage !== "object") {
      return false;
    }
  } catch (e2) {
    return false;
  }
  if (localStorageWriteTests.tested) {
    return localStorageWriteTests.writable;
  }
  const randomKey = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(randomKey, randomKey);
    globalThis.localStorage.removeItem(randomKey);
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = true;
  } catch (e2) {
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = false;
  }
  return localStorageWriteTests.writable;
};
function parseParametersFromURL(href) {
  const result = {};
  const url = new URL(href);
  if (url.hash && url.hash[0] === "#") {
    try {
      const hashSearchParams = new URLSearchParams(url.hash.substring(1));
      hashSearchParams.forEach((value, key) => {
        result[key] = value;
      });
    } catch (e2) {
    }
  }
  url.searchParams.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
const resolveFetch = (customFetch) => {
  if (customFetch) {
    return (...args) => customFetch(...args);
  }
  return (...args) => fetch(...args);
};
const looksLikeFetchResponse = (maybeResponse) => {
  return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
};
const setItemAsync = async (storage, key, data) => {
  await storage.setItem(key, JSON.stringify(data));
};
const getItemAsync = async (storage, key) => {
  const value = await storage.getItem(key);
  if (!value) {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch (_a2) {
    return value;
  }
};
const removeItemAsync = async (storage, key) => {
  await storage.removeItem(key);
};
class Deferred {
  constructor() {
    this.promise = new Deferred.promiseConstructor((res, rej) => {
      this.resolve = res;
      this.reject = rej;
    });
  }
}
Deferred.promiseConstructor = Promise;
function decodeJWT(token) {
  const parts = token.split(".");
  if (parts.length !== 3) {
    throw new AuthInvalidJwtError$1("Invalid JWT structure");
  }
  for (let i2 = 0; i2 < parts.length; i2++) {
    if (!BASE64URL_REGEX.test(parts[i2])) {
      throw new AuthInvalidJwtError$1("JWT not in base64url format");
    }
  }
  const data = {
    // using base64url lib
    header: JSON.parse(stringFromBase64URL(parts[0])),
    payload: JSON.parse(stringFromBase64URL(parts[1])),
    signature: base64UrlToUint8Array(parts[2]),
    raw: {
      header: parts[0],
      payload: parts[1]
    }
  };
  return data;
}
async function sleep(time2) {
  return await new Promise((accept) => {
    setTimeout(() => accept(null), time2);
  });
}
function retryable(fn, isRetryable) {
  const promise = new Promise((accept, reject) => {
    (async () => {
      for (let attempt = 0; attempt < Infinity; attempt++) {
        try {
          const result = await fn(attempt);
          if (!isRetryable(attempt, null, result)) {
            accept(result);
            return;
          }
        } catch (e2) {
          if (!isRetryable(attempt, e2)) {
            reject(e2);
            return;
          }
        }
      }
    })();
  });
  return promise;
}
function dec2hex(dec) {
  return ("0" + dec.toString(16)).substr(-2);
}
function generatePKCEVerifier() {
  const verifierLength = 56;
  const array2 = new Uint32Array(verifierLength);
  if (typeof crypto === "undefined") {
    const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    const charSetLen = charSet.length;
    let verifier = "";
    for (let i2 = 0; i2 < verifierLength; i2++) {
      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
    }
    return verifier;
  }
  crypto.getRandomValues(array2);
  return Array.from(array2, dec2hex).join("");
}
async function sha256(randomString2) {
  const encoder = new TextEncoder();
  const encodedData = encoder.encode(randomString2);
  const hash = await crypto.subtle.digest("SHA-256", encodedData);
  const bytes = new Uint8Array(hash);
  return Array.from(bytes).map((c2) => String.fromCharCode(c2)).join("");
}
async function generatePKCEChallenge(verifier) {
  const hasCryptoSupport = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof TextEncoder !== "undefined";
  if (!hasCryptoSupport) {
    console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
    return verifier;
  }
  const hashed = await sha256(verifier);
  return btoa(hashed).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {
  const codeVerifier = generatePKCEVerifier();
  let storedCodeVerifier = codeVerifier;
  if (isPasswordRecovery) {
    storedCodeVerifier += "/PASSWORD_RECOVERY";
  }
  await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
  const codeChallenge = await generatePKCEChallenge(codeVerifier);
  const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
  return [codeChallenge, codeChallengeMethod];
}
const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function parseResponseAPIVersion(response) {
  const apiVersion = response.headers.get(API_VERSION_HEADER_NAME);
  if (!apiVersion) {
    return null;
  }
  if (!apiVersion.match(API_VERSION_REGEX)) {
    return null;
  }
  try {
    const date2 = /* @__PURE__ */ new Date(`${apiVersion}T00:00:00.0Z`);
    return date2;
  } catch (e2) {
    return null;
  }
}
function validateExp(exp) {
  if (!exp) {
    throw new Error("Missing exp claim");
  }
  const timeNow = Math.floor(Date.now() / 1e3);
  if (exp <= timeNow) {
    throw new Error("JWT has expired");
  }
}
function getAlgorithm(alg) {
  switch (alg) {
    case "RS256":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      };
    case "ES256":
      return {
        name: "ECDSA",
        namedCurve: "P-256",
        hash: { name: "SHA-256" }
      };
    default:
      throw new Error("Invalid alg claim");
  }
}
const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function validateUUID(str) {
  if (!UUID_REGEX.test(str)) {
    throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not");
  }
}
function userNotAvailableProxy() {
  const proxyTarget = {};
  return new Proxy(proxyTarget, {
    get: (target, prop) => {
      if (prop === "__isUserNotAvailableProxy") {
        return true;
      }
      if (typeof prop === "symbol") {
        const sProp = prop.toString();
        if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)") {
          return void 0;
        }
      }
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${prop}" property of the session object is not supported. Please use getUser() instead.`);
    },
    set: (_target, prop) => {
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    },
    deleteProperty: (_target, prop) => {
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    }
  });
}
function insecureUserWarningProxy(user, suppressWarningRef) {
  return new Proxy(user, {
    get: (target, prop, receiver) => {
      if (prop === "__isInsecureUserWarningProxy") {
        return true;
      }
      if (typeof prop === "symbol") {
        const sProp = prop.toString();
        if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)" || sProp === "Symbol(nodejs.util.inspect.custom)") {
          return Reflect.get(target, prop, receiver);
        }
      }
      if (!suppressWarningRef.value && typeof prop === "string") {
        console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.");
        suppressWarningRef.value = true;
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}
const _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const NETWORK_ERROR_CODES = [502, 503, 504];
async function handleError(error2) {
  var _a2;
  if (!looksLikeFetchResponse(error2)) {
    throw new AuthRetryableFetchError$1(_getErrorMessage(error2), 0);
  }
  if (NETWORK_ERROR_CODES.includes(error2.status)) {
    throw new AuthRetryableFetchError$1(_getErrorMessage(error2), error2.status);
  }
  let data;
  try {
    data = await error2.json();
  } catch (e2) {
    throw new AuthUnknownError$1(_getErrorMessage(e2), e2);
  }
  let errorCode = void 0;
  const responseAPIVersion = parseResponseAPIVersion(error2);
  if (responseAPIVersion && responseAPIVersion.getTime() >= API_VERSIONS["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string") {
    errorCode = data.code;
  } else if (typeof data === "object" && data && typeof data.error_code === "string") {
    errorCode = data.error_code;
  }
  if (!errorCode) {
    if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a2, i2) => a2 && typeof i2 === "string", true)) {
      throw new AuthWeakPasswordError$1(_getErrorMessage(data), error2.status, data.weak_password.reasons);
    }
  } else if (errorCode === "weak_password") {
    throw new AuthWeakPasswordError$1(_getErrorMessage(data), error2.status, ((_a2 = data.weak_password) === null || _a2 === void 0 ? void 0 : _a2.reasons) || []);
  } else if (errorCode === "session_not_found") {
    throw new AuthSessionMissingError$1();
  }
  throw new AuthApiError$1(_getErrorMessage(data), error2.status || 500, errorCode);
}
const _getRequestParams = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
async function _request(fetcher, method, url, options) {
  var _a2;
  const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
  if (!headers[API_VERSION_HEADER_NAME]) {
    headers[API_VERSION_HEADER_NAME] = API_VERSIONS["2024-01-01"].name;
  }
  if (options === null || options === void 0 ? void 0 : options.jwt) {
    headers["Authorization"] = `Bearer ${options.jwt}`;
  }
  const qs = (_a2 = options === null || options === void 0 ? void 0 : options.query) !== null && _a2 !== void 0 ? _a2 : {};
  if (options === null || options === void 0 ? void 0 : options.redirectTo) {
    qs["redirect_to"] = options.redirectTo;
  }
  const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
  const data = await _handleRequest(fetcher, method, url + queryString, {
    headers,
    noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
  }, {}, options === null || options === void 0 ? void 0 : options.body);
  return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };
}
async function _handleRequest(fetcher, method, url, options, parameters, body) {
  const requestParams = _getRequestParams(method, options, parameters, body);
  let result;
  try {
    result = await fetcher(url, Object.assign({}, requestParams));
  } catch (e2) {
    console.error(e2);
    throw new AuthRetryableFetchError$1(_getErrorMessage(e2), 0);
  }
  if (!result.ok) {
    await handleError(result);
  }
  if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
    return result;
  }
  try {
    return await result.json();
  } catch (e2) {
    await handleError(e2);
  }
}
function _sessionResponse(data) {
  var _a2;
  let session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    if (!data.expires_at) {
      session.expires_at = expiresAt(data.expires_in);
    }
  }
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { session, user }, error: null };
}
function _sessionResponsePassword(data) {
  const response = _sessionResponse(data);
  if (!response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a2, i2) => a2 && typeof i2 === "string", true)) {
    response.data.weak_password = data.weak_password;
  }
  return response;
}
function _userResponse(data) {
  var _a2;
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { user }, error: null };
}
function _ssoResponse(data) {
  return { data, error: null };
}
function _generateLinkResponse(data) {
  const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  const properties = {
    action_link,
    email_otp,
    hashed_token,
    redirect_to,
    verification_type
  };
  const user = Object.assign({}, rest);
  return {
    data: {
      properties,
      user
    },
    error: null
  };
}
function _noResolveJsonResponse(data) {
  return data;
}
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}
const SIGN_OUT_SCOPES$1 = ["global", "local", "others"];
let GoTrueAdminApi$1 = class GoTrueAdminApi {
  /**
   * Creates an admin API client that can be used to manage users and OAuth clients.
   *
   * @example
   * ```ts
   * import { GoTrueAdminApi } from '@supabase/auth-js'
   *
   * const admin = new GoTrueAdminApi({
   *   url: 'https://xyzcompany.supabase.co/auth/v1',
   *   headers: { Authorization: `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}` },
   * })
   * ```
   */
  constructor({ url = "", headers = {}, fetch: fetch2 }) {
    this.url = url;
    this.headers = headers;
    this.fetch = resolveFetch(fetch2);
    this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
    this.oauth = {
      listClients: this._listOAuthClients.bind(this),
      createClient: this._createOAuthClient.bind(this),
      getClient: this._getOAuthClient.bind(this),
      updateClient: this._updateOAuthClient.bind(this),
      deleteClient: this._deleteOAuthClient.bind(this),
      regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  async signOut(jwt, scope = SIGN_OUT_SCOPES$1[0]) {
    if (SIGN_OUT_SCOPES$1.indexOf(scope) < 0) {
      throw new Error(`@supabase/auth-js: Parameter scope must be one of ${SIGN_OUT_SCOPES$1.join(", ")}`);
    }
    try {
      await _request(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
        headers: this.headers,
        jwt,
        noResolveJson: true
      });
      return { data: null, error: null };
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: null, error: error2 };
      }
      throw error2;
    }
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  async inviteUserByEmail(email2, options = {}) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/invite`, {
        body: { email: email2, data: options.data },
        headers: this.headers,
        redirectTo: options.redirectTo,
        xform: _userResponse
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: { user: null }, error: error2 };
      }
      throw error2;
    }
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  async generateLink(params) {
    try {
      const { options } = params, rest = __rest(params, ["options"]);
      const body = Object.assign(Object.assign({}, rest), options);
      if ("newEmail" in rest) {
        body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
        delete body["newEmail"];
      }
      return await _request(this.fetch, "POST", `${this.url}/admin/generate_link`, {
        body,
        headers: this.headers,
        xform: _generateLinkResponse,
        redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return {
          data: {
            properties: null,
            user: null
          },
          error: error2
        };
      }
      throw error2;
    }
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async createUser(attributes) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/admin/users`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: { user: null }, error: error2 };
      }
      throw error2;
    }
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  async listUsers(params) {
    var _a2, _b, _c, _d, _e, _f, _g;
    try {
      const pagination = { nextPage: null, lastPage: 0, total: 0 };
      const response = await _request(this.fetch, "GET", `${this.url}/admin/users`, {
        headers: this.headers,
        noResolveJson: true,
        query: {
          page: (_b = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "",
          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
        },
        xform: _noResolveJsonResponse
      });
      if (response.error)
        throw response.error;
      const users = await response.json();
      const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
      const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
      if (links.length > 0) {
        links.forEach((link) => {
          const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
          const rel = JSON.parse(link.split(";")[1].split("=")[1]);
          pagination[`${rel}Page`] = page;
        });
        pagination.total = parseInt(total);
      }
      return { data: Object.assign(Object.assign({}, users), pagination), error: null };
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: { users: [] }, error: error2 };
      }
      throw error2;
    }
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async getUserById(uid) {
    validateUUID(uid);
    try {
      return await _request(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: { user: null }, error: error2 };
      }
      throw error2;
    }
  }
  /**
   * Updates the user data.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async updateUserById(uid, attributes) {
    validateUUID(uid);
    try {
      return await _request(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: { user: null }, error: error2 };
      }
      throw error2;
    }
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async deleteUser(id, shouldSoftDelete = false) {
    validateUUID(id);
    try {
      return await _request(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {
        headers: this.headers,
        body: {
          should_soft_delete: shouldSoftDelete
        },
        xform: _userResponse
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: { user: null }, error: error2 };
      }
      throw error2;
    }
  }
  async _listFactors(params) {
    validateUUID(params.userId);
    try {
      const { data, error: error2 } = await _request(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {
        headers: this.headers,
        xform: (factors) => {
          return { data: { factors }, error: null };
        }
      });
      return { data, error: error2 };
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: null, error: error2 };
      }
      throw error2;
    }
  }
  async _deleteFactor(params) {
    validateUUID(params.userId);
    validateUUID(params.id);
    try {
      const data = await _request(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
        headers: this.headers
      });
      return { data, error: null };
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: null, error: error2 };
      }
      throw error2;
    }
  }
  /**
   * Lists all OAuth clients with optional pagination.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _listOAuthClients(params) {
    var _a2, _b, _c, _d, _e, _f, _g;
    try {
      const pagination = { nextPage: null, lastPage: 0, total: 0 };
      const response = await _request(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
        headers: this.headers,
        noResolveJson: true,
        query: {
          page: (_b = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "",
          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
        },
        xform: _noResolveJsonResponse
      });
      if (response.error)
        throw response.error;
      const clients = await response.json();
      const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
      const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
      if (links.length > 0) {
        links.forEach((link) => {
          const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
          const rel = JSON.parse(link.split(";")[1].split("=")[1]);
          pagination[`${rel}Page`] = page;
        });
        pagination.total = parseInt(total);
      }
      return { data: Object.assign(Object.assign({}, clients), pagination), error: null };
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: { clients: [] }, error: error2 };
      }
      throw error2;
    }
  }
  /**
   * Creates a new OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _createOAuthClient(params) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
        body: params,
        headers: this.headers,
        xform: (client2) => {
          return { data: client2, error: null };
        }
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: null, error: error2 };
      }
      throw error2;
    }
  }
  /**
   * Gets details of a specific OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _getOAuthClient(clientId) {
    try {
      return await _request(this.fetch, "GET", `${this.url}/admin/oauth/clients/${clientId}`, {
        headers: this.headers,
        xform: (client2) => {
          return { data: client2, error: null };
        }
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: null, error: error2 };
      }
      throw error2;
    }
  }
  /**
   * Updates an existing OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _updateOAuthClient(clientId, params) {
    try {
      return await _request(this.fetch, "PUT", `${this.url}/admin/oauth/clients/${clientId}`, {
        body: params,
        headers: this.headers,
        xform: (client2) => {
          return { data: client2, error: null };
        }
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: null, error: error2 };
      }
      throw error2;
    }
  }
  /**
   * Deletes an OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _deleteOAuthClient(clientId) {
    try {
      await _request(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${clientId}`, {
        headers: this.headers,
        noResolveJson: true
      });
      return { data: null, error: null };
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: null, error: error2 };
      }
      throw error2;
    }
  }
  /**
   * Regenerates the secret for an OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _regenerateOAuthClientSecret(clientId) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {
        headers: this.headers,
        xform: (client2) => {
          return { data: client2, error: null };
        }
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: null, error: error2 };
      }
      throw error2;
    }
  }
};
function memoryLocalStorageAdapter(store2 = {}) {
  return {
    getItem: (key) => {
      return store2[key] || null;
    },
    setItem: (key, value) => {
      store2[key] = value;
    },
    removeItem: (key) => {
      delete store2[key];
    }
  };
}
const internals = {
  /**
   * @experimental
   */
  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class LockAcquireTimeoutError extends Error {
  constructor(message) {
    super(message);
    this.isAcquireTimeout = true;
  }
}
let NavigatorLockAcquireTimeoutError$1 = class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {
};
class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {
}
async function navigatorLock$1(name, acquireTimeout, fn) {
  if (internals.debug) {
    console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name, acquireTimeout);
  }
  const abortController = new globalThis.AbortController();
  if (acquireTimeout > 0) {
    setTimeout(() => {
      abortController.abort();
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name);
      }
    }, acquireTimeout);
  }
  return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
    mode: "exclusive",
    ifAvailable: true
  } : {
    mode: "exclusive",
    signal: abortController.signal
  }, async (lock) => {
    if (lock) {
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock: acquired", name, lock.name);
      }
      try {
        return await fn();
      } finally {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: released", name, lock.name);
        }
      }
    } else {
      if (acquireTimeout === 0) {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name);
        }
        throw new NavigatorLockAcquireTimeoutError$1(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
      } else {
        if (internals.debug) {
          try {
            const result = await globalThis.navigator.locks.query();
            console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result, null, "  "));
          } catch (e2) {
            console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e2);
          }
        }
        console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
        return await fn();
      }
    }
  }));
}
const PROCESS_LOCKS = {};
async function processLock$1(name, acquireTimeout, fn) {
  var _a2;
  const previousOperation = (_a2 = PROCESS_LOCKS[name]) !== null && _a2 !== void 0 ? _a2 : Promise.resolve();
  const currentOperation = Promise.race([
    previousOperation.catch(() => {
      return null;
    }),
    acquireTimeout >= 0 ? new Promise((_2, reject) => {
      setTimeout(() => {
        reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name "${name}" timed out`));
      }, acquireTimeout);
    }) : null
  ].filter((x2) => x2)).catch((e2) => {
    if (e2 && e2.isAcquireTimeout) {
      throw e2;
    }
    return null;
  }).then(async () => {
    return await fn();
  });
  PROCESS_LOCKS[name] = currentOperation.catch(async (e2) => {
    if (e2 && e2.isAcquireTimeout) {
      await previousOperation;
      return null;
    }
    throw e2;
  });
  return await currentOperation;
}
function polyfillGlobalThis() {
  if (typeof globalThis === "object")
    return;
  try {
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  } catch (e2) {
    if (typeof self !== "undefined") {
      self.globalThis = self;
    }
  }
}
function getAddress(address) {
  if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
    throw new Error(`@supabase/auth-js: Address "${address}" is invalid.`);
  }
  return address.toLowerCase();
}
function fromHex(hex) {
  return parseInt(hex, 16);
}
function toHex(value) {
  const bytes = new TextEncoder().encode(value);
  const hex = Array.from(bytes, (byte) => byte.toString(16).padStart(2, "0")).join("");
  return "0x" + hex;
}
function createSiweMessage(parameters) {
  var _a2;
  const { chainId, domain, expirationTime, issuedAt = /* @__PURE__ */ new Date(), nonce, notBefore, requestId, resources, scheme, uri, version: version2 } = parameters;
  {
    if (!Number.isInteger(chainId))
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);
    if (!domain)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.`);
    if (nonce && nonce.length < 8)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${nonce}`);
    if (!uri)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.`);
    if (version2 !== "1")
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${version2}`);
    if ((_a2 = parameters.statement) === null || _a2 === void 0 ? void 0 : _a2.includes("\n"))
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${parameters.statement}`);
  }
  const address = getAddress(parameters.address);
  const origin = scheme ? `${scheme}://${domain}` : domain;
  const statement = parameters.statement ? `${parameters.statement}
` : "";
  const prefix = `${origin} wants you to sign in with your Ethereum account:
${address}

${statement}`;
  let suffix = `URI: ${uri}
Version: ${version2}
Chain ID: ${chainId}${nonce ? `
Nonce: ${nonce}` : ""}
Issued At: ${issuedAt.toISOString()}`;
  if (expirationTime)
    suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
  if (notBefore)
    suffix += `
Not Before: ${notBefore.toISOString()}`;
  if (requestId)
    suffix += `
Request ID: ${requestId}`;
  if (resources) {
    let content = "\nResources:";
    for (const resource of resources) {
      if (!resource || typeof resource !== "string")
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${resource}`);
      content += `
- ${resource}`;
    }
    suffix += content;
  }
  return `${prefix}
${suffix}`;
}
class WebAuthnError extends Error {
  constructor({ message, code, cause, name }) {
    var _a2;
    super(message, { cause });
    this.__isWebAuthnError = true;
    this.name = (_a2 = name !== null && name !== void 0 ? name : cause instanceof Error ? cause.name : void 0) !== null && _a2 !== void 0 ? _a2 : "Unknown Error";
    this.code = code;
  }
}
class WebAuthnUnknownError extends WebAuthnError {
  constructor(message, originalError) {
    super({
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: originalError,
      message
    });
    this.name = "WebAuthnUnknownError";
    this.originalError = originalError;
  }
}
function identifyRegistrationError({ error: error2, options }) {
  var _a2, _b, _c;
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error2.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error2
      });
    }
  } else if (error2.name === "ConstraintError") {
    if (((_a2 = publicKey.authenticatorSelection) === null || _a2 === void 0 ? void 0 : _a2.requireResidentKey) === true) {
      return new WebAuthnError({
        message: "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: error2
      });
    } else if (
      // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
      options.mediation === "conditional" && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === "required"
    ) {
      return new WebAuthnError({
        message: "User verification was required during automatic registration but it could not be performed",
        code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
        cause: error2
      });
    } else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === "required") {
      return new WebAuthnError({
        message: "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: error2
      });
    }
  } else if (error2.name === "InvalidStateError") {
    return new WebAuthnError({
      message: "The authenticator was previously registered",
      code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
      cause: error2
    });
  } else if (error2.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error2.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error2
    });
  } else if (error2.name === "NotSupportedError") {
    const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === "public-key");
    if (validPubKeyCredParams.length === 0) {
      return new WebAuthnError({
        message: 'No entry in pubKeyCredParams was of type "public-key"',
        code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
        cause: error2
      });
    }
    return new WebAuthnError({
      message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
      code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
      cause: error2
    });
  } else if (error2.name === "SecurityError") {
    const effectiveDomain = window.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error2
      });
    } else if (publicKey.rp.id !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rp.id}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error2
      });
    }
  } else if (error2.name === "TypeError") {
    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
      return new WebAuthnError({
        message: "User ID was not between 1 and 64 characters",
        code: "ERROR_INVALID_USER_ID_LENGTH",
        cause: error2
      });
    }
  } else if (error2.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new credential",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error2
    });
  }
  return new WebAuthnError({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: error2
  });
}
function identifyAuthenticationError({ error: error2, options }) {
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error2.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Authentication ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error2
      });
    }
  } else if (error2.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error2.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error2
    });
  } else if (error2.name === "SecurityError") {
    const effectiveDomain = window.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error2
      });
    } else if (publicKey.rpId !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rpId}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error2
      });
    }
  } else if (error2.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error2
    });
  }
  return new WebAuthnError({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: error2
  });
}
class WebAuthnAbortService {
  /**
   * Create an abort signal for a new WebAuthn operation.
   * Automatically cancels any existing operation.
   *
   * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}
   */
  createNewAbortSignal() {
    if (this.controller) {
      const abortError = new Error("Cancelling existing WebAuthn API call for new one");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
    }
    const newController = new AbortController();
    this.controller = newController;
    return newController.signal;
  }
  /**
   * Manually cancel the current WebAuthn operation.
   * Useful for cleaning up when user cancels or navigates away.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}
   */
  cancelCeremony() {
    if (this.controller) {
      const abortError = new Error("Manually cancelling existing WebAuthn API call");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
      this.controller = void 0;
    }
  }
}
const webAuthnAbortService = new WebAuthnAbortService();
function deserializeCredentialCreationOptions(options) {
  if (!options) {
    throw new Error("Credential creation options are required");
  }
  if (typeof PublicKeyCredential !== "undefined" && "parseCreationOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === "function") {
    return PublicKeyCredential.parseCreationOptionsFromJSON(
      /** we assert the options here as typescript still doesn't know about future webauthn types */
      options
    );
  }
  const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = __rest(
    options,
    ["challenge", "user", "excludeCredentials"]
  );
  const challenge = base64UrlToUint8Array(challengeStr).buffer;
  const user = Object.assign(Object.assign({}, userOpts), { id: base64UrlToUint8Array(userOpts.id).buffer });
  const result = Object.assign(Object.assign({}, restOptions), {
    challenge,
    user
  });
  if (excludeCredentials && excludeCredentials.length > 0) {
    result.excludeCredentials = new Array(excludeCredentials.length);
    for (let i2 = 0; i2 < excludeCredentials.length; i2++) {
      const cred = excludeCredentials[i2];
      result.excludeCredentials[i2] = Object.assign(Object.assign({}, cred), {
        id: base64UrlToUint8Array(cred.id).buffer,
        type: cred.type || "public-key",
        // Cast transports to handle future transport types like "cable"
        transports: cred.transports
      });
    }
  }
  return result;
}
function deserializeCredentialRequestOptions(options) {
  if (!options) {
    throw new Error("Credential request options are required");
  }
  if (typeof PublicKeyCredential !== "undefined" && "parseRequestOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === "function") {
    return PublicKeyCredential.parseRequestOptionsFromJSON(options);
  }
  const { challenge: challengeStr, allowCredentials } = options, restOptions = __rest(
    options,
    ["challenge", "allowCredentials"]
  );
  const challenge = base64UrlToUint8Array(challengeStr).buffer;
  const result = Object.assign(Object.assign({}, restOptions), { challenge });
  if (allowCredentials && allowCredentials.length > 0) {
    result.allowCredentials = new Array(allowCredentials.length);
    for (let i2 = 0; i2 < allowCredentials.length; i2++) {
      const cred = allowCredentials[i2];
      result.allowCredentials[i2] = Object.assign(Object.assign({}, cred), {
        id: base64UrlToUint8Array(cred.id).buffer,
        type: cred.type || "public-key",
        // Cast transports to handle future transport types like "cable"
        transports: cred.transports
      });
    }
  }
  return result;
}
function serializeCredentialCreationResponse(credential) {
  var _a2;
  if ("toJSON" in credential && typeof credential.toJSON === "function") {
    return credential.toJSON();
  }
  const credentialWithAttachment = credential;
  return {
    id: credential.id,
    rawId: credential.id,
    response: {
      attestationObject: bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),
      clientDataJSON: bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON))
    },
    type: "public-key",
    clientExtensionResults: credential.getClientExtensionResults(),
    // Convert null to undefined and cast to AuthenticatorAttachment type
    authenticatorAttachment: (_a2 = credentialWithAttachment.authenticatorAttachment) !== null && _a2 !== void 0 ? _a2 : void 0
  };
}
function serializeCredentialRequestResponse(credential) {
  var _a2;
  if ("toJSON" in credential && typeof credential.toJSON === "function") {
    return credential.toJSON();
  }
  const credentialWithAttachment = credential;
  const clientExtensionResults = credential.getClientExtensionResults();
  const assertionResponse = credential.response;
  return {
    id: credential.id,
    rawId: credential.id,
    // W3C spec expects rawId to match id for JSON format
    response: {
      authenticatorData: bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),
      clientDataJSON: bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),
      signature: bytesToBase64URL(new Uint8Array(assertionResponse.signature)),
      userHandle: assertionResponse.userHandle ? bytesToBase64URL(new Uint8Array(assertionResponse.userHandle)) : void 0
    },
    type: "public-key",
    clientExtensionResults,
    // Convert null to undefined and cast to AuthenticatorAttachment type
    authenticatorAttachment: (_a2 = credentialWithAttachment.authenticatorAttachment) !== null && _a2 !== void 0 ? _a2 : void 0
  };
}
function isValidDomain(hostname) {
  return (
    // Consider localhost valid as well since it's okay wrt Secure Contexts
    hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname)
  );
}
function browserSupportsWebAuthn() {
  var _a2, _b;
  return !!(isBrowser() && "PublicKeyCredential" in window && window.PublicKeyCredential && "credentials" in navigator && typeof ((_a2 = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a2 === void 0 ? void 0 : _a2.create) === "function" && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === "function");
}
async function createCredential(options) {
  try {
    const response = await navigator.credentials.create(
      /** we assert the type here until typescript types are updated */
      options
    );
    if (!response) {
      return {
        data: null,
        error: new WebAuthnUnknownError("Empty credential response", response)
      };
    }
    if (!(response instanceof PublicKeyCredential)) {
      return {
        data: null,
        error: new WebAuthnUnknownError("Browser returned unexpected credential type", response)
      };
    }
    return { data: response, error: null };
  } catch (err) {
    return {
      data: null,
      error: identifyRegistrationError({
        error: err,
        options
      })
    };
  }
}
async function getCredential(options) {
  try {
    const response = await navigator.credentials.get(
      /** we assert the type here until typescript types are updated */
      options
    );
    if (!response) {
      return {
        data: null,
        error: new WebAuthnUnknownError("Empty credential response", response)
      };
    }
    if (!(response instanceof PublicKeyCredential)) {
      return {
        data: null,
        error: new WebAuthnUnknownError("Browser returned unexpected credential type", response)
      };
    }
    return { data: response, error: null };
  } catch (err) {
    return {
      data: null,
      error: identifyAuthenticationError({
        error: err,
        options
      })
    };
  }
}
const DEFAULT_CREATION_OPTIONS = {
  hints: ["security-key"],
  authenticatorSelection: {
    authenticatorAttachment: "cross-platform",
    requireResidentKey: false,
    /** set to preferred because older yubikeys don't have PIN/Biometric */
    userVerification: "preferred",
    residentKey: "discouraged"
  },
  attestation: "direct"
};
const DEFAULT_REQUEST_OPTIONS = {
  /** set to preferred because older yubikeys don't have PIN/Biometric */
  userVerification: "preferred",
  hints: ["security-key"],
  attestation: "direct"
};
function deepMerge(...sources) {
  const isObject2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);
  const result = {};
  for (const source of sources) {
    if (!source)
      continue;
    for (const key in source) {
      const value = source[key];
      if (value === void 0)
        continue;
      if (Array.isArray(value)) {
        result[key] = value;
      } else if (isArrayBufferLike(value)) {
        result[key] = value;
      } else if (isObject2(value)) {
        const existing = result[key];
        if (isObject2(existing)) {
          result[key] = deepMerge(existing, value);
        } else {
          result[key] = deepMerge(value);
        }
      } else {
        result[key] = value;
      }
    }
  }
  return result;
}
function mergeCredentialCreationOptions(baseOptions, overrides) {
  return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});
}
function mergeCredentialRequestOptions(baseOptions, overrides) {
  return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});
}
class WebAuthnApi {
  constructor(client2) {
    this.client = client2;
    this.enroll = this._enroll.bind(this);
    this.challenge = this._challenge.bind(this);
    this.verify = this._verify.bind(this);
    this.authenticate = this._authenticate.bind(this);
    this.register = this._register.bind(this);
  }
  /**
   * Enroll a new WebAuthn factor.
   * Creates an unverified WebAuthn factor that must be verified with a credential.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)
   * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}
   */
  async _enroll(params) {
    return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: "webauthn" }));
  }
  /**
   * Challenge for WebAuthn credential creation or authentication.
   * Combines server challenge with browser credential operations.
   * Handles both registration (create) and authentication (request) flows.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId
   * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials
   * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation
   * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request
   * @returns {Promise<RequestResult>} Challenge response with credential or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}
   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}
   */
  async _challenge({ factorId, webauthn, friendlyName, signal }, overrides) {
    try {
      const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({
        factorId,
        webauthn
      });
      if (!challengeResponse) {
        return { data: null, error: challengeError };
      }
      const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();
      if (challengeResponse.webauthn.type === "create") {
        const { user } = challengeResponse.webauthn.credential_options.publicKey;
        if (!user.name) {
          user.name = `${user.id}:${friendlyName}`;
        }
        if (!user.displayName) {
          user.displayName = user.name;
        }
      }
      switch (challengeResponse.webauthn.type) {
        case "create": {
          const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);
          const { data, error: error2 } = await createCredential({
            publicKey: options,
            signal: abortSignal
          });
          if (data) {
            return {
              data: {
                factorId,
                challengeId: challengeResponse.id,
                webauthn: {
                  type: challengeResponse.webauthn.type,
                  credential_response: data
                }
              },
              error: null
            };
          }
          return { data: null, error: error2 };
        }
        case "request": {
          const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);
          const { data, error: error2 } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));
          if (data) {
            return {
              data: {
                factorId,
                challengeId: challengeResponse.id,
                webauthn: {
                  type: challengeResponse.webauthn.type,
                  credential_response: data
                }
              },
              error: null
            };
          }
          return { data: null, error: error2 };
        }
      }
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: null, error: error2 };
      }
      return {
        data: null,
        error: new AuthUnknownError$1("Unexpected error in challenge", error2)
      };
    }
  }
  /**
   * Verify a WebAuthn credential with the server.
   * Completes the WebAuthn ceremony by sending the credential to the server for verification.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Verification parameters
   * @param {string} params.challengeId - ID of the challenge being verified
   * @param {string} params.factorId - ID of the WebAuthn factor
   * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response
   * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}
   * */
  async _verify({ challengeId, factorId, webauthn }) {
    return this.client.mfa.verify({
      factorId,
      challengeId,
      webauthn
    });
  }
  /**
   * Complete WebAuthn authentication flow.
   * Performs challenge and verification in a single operation for existing credentials.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Authentication parameters
   * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with
   * @param {Object} params.webauthn - WebAuthn configuration
   * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)
   * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)
   * @param {AbortSignal} params.webauthn.signal - Optional abort signal
   * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get
   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result
   * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}
   */
  async _authenticate({ factorId, webauthn: { rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal } = {} }, overrides) {
    if (!rpId) {
      return {
        data: null,
        error: new AuthError$1("rpId is required for WebAuthn authentication")
      };
    }
    try {
      if (!browserSupportsWebAuthn()) {
        return {
          data: null,
          error: new AuthUnknownError$1("Browser does not support WebAuthn", null)
        };
      }
      const { data: challengeResponse, error: challengeError } = await this.challenge({
        factorId,
        webauthn: { rpId, rpOrigins },
        signal
      }, { request: overrides });
      if (!challengeResponse) {
        return { data: null, error: challengeError };
      }
      const { webauthn } = challengeResponse;
      return this._verify({
        factorId,
        challengeId: challengeResponse.challengeId,
        webauthn: {
          type: webauthn.type,
          rpId,
          rpOrigins,
          credential_response: webauthn.credential_response
        }
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: null, error: error2 };
      }
      return {
        data: null,
        error: new AuthUnknownError$1("Unexpected error in authenticate", error2)
      };
    }
  }
  /**
   * Complete WebAuthn registration flow.
   * Performs enrollment, challenge, and verification in a single operation for new credentials.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Registration parameters
   * @param {string} params.friendlyName - User-friendly name for the credential
   * @param {string} params.rpId - Relying Party ID (defaults to current hostname)
   * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)
   * @param {AbortSignal} params.signal - Optional abort signal
   * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create
   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result
   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}
   */
  async _register({ friendlyName, webauthn: { rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal } = {} }, overrides) {
    if (!rpId) {
      return {
        data: null,
        error: new AuthError$1("rpId is required for WebAuthn registration")
      };
    }
    try {
      if (!browserSupportsWebAuthn()) {
        return {
          data: null,
          error: new AuthUnknownError$1("Browser does not support WebAuthn", null)
        };
      }
      const { data: factor, error: enrollError } = await this._enroll({
        friendlyName
      });
      if (!factor) {
        await this.client.mfa.listFactors().then((factors) => {
          var _a2;
          return (_a2 = factors.data) === null || _a2 === void 0 ? void 0 : _a2.all.find((v2) => v2.factor_type === "webauthn" && v2.friendly_name === friendlyName && v2.status !== "unverified");
        }).then((factor2) => factor2 ? this.client.mfa.unenroll({ factorId: factor2 === null || factor2 === void 0 ? void 0 : factor2.id }) : void 0);
        return { data: null, error: enrollError };
      }
      const { data: challengeResponse, error: challengeError } = await this._challenge({
        factorId: factor.id,
        friendlyName: factor.friendly_name,
        webauthn: { rpId, rpOrigins },
        signal
      }, {
        create: overrides
      });
      if (!challengeResponse) {
        return { data: null, error: challengeError };
      }
      return this._verify({
        factorId: factor.id,
        challengeId: challengeResponse.challengeId,
        webauthn: {
          rpId,
          rpOrigins,
          type: challengeResponse.webauthn.type,
          credential_response: challengeResponse.webauthn.credential_response
        }
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return { data: null, error: error2 };
      }
      return {
        data: null,
        error: new AuthUnknownError$1("Unexpected error in register", error2)
      };
    }
  }
}
polyfillGlobalThis();
const DEFAULT_OPTIONS = {
  url: GOTRUE_URL,
  storageKey: STORAGE_KEY,
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  headers: DEFAULT_HEADERS,
  flowType: "implicit",
  debug: false,
  hasCustomAuthorizationHeader: false,
  throwOnError: false
};
async function lockNoOp(name, acquireTimeout, fn) {
  return await fn();
}
const GLOBAL_JWKS = {};
let GoTrueClient$1 = class GoTrueClient {
  /**
   * The JWKS used for verifying asymmetric JWTs
   */
  get jwks() {
    var _a2, _b;
    return (_b = (_a2 = GLOBAL_JWKS[this.storageKey]) === null || _a2 === void 0 ? void 0 : _a2.jwks) !== null && _b !== void 0 ? _b : { keys: [] };
  }
  set jwks(value) {
    GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { jwks: value });
  }
  get jwks_cached_at() {
    var _a2, _b;
    return (_b = (_a2 = GLOBAL_JWKS[this.storageKey]) === null || _a2 === void 0 ? void 0 : _a2.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
  }
  set jwks_cached_at(value) {
    GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { cachedAt: value });
  }
  /**
   * Create a new client for use in the browser.
   *
   * @example
   * ```ts
   * import { GoTrueClient } from '@supabase/auth-js'
   *
   * const auth = new GoTrueClient({
   *   url: 'https://xyzcompany.supabase.co/auth/v1',
   *   headers: { apikey: 'public-anon-key' },
   *   storageKey: 'supabase-auth',
   * })
   * ```
   */
  constructor(options) {
    var _a2, _b, _c;
    this.userStorage = null;
    this.memoryStorage = null;
    this.stateChangeEmitters = /* @__PURE__ */ new Map();
    this.autoRefreshTicker = null;
    this.visibilityChangedCallback = null;
    this.refreshingDeferred = null;
    this.initializePromise = null;
    this.detectSessionInUrl = true;
    this.hasCustomAuthorizationHeader = false;
    this.suppressGetSessionWarning = false;
    this.lockAcquired = false;
    this.pendingInLock = [];
    this.broadcastChannel = null;
    this.logger = console.log;
    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    this.storageKey = settings.storageKey;
    this.instanceID = (_a2 = GoTrueClient.nextInstanceID[this.storageKey]) !== null && _a2 !== void 0 ? _a2 : 0;
    GoTrueClient.nextInstanceID[this.storageKey] = this.instanceID + 1;
    this.logDebugMessages = !!settings.debug;
    if (typeof settings.debug === "function") {
      this.logger = settings.debug;
    }
    if (this.instanceID > 0 && isBrowser()) {
      const message = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;
      console.warn(message);
      if (this.logDebugMessages) {
        console.trace(message);
      }
    }
    this.persistSession = settings.persistSession;
    this.autoRefreshToken = settings.autoRefreshToken;
    this.admin = new GoTrueAdminApi$1({
      url: settings.url,
      headers: settings.headers,
      fetch: settings.fetch
    });
    this.url = settings.url;
    this.headers = settings.headers;
    this.fetch = resolveFetch(settings.fetch);
    this.lock = settings.lock || lockNoOp;
    this.detectSessionInUrl = settings.detectSessionInUrl;
    this.flowType = settings.flowType;
    this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
    this.throwOnError = settings.throwOnError;
    if (settings.lock) {
      this.lock = settings.lock;
    } else if (this.persistSession && isBrowser() && ((_b = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _b === void 0 ? void 0 : _b.locks)) {
      this.lock = navigatorLock$1;
    } else {
      this.lock = lockNoOp;
    }
    if (!this.jwks) {
      this.jwks = { keys: [] };
      this.jwks_cached_at = Number.MIN_SAFE_INTEGER;
    }
    this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
      webauthn: new WebAuthnApi(this)
    };
    this.oauth = {
      getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
      approveAuthorization: this._approveAuthorization.bind(this),
      denyAuthorization: this._denyAuthorization.bind(this),
      listGrants: this._listOAuthGrants.bind(this),
      revokeGrant: this._revokeOAuthGrant.bind(this)
    };
    if (this.persistSession) {
      if (settings.storage) {
        this.storage = settings.storage;
      } else {
        if (supportsLocalStorage()) {
          this.storage = globalThis.localStorage;
        } else {
          this.memoryStorage = {};
          this.storage = memoryLocalStorageAdapter(this.memoryStorage);
        }
      }
      if (settings.userStorage) {
        this.userStorage = settings.userStorage;
      }
    } else {
      this.memoryStorage = {};
      this.storage = memoryLocalStorageAdapter(this.memoryStorage);
    }
    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (e2) {
        console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e2);
      }
      (_c = this.broadcastChannel) === null || _c === void 0 ? void 0 : _c.addEventListener("message", async (event) => {
        this._debug("received broadcast notification from other tab or client", event);
        await this._notifyAllSubscribers(event.data.event, event.data.session, false);
      });
    }
    this.initialize();
  }
  /**
   * Returns whether error throwing mode is enabled for this client.
   */
  isThrowOnErrorEnabled() {
    return this.throwOnError;
  }
  /**
   * Centralizes return handling with optional error throwing. When `throwOnError` is enabled
   * and the provided result contains a non-nullish error, the error is thrown instead of
   * being returned. This ensures consistent behavior across all public API methods.
   */
  _returnResult(result) {
    if (this.throwOnError && result && result.error) {
      throw result.error;
    }
    return result;
  }
  _logPrefix() {
    return `GoTrueClient@${this.storageKey}:${this.instanceID} (${version$1}) ${(/* @__PURE__ */ new Date()).toISOString()}`;
  }
  _debug(...args) {
    if (this.logDebugMessages) {
      this.logger(this._logPrefix(), ...args);
    }
    return this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  async initialize() {
    if (this.initializePromise) {
      return await this.initializePromise;
    }
    this.initializePromise = (async () => {
      return await this._acquireLock(-1, async () => {
        return await this._initialize();
      });
    })();
    return await this.initializePromise;
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  async _initialize() {
    var _a2;
    try {
      let params = {};
      let callbackUrlType = "none";
      if (isBrowser()) {
        params = parseParametersFromURL(window.location.href);
        if (this._isImplicitGrantCallback(params)) {
          callbackUrlType = "implicit";
        } else if (await this._isPKCECallback(params)) {
          callbackUrlType = "pkce";
        }
      }
      if (isBrowser() && this.detectSessionInUrl && callbackUrlType !== "none") {
        const { data, error: error2 } = await this._getSessionFromURL(params, callbackUrlType);
        if (error2) {
          this._debug("#_initialize()", "error detecting session from URL", error2);
          if (isAuthImplicitGrantRedirectError$1(error2)) {
            const errorCode = (_a2 = error2.details) === null || _a2 === void 0 ? void 0 : _a2.code;
            if (errorCode === "identity_already_exists" || errorCode === "identity_not_found" || errorCode === "single_identity_not_deletable") {
              return { error: error2 };
            }
          }
          await this._removeSession();
          return { error: error2 };
        }
        const { session, redirectType } = data;
        this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
        await this._saveSession(session);
        setTimeout(async () => {
          if (redirectType === "recovery") {
            await this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
          } else {
            await this._notifyAllSubscribers("SIGNED_IN", session);
          }
        }, 0);
        return { error: null };
      }
      await this._recoverAndRefresh();
      return { error: null };
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ error: error2 });
      }
      return this._returnResult({
        error: new AuthUnknownError$1("Unexpected error during initialization", error2)
      });
    } finally {
      await this._handleVisibilityChange();
      this._debug("#_initialize()", "end");
    }
  }
  /**
   * Creates a new anonymous user.
   *
   * @returns A session where the is_anonymous claim in the access token JWT set to true
   */
  async signInAnonymously(credentials) {
    var _a2, _b, _c;
    try {
      const res = await _request(this.fetch, "POST", `${this.url}/signup`, {
        headers: this.headers,
        body: {
          data: (_b = (_a2 = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a2 === void 0 ? void 0 : _a2.data) !== null && _b !== void 0 ? _b : {},
          gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error: error2 } = res;
      if (error2 || !data) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return this._returnResult({ data: { user, session }, error: null });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  async signUp(credentials) {
    var _a2, _b, _c;
    try {
      let res;
      if ("email" in credentials) {
        const { email: email2, password, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: {
            email: email2,
            password,
            data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          xform: _sessionResponse
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone,
            password,
            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
            channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : "sms",
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
      } else {
        throw new AuthInvalidCredentialsError$1("You must provide either an email or phone number and a password");
      }
      const { data, error: error2 } = res;
      if (error2 || !data) {
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return this._returnResult({ data: { user, session }, error: null });
    } catch (error2) {
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  async signInWithPassword(credentials) {
    try {
      let res;
      if ("email" in credentials) {
        const { email: email2, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            email: email2,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponsePassword
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            phone,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponsePassword
        });
      } else {
        throw new AuthInvalidCredentialsError$1("You must provide either an email or phone number and a password");
      }
      const { data, error: error2 } = res;
      if (error2) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      } else if (!data || !data.session || !data.user) {
        const invalidTokenError = new AuthInvalidTokenResponseError$1();
        return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return this._returnResult({
        data: Object.assign({ user: data.user, session: data.session }, data.weak_password ? { weakPassword: data.weak_password } : null),
        error: error2
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  async signInWithOAuth(credentials) {
    var _a2, _b, _c, _d;
    return await this._handleProviderSignIn(credentials.provider, {
      redirectTo: (_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo,
      scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
      queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
      skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  async exchangeCodeForSession(authCode) {
    await this.initializePromise;
    return this._acquireLock(-1, async () => {
      return this._exchangeCodeForSession(authCode);
    });
  }
  /**
   * Signs in a user by verifying a message signed by the user's private key.
   * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,
   * both of which derive from the EIP-4361 standard
   * With slight variation on Solana's side.
   * @reference https://eips.ethereum.org/EIPS/eip-4361
   */
  async signInWithWeb3(credentials) {
    const { chain } = credentials;
    switch (chain) {
      case "ethereum":
        return await this.signInWithEthereum(credentials);
      case "solana":
        return await this.signInWithSolana(credentials);
      default:
        throw new Error(`@supabase/auth-js: Unsupported chain "${chain}"`);
    }
  }
  async signInWithEthereum(credentials) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    let message;
    let signature;
    if ("message" in credentials) {
      message = credentials.message;
      signature = credentials.signature;
    } else {
      const { chain, wallet, statement, options } = credentials;
      let resolvedWallet;
      if (!isBrowser()) {
        if (typeof wallet !== "object" || !(options === null || options === void 0 ? void 0 : options.url)) {
          throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
        }
        resolvedWallet = wallet;
      } else if (typeof wallet === "object") {
        resolvedWallet = wallet;
      } else {
        const windowAny = window;
        if ("ethereum" in windowAny && typeof windowAny.ethereum === "object" && "request" in windowAny.ethereum && typeof windowAny.ethereum.request === "function") {
          resolvedWallet = windowAny.ethereum;
        } else {
          throw new Error(`@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.`);
        }
      }
      const url = new URL((_a2 = options === null || options === void 0 ? void 0 : options.url) !== null && _a2 !== void 0 ? _a2 : window.location.href);
      const accounts = await resolvedWallet.request({
        method: "eth_requestAccounts"
      }).then((accs) => accs).catch(() => {
        throw new Error(`@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid`);
      });
      if (!accounts || accounts.length === 0) {
        throw new Error(`@supabase/auth-js: No accounts available. Please ensure the wallet is connected.`);
      }
      const address = getAddress(accounts[0]);
      let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;
      if (!chainId) {
        const chainIdHex = await resolvedWallet.request({
          method: "eth_chainId"
        });
        chainId = fromHex(chainIdHex);
      }
      const siweMessage = {
        domain: url.host,
        address,
        statement,
        uri: url.href,
        version: "1",
        chainId,
        nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,
        issuedAt: (_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : /* @__PURE__ */ new Date(),
        expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,
        notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,
        requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,
        resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources
      };
      message = createSiweMessage(siweMessage);
      signature = await resolvedWallet.request({
        method: "personal_sign",
        params: [toHex(message), address]
      });
    }
    try {
      const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
        headers: this.headers,
        body: Object.assign({
          chain: "ethereum",
          message,
          signature
        }, ((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken) ? { gotrue_meta_security: { captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken } } : null),
        xform: _sessionResponse
      });
      if (error2) {
        throw error2;
      }
      if (!data || !data.session || !data.user) {
        const invalidTokenError = new AuthInvalidTokenResponseError$1();
        return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return this._returnResult({ data: Object.assign({}, data), error: error2 });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      throw error2;
    }
  }
  async signInWithSolana(credentials) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    let message;
    let signature;
    if ("message" in credentials) {
      message = credentials.message;
      signature = credentials.signature;
    } else {
      const { chain, wallet, statement, options } = credentials;
      let resolvedWallet;
      if (!isBrowser()) {
        if (typeof wallet !== "object" || !(options === null || options === void 0 ? void 0 : options.url)) {
          throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
        }
        resolvedWallet = wallet;
      } else if (typeof wallet === "object") {
        resolvedWallet = wallet;
      } else {
        const windowAny = window;
        if ("solana" in windowAny && typeof windowAny.solana === "object" && ("signIn" in windowAny.solana && typeof windowAny.solana.signIn === "function" || "signMessage" in windowAny.solana && typeof windowAny.solana.signMessage === "function")) {
          resolvedWallet = windowAny.solana;
        } else {
          throw new Error(`@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`);
        }
      }
      const url = new URL((_a2 = options === null || options === void 0 ? void 0 : options.url) !== null && _a2 !== void 0 ? _a2 : window.location.href);
      if ("signIn" in resolvedWallet && resolvedWallet.signIn) {
        const output = await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({ issuedAt: (/* @__PURE__ */ new Date()).toISOString() }, options === null || options === void 0 ? void 0 : options.signInWithSolana), {
          // non-overridable properties
          version: "1",
          domain: url.host,
          uri: url.href
        }), statement ? { statement } : null));
        let outputToProcess;
        if (Array.isArray(output) && output[0] && typeof output[0] === "object") {
          outputToProcess = output[0];
        } else if (output && typeof output === "object" && "signedMessage" in output && "signature" in output) {
          outputToProcess = output;
        } else {
          throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
        }
        if ("signedMessage" in outputToProcess && "signature" in outputToProcess && (typeof outputToProcess.signedMessage === "string" || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array) {
          message = typeof outputToProcess.signedMessage === "string" ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);
          signature = outputToProcess.signature;
        } else {
          throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields");
        }
      } else {
        if (!("signMessage" in resolvedWallet) || typeof resolvedWallet.signMessage !== "function" || !("publicKey" in resolvedWallet) || typeof resolvedWallet !== "object" || !resolvedWallet.publicKey || !("toBase58" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== "function") {
          throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
        }
        message = [
          `${url.host} wants you to sign in with your Solana account:`,
          resolvedWallet.publicKey.toBase58(),
          ...statement ? ["", statement, ""] : [""],
          "Version: 1",
          `URI: ${url.href}`,
          `Issued At: ${(_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : (/* @__PURE__ */ new Date()).toISOString()}`,
          ...((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore) ? [`Not Before: ${options.signInWithSolana.notBefore}`] : [],
          ...((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? void 0 : _e.expirationTime) ? [`Expiration Time: ${options.signInWithSolana.expirationTime}`] : [],
          ...((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId) ? [`Chain ID: ${options.signInWithSolana.chainId}`] : [],
          ...((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? [`Nonce: ${options.signInWithSolana.nonce}`] : [],
          ...((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId) ? [`Request ID: ${options.signInWithSolana.requestId}`] : [],
          ...((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length) ? [
            "Resources",
            ...options.signInWithSolana.resources.map((resource) => `- ${resource}`)
          ] : []
        ].join("\n");
        const maybeSignature = await resolvedWallet.signMessage(new TextEncoder().encode(message), "utf8");
        if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {
          throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
        }
        signature = maybeSignature;
      }
    }
    try {
      const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
        headers: this.headers,
        body: Object.assign({ chain: "solana", message, signature: bytesToBase64URL(signature) }, ((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken) ? { gotrue_meta_security: { captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken } } : null),
        xform: _sessionResponse
      });
      if (error2) {
        throw error2;
      }
      if (!data || !data.session || !data.user) {
        const invalidTokenError = new AuthInvalidTokenResponseError$1();
        return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return this._returnResult({ data: Object.assign({}, data), error: error2 });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      throw error2;
    }
  }
  async _exchangeCodeForSession(authCode) {
    const storageItem = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : "").split("/");
    try {
      const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
        headers: this.headers,
        body: {
          auth_code: authCode,
          code_verifier: codeVerifier
        },
        xform: _sessionResponse
      });
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (error2) {
        throw error2;
      }
      if (!data || !data.session || !data.user) {
        const invalidTokenError = new AuthInvalidTokenResponseError$1();
        return this._returnResult({
          data: { user: null, session: null, redirectType: null },
          error: invalidTokenError
        });
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return this._returnResult({ data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null }), error: error2 });
    } catch (error2) {
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (isAuthError$1(error2)) {
        return this._returnResult({
          data: { user: null, session: null, redirectType: null },
          error: error2
        });
      }
      throw error2;
    }
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  async signInWithIdToken(credentials) {
    try {
      const { options, provider, token, access_token, nonce } = credentials;
      const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
        headers: this.headers,
        body: {
          provider,
          id_token: token,
          access_token,
          nonce,
          gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error: error2 } = res;
      if (error2) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      } else if (!data || !data.session || !data.user) {
        const invalidTokenError = new AuthInvalidTokenResponseError$1();
        return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return this._returnResult({ data, error: error2 });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  async signInWithOtp(credentials) {
    var _a2, _b, _c, _d, _e;
    try {
      if ("email" in credentials) {
        const { email: email2, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const { error: error2 } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email: email2,
            data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
            create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      if ("phone" in credentials) {
        const { phone, options } = credentials;
        const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            phone,
            data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
            create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : "sms"
          }
        });
        return this._returnResult({
          data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id },
          error: error2
        });
      }
      throw new AuthInvalidCredentialsError$1("You must provide either an email or phone number.");
    } catch (error2) {
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
   */
  async verifyOtp(params) {
    var _a2, _b;
    try {
      let redirectTo = void 0;
      let captchaToken = void 0;
      if ("options" in params) {
        redirectTo = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo;
        captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
      }
      const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/verify`, {
        headers: this.headers,
        body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),
        redirectTo,
        xform: _sessionResponse
      });
      if (error2) {
        throw error2;
      }
      if (!data) {
        const tokenVerificationError = new Error("An error occurred on token verification.");
        throw tokenVerificationError;
      }
      const session = data.session;
      const user = data.user;
      if (session === null || session === void 0 ? void 0 : session.access_token) {
        await this._saveSession(session);
        await this._notifyAllSubscribers(params.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
      }
      return this._returnResult({ data: { user, session }, error: null });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  async signInWithSSO(params) {
    var _a2, _b, _c, _d, _e;
    try {
      let codeChallenge = null;
      let codeChallengeMethod = null;
      if (this.flowType === "pkce") {
        ;
        [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
      }
      const result = await _request(this.fetch, "POST", `${this.url}/sso`, {
        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? { provider_id: params.providerId } : null), "domain" in params ? { domain: params.domain } : null), { redirect_to: (_b = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo) !== null && _b !== void 0 ? _b : void 0 }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
        headers: this.headers,
        xform: _ssoResponse
      });
      if (((_d = result.data) === null || _d === void 0 ? void 0 : _d.url) && isBrowser() && !((_e = params.options) === null || _e === void 0 ? void 0 : _e.skipBrowserRedirect)) {
        window.location.assign(result.data.url);
      }
      return this._returnResult(result);
    } catch (error2) {
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: null, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  async reauthenticate() {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._reauthenticate();
    });
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError)
          throw sessionError;
        if (!session)
          throw new AuthSessionMissingError$1();
        const { error: error2 } = await _request(this.fetch, "GET", `${this.url}/reauthenticate`, {
          headers: this.headers,
          jwt: session.access_token
        });
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  async resend(credentials) {
    try {
      const endpoint = `${this.url}/resend`;
      if ("email" in credentials) {
        const { email: email2, type, options } = credentials;
        const { error: error2 } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            email: email2,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      } else if ("phone" in credentials) {
        const { phone, type, options } = credentials;
        const { data, error: error2 } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            phone,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          }
        });
        return this._returnResult({
          data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id },
          error: error2
        });
      }
      throw new AuthInvalidCredentialsError$1("You must provide either an email or phone number and a type");
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Returns the session, refreshing it if necessary.
   *
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   *
   * **IMPORTANT:** This method loads values directly from the storage attached
   * to the client. If that storage is based on request cookies for example,
   * the values in it may not be authentic and therefore it's strongly advised
   * against using this method and its results in such circumstances. A warning
   * will be emitted if this is detected. Use {@link #getUser()} instead.
   */
  async getSession() {
    await this.initializePromise;
    const result = await this._acquireLock(-1, async () => {
      return this._useSession(async (result2) => {
        return result2;
      });
    });
    return result;
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  async _acquireLock(acquireTimeout, fn) {
    this._debug("#_acquireLock", "begin", acquireTimeout);
    try {
      if (this.lockAcquired) {
        const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
        const result = (async () => {
          await last;
          return await fn();
        })();
        this.pendingInLock.push((async () => {
          try {
            await result;
          } catch (e2) {
          }
        })());
        return result;
      }
      return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {
        this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
        try {
          this.lockAcquired = true;
          const result = fn();
          this.pendingInLock.push((async () => {
            try {
              await result;
            } catch (e2) {
            }
          })());
          await result;
          while (this.pendingInLock.length) {
            const waitOn = [...this.pendingInLock];
            await Promise.all(waitOn);
            this.pendingInLock.splice(0, waitOn.length);
          }
          return await result;
        } finally {
          this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
          this.lockAcquired = false;
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  async _useSession(fn) {
    this._debug("#_useSession", "begin");
    try {
      const result = await this.__loadSession();
      return await fn(result);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  async __loadSession() {
    this._debug("#__loadSession()", "begin");
    if (!this.lockAcquired) {
      this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
    }
    try {
      let currentSession = null;
      const maybeSession = await getItemAsync(this.storage, this.storageKey);
      this._debug("#getSession()", "session from storage", maybeSession);
      if (maybeSession !== null) {
        if (this._isValidSession(maybeSession)) {
          currentSession = maybeSession;
        } else {
          this._debug("#getSession()", "session from storage is not valid");
          await this._removeSession();
        }
      }
      if (!currentSession) {
        return { data: { session: null }, error: null };
      }
      const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1e3 - Date.now() < EXPIRY_MARGIN_MS : false;
      this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
      if (!hasExpired) {
        if (this.userStorage) {
          const maybeUser = await getItemAsync(this.userStorage, this.storageKey + "-user");
          if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {
            currentSession.user = maybeUser.user;
          } else {
            currentSession.user = userNotAvailableProxy();
          }
        }
        if (this.storage.isServer && currentSession.user && !currentSession.user.__isUserNotAvailableProxy) {
          const suppressWarningRef = { value: this.suppressGetSessionWarning };
          currentSession.user = insecureUserWarningProxy(currentSession.user, suppressWarningRef);
          if (suppressWarningRef.value) {
            this.suppressGetSessionWarning = true;
          }
        }
        return { data: { session: currentSession }, error: null };
      }
      const { data: session, error: error2 } = await this._callRefreshToken(currentSession.refresh_token);
      if (error2) {
        return this._returnResult({ data: { session: null }, error: error2 });
      }
      return this._returnResult({ data: { session }, error: null });
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  /**
   * Gets the current user details if there is an existing session. This method
   * performs a network request to the Supabase Auth server, so the returned
   * value is authentic and can be used to base authorization rules on.
   *
   * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
   */
  async getUser(jwt) {
    if (jwt) {
      return await this._getUser(jwt);
    }
    await this.initializePromise;
    const result = await this._acquireLock(-1, async () => {
      return await this._getUser();
    });
    if (result.data.user) {
      this.suppressGetSessionWarning = true;
    }
    return result;
  }
  async _getUser(jwt) {
    try {
      if (jwt) {
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt,
          xform: _userResponse
        });
      }
      return await this._useSession(async (result) => {
        var _a2, _b, _c;
        const { data, error: error2 } = result;
        if (error2) {
          throw error2;
        }
        if (!((_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) && !this.hasCustomAuthorizationHeader) {
          return { data: { user: null }, error: new AuthSessionMissingError$1() };
        }
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : void 0,
          xform: _userResponse
        });
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        if (isAuthSessionMissingError$1(error2)) {
          await this._removeSession();
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        }
        return this._returnResult({ data: { user: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Updates user data for a logged in user.
   */
  async updateUser(attributes, options = {}) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._updateUser(attributes, options);
    });
  }
  async _updateUser(attributes, options = {}) {
    try {
      return await this._useSession(async (result) => {
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          throw sessionError;
        }
        if (!sessionData.session) {
          throw new AuthSessionMissingError$1();
        }
        const session = sessionData.session;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce" && attributes.email != null) {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const { data, error: userError } = await _request(this.fetch, "PUT", `${this.url}/user`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
          jwt: session.access_token,
          xform: _userResponse
        });
        if (userError) {
          throw userError;
        }
        session.user = data.user;
        await this._saveSession(session);
        await this._notifyAllSubscribers("USER_UPDATED", session);
        return this._returnResult({ data: { user: session.user }, error: null });
      });
    } catch (error2) {
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { user: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  async setSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._setSession(currentSession);
    });
  }
  async _setSession(currentSession) {
    try {
      if (!currentSession.access_token || !currentSession.refresh_token) {
        throw new AuthSessionMissingError$1();
      }
      const timeNow = Date.now() / 1e3;
      let expiresAt2 = timeNow;
      let hasExpired = true;
      let session = null;
      const { payload } = decodeJWT(currentSession.access_token);
      if (payload.exp) {
        expiresAt2 = payload.exp;
        hasExpired = expiresAt2 <= timeNow;
      }
      if (hasExpired) {
        const { data: refreshedSession, error: error2 } = await this._callRefreshToken(currentSession.refresh_token);
        if (error2) {
          return this._returnResult({ data: { user: null, session: null }, error: error2 });
        }
        if (!refreshedSession) {
          return { data: { user: null, session: null }, error: null };
        }
        session = refreshedSession;
      } else {
        const { data, error: error2 } = await this._getUser(currentSession.access_token);
        if (error2) {
          throw error2;
        }
        session = {
          access_token: currentSession.access_token,
          refresh_token: currentSession.refresh_token,
          user: data.user,
          token_type: "bearer",
          expires_in: expiresAt2 - timeNow,
          expires_at: expiresAt2
        };
        await this._saveSession(session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return this._returnResult({ data: { user: session.user, session }, error: null });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { session: null, user: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  async refreshSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._refreshSession(currentSession);
    });
  }
  async _refreshSession(currentSession) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        if (!currentSession) {
          const { data, error: error3 } = result;
          if (error3) {
            throw error3;
          }
          currentSession = (_a2 = data.session) !== null && _a2 !== void 0 ? _a2 : void 0;
        }
        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
          throw new AuthSessionMissingError$1();
        }
        const { data: session, error: error2 } = await this._callRefreshToken(currentSession.refresh_token);
        if (error2) {
          return this._returnResult({ data: { user: null, session: null }, error: error2 });
        }
        if (!session) {
          return this._returnResult({ data: { user: null, session: null }, error: null });
        }
        return this._returnResult({ data: { user: session.user, session }, error: null });
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { user: null, session: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Gets the session data from a URL string
   */
  async _getSessionFromURL(params, callbackUrlType) {
    try {
      if (!isBrowser())
        throw new AuthImplicitGrantRedirectError$1("No browser detected.");
      if (params.error || params.error_description || params.error_code) {
        throw new AuthImplicitGrantRedirectError$1(params.error_description || "Error in URL with unspecified error_description", {
          error: params.error || "unspecified_error",
          code: params.error_code || "unspecified_code"
        });
      }
      switch (callbackUrlType) {
        case "implicit":
          if (this.flowType === "pkce") {
            throw new AuthPKCEGrantCodeExchangeError$1("Not a valid PKCE flow url.");
          }
          break;
        case "pkce":
          if (this.flowType === "implicit") {
            throw new AuthImplicitGrantRedirectError$1("Not a valid implicit grant flow url.");
          }
          break;
        default:
      }
      if (callbackUrlType === "pkce") {
        this._debug("#_initialize()", "begin", "is PKCE flow", true);
        if (!params.code)
          throw new AuthPKCEGrantCodeExchangeError$1("No code detected.");
        const { data: data2, error: error3 } = await this._exchangeCodeForSession(params.code);
        if (error3)
          throw error3;
        const url = new URL(window.location.href);
        url.searchParams.delete("code");
        window.history.replaceState(window.history.state, "", url.toString());
        return { data: { session: data2.session, redirectType: null }, error: null };
      }
      const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;
      if (!access_token || !expires_in || !refresh_token || !token_type) {
        throw new AuthImplicitGrantRedirectError$1("No session defined in URL");
      }
      const timeNow = Math.round(Date.now() / 1e3);
      const expiresIn = parseInt(expires_in);
      let expiresAt2 = timeNow + expiresIn;
      if (expires_at) {
        expiresAt2 = parseInt(expires_at);
      }
      const actuallyExpiresIn = expiresAt2 - timeNow;
      if (actuallyExpiresIn * 1e3 <= AUTO_REFRESH_TICK_DURATION_MS) {
        console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
      }
      const issuedAt = expiresAt2 - expiresIn;
      if (timeNow - issuedAt >= 120) {
        console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", issuedAt, expiresAt2, timeNow);
      } else if (timeNow - issuedAt < 0) {
        console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", issuedAt, expiresAt2, timeNow);
      }
      const { data, error: error2 } = await this._getUser(access_token);
      if (error2)
        throw error2;
      const session = {
        provider_token,
        provider_refresh_token,
        access_token,
        expires_in: expiresIn,
        expires_at: expiresAt2,
        refresh_token,
        token_type,
        user: data.user
      };
      window.location.hash = "";
      this._debug("#_getSessionFromURL()", "clearing window.location.hash");
      return this._returnResult({ data: { session, redirectType: params.type }, error: null });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { session: null, redirectType: null }, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   */
  _isImplicitGrantCallback(params) {
    return Boolean(params.access_token || params.error_description);
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  async _isPKCECallback(params) {
    const currentStorageContent = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    return !!(params.code && currentStorageContent);
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using `others` scope, no `SIGNED_OUT` event is fired!
   */
  async signOut(options = { scope: "global" }) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._signOut(options);
    });
  }
  async _signOut({ scope } = { scope: "global" }) {
    return await this._useSession(async (result) => {
      var _a2;
      const { data, error: sessionError } = result;
      if (sessionError) {
        return this._returnResult({ error: sessionError });
      }
      const accessToken = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token;
      if (accessToken) {
        const { error: error2 } = await this.admin.signOut(accessToken, scope);
        if (error2) {
          if (!(isAuthApiError$1(error2) && (error2.status === 404 || error2.status === 401 || error2.status === 403))) {
            return this._returnResult({ error: error2 });
          }
        }
      }
      if (scope !== "others") {
        await this._removeSession();
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      }
      return this._returnResult({ error: null });
    });
  }
  onAuthStateChange(callback) {
    const id = generateCallbackId();
    const subscription = {
      id,
      callback,
      unsubscribe: () => {
        this._debug("#unsubscribe()", "state change callback with id removed", id);
        this.stateChangeEmitters.delete(id);
      }
    };
    this._debug("#onAuthStateChange()", "registered callback with id", id);
    this.stateChangeEmitters.set(id, subscription);
    (async () => {
      await this.initializePromise;
      await this._acquireLock(-1, async () => {
        this._emitInitialSession(id);
      });
    })();
    return { data: { subscription } };
  }
  async _emitInitialSession(id) {
    return await this._useSession(async (result) => {
      var _a2, _b;
      try {
        const { data: { session }, error: error2 } = result;
        if (error2)
          throw error2;
        await ((_a2 = this.stateChangeEmitters.get(id)) === null || _a2 === void 0 ? void 0 : _a2.callback("INITIAL_SESSION", session));
        this._debug("INITIAL_SESSION", "callback id", id, "session", session);
      } catch (err) {
        await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback("INITIAL_SESSION", null));
        this._debug("INITIAL_SESSION", "callback id", id, "error", err);
        console.error(err);
      }
    });
  }
  /**
   * Sends a password reset request to an email address. This method supports the PKCE flow.
   *
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  async resetPasswordForEmail(email2, options = {}) {
    let codeChallenge = null;
    let codeChallengeMethod = null;
    if (this.flowType === "pkce") {
      [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(
        this.storage,
        this.storageKey,
        true
        // isPasswordRecovery
      );
    }
    try {
      return await _request(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email: email2,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod,
          gotrue_meta_security: { captcha_token: options.captchaToken }
        },
        headers: this.headers,
        redirectTo: options.redirectTo
      });
    } catch (error2) {
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: null, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Gets all the identities linked to a user.
   */
  async getUserIdentities() {
    var _a2;
    try {
      const { data, error: error2 } = await this.getUser();
      if (error2)
        throw error2;
      return this._returnResult({ data: { identities: (_a2 = data.user.identities) !== null && _a2 !== void 0 ? _a2 : [] }, error: null });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: null, error: error2 });
      }
      throw error2;
    }
  }
  async linkIdentity(credentials) {
    if ("token" in credentials) {
      return this.linkIdentityIdToken(credentials);
    }
    return this.linkIdentityOAuth(credentials);
  }
  async linkIdentityOAuth(credentials) {
    var _a2;
    try {
      const { data, error: error2 } = await this._useSession(async (result) => {
        var _a3, _b, _c, _d, _e;
        const { data: data2, error: error3 } = result;
        if (error3)
          throw error3;
        const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
          redirectTo: (_a3 = credentials.options) === null || _a3 === void 0 ? void 0 : _a3.redirectTo,
          scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
          queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
          skipBrowserRedirect: true
        });
        return await _request(this.fetch, "GET", url, {
          headers: this.headers,
          jwt: (_e = (_d = data2.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : void 0
        });
      });
      if (error2)
        throw error2;
      if (isBrowser() && !((_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.skipBrowserRedirect)) {
        window.location.assign(data === null || data === void 0 ? void 0 : data.url);
      }
      return this._returnResult({
        data: { provider: credentials.provider, url: data === null || data === void 0 ? void 0 : data.url },
        error: null
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { provider: credentials.provider, url: null }, error: error2 });
      }
      throw error2;
    }
  }
  async linkIdentityIdToken(credentials) {
    return await this._useSession(async (result) => {
      var _a2;
      try {
        const { error: sessionError, data: { session } } = result;
        if (sessionError)
          throw sessionError;
        const { options, provider, token, access_token, nonce } = credentials;
        const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
          headers: this.headers,
          jwt: (_a2 = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a2 !== void 0 ? _a2 : void 0,
          body: {
            provider,
            id_token: token,
            access_token,
            nonce,
            link_identity: true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
        const { data, error: error2 } = res;
        if (error2) {
          return this._returnResult({ data: { user: null, session: null }, error: error2 });
        } else if (!data || !data.session || !data.user) {
          return this._returnResult({
            data: { user: null, session: null },
            error: new AuthInvalidTokenResponseError$1()
          });
        }
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("USER_UPDATED", data.session);
        }
        return this._returnResult({ data, error: error2 });
      } catch (error2) {
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        if (isAuthError$1(error2)) {
          return this._returnResult({ data: { user: null, session: null }, error: error2 });
        }
        throw error2;
      }
    });
  }
  /**
   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
   */
  async unlinkIdentity(identity) {
    try {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data, error: error2 } = result;
        if (error2) {
          throw error2;
        }
        return await _request(this.fetch, "DELETE", `${this.url}/user/identities/${identity.identity_id}`, {
          headers: this.headers,
          jwt: (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : void 0
        });
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: null, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  async _refreshAccessToken(refreshToken) {
    const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      const startedAt = Date.now();
      return await retryable(async (attempt) => {
        if (attempt > 0) {
          await sleep(200 * Math.pow(2, attempt - 1));
        }
        this._debug(debugName, "refreshing attempt", attempt);
        return await _request(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
          body: { refresh_token: refreshToken },
          headers: this.headers,
          xform: _sessionResponse
        });
      }, (attempt, error2) => {
        const nextBackOffInterval = 200 * Math.pow(2, attempt);
        return error2 && isAuthRetryableFetchError$1(error2) && // retryable only if the request can be sent before the backoff overflows the tick duration
        Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION_MS;
      });
    } catch (error2) {
      this._debug(debugName, "error", error2);
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: { session: null, user: null }, error: error2 });
      }
      throw error2;
    } finally {
      this._debug(debugName, "end");
    }
  }
  _isValidSession(maybeSession) {
    const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
    return isValidSession;
  }
  async _handleProviderSignIn(provider, options) {
    const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {
      redirectTo: options.redirectTo,
      scopes: options.scopes,
      queryParams: options.queryParams
    });
    this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
    if (isBrowser() && !options.skipBrowserRedirect) {
      window.location.assign(url);
    }
    return { data: { provider, url }, error: null };
  }
  /**
   * Recovers the session from LocalStorage and refreshes the token
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  async _recoverAndRefresh() {
    var _a2, _b;
    const debugName = "#_recoverAndRefresh()";
    this._debug(debugName, "begin");
    try {
      const currentSession = await getItemAsync(this.storage, this.storageKey);
      if (currentSession && this.userStorage) {
        let maybeUser = await getItemAsync(this.userStorage, this.storageKey + "-user");
        if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {
          maybeUser = { user: currentSession.user };
          await setItemAsync(this.userStorage, this.storageKey + "-user", maybeUser);
        }
        currentSession.user = (_a2 = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a2 !== void 0 ? _a2 : userNotAvailableProxy();
      } else if (currentSession && !currentSession.user) {
        if (!currentSession.user) {
          const separateUser = await getItemAsync(this.storage, this.storageKey + "-user");
          if (separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user)) {
            currentSession.user = separateUser.user;
            await removeItemAsync(this.storage, this.storageKey + "-user");
            await setItemAsync(this.storage, this.storageKey, currentSession);
          } else {
            currentSession.user = userNotAvailableProxy();
          }
        }
      }
      this._debug(debugName, "session from storage", currentSession);
      if (!this._isValidSession(currentSession)) {
        this._debug(debugName, "session is not valid");
        if (currentSession !== null) {
          await this._removeSession();
        }
        return;
      }
      const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1e3 - Date.now() < EXPIRY_MARGIN_MS;
      this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${EXPIRY_MARGIN_MS}s`);
      if (expiresWithMargin) {
        if (this.autoRefreshToken && currentSession.refresh_token) {
          const { error: error2 } = await this._callRefreshToken(currentSession.refresh_token);
          if (error2) {
            console.error(error2);
            if (!isAuthRetryableFetchError$1(error2)) {
              this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error2);
              await this._removeSession();
            }
          }
        }
      } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === true) {
        try {
          const { data, error: userError } = await this._getUser(currentSession.access_token);
          if (!userError && (data === null || data === void 0 ? void 0 : data.user)) {
            currentSession.user = data.user;
            await this._saveSession(currentSession);
            await this._notifyAllSubscribers("SIGNED_IN", currentSession);
          } else {
            this._debug(debugName, "could not get user data, skipping SIGNED_IN notification");
          }
        } catch (getUserError) {
          console.error("Error getting user data:", getUserError);
          this._debug(debugName, "error getting user data, skipping SIGNED_IN notification", getUserError);
        }
      } else {
        await this._notifyAllSubscribers("SIGNED_IN", currentSession);
      }
    } catch (err) {
      this._debug(debugName, "error", err);
      console.error(err);
      return;
    } finally {
      this._debug(debugName, "end");
    }
  }
  async _callRefreshToken(refreshToken) {
    var _a2, _b;
    if (!refreshToken) {
      throw new AuthSessionMissingError$1();
    }
    if (this.refreshingDeferred) {
      return this.refreshingDeferred.promise;
    }
    const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      this.refreshingDeferred = new Deferred();
      const { data, error: error2 } = await this._refreshAccessToken(refreshToken);
      if (error2)
        throw error2;
      if (!data.session)
        throw new AuthSessionMissingError$1();
      await this._saveSession(data.session);
      await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
      const result = { data: data.session, error: null };
      this.refreshingDeferred.resolve(result);
      return result;
    } catch (error2) {
      this._debug(debugName, "error", error2);
      if (isAuthError$1(error2)) {
        const result = { data: null, error: error2 };
        if (!isAuthRetryableFetchError$1(error2)) {
          await this._removeSession();
        }
        (_a2 = this.refreshingDeferred) === null || _a2 === void 0 ? void 0 : _a2.resolve(result);
        return result;
      }
      (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error2);
      throw error2;
    } finally {
      this.refreshingDeferred = null;
      this._debug(debugName, "end");
    }
  }
  async _notifyAllSubscribers(event, session, broadcast = true) {
    const debugName = `#_notifyAllSubscribers(${event})`;
    this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
    try {
      if (this.broadcastChannel && broadcast) {
        this.broadcastChannel.postMessage({ event, session });
      }
      const errors = [];
      const promises = Array.from(this.stateChangeEmitters.values()).map(async (x2) => {
        try {
          await x2.callback(event, session);
        } catch (e2) {
          errors.push(e2);
        }
      });
      await Promise.all(promises);
      if (errors.length > 0) {
        for (let i2 = 0; i2 < errors.length; i2 += 1) {
          console.error(errors[i2]);
        }
        throw errors[0];
      }
    } finally {
      this._debug(debugName, "end");
    }
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  async _saveSession(session) {
    this._debug("#_saveSession()", session);
    this.suppressGetSessionWarning = true;
    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    const sessionToProcess = Object.assign({}, session);
    const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;
    if (this.userStorage) {
      if (!userIsProxy && sessionToProcess.user) {
        await setItemAsync(this.userStorage, this.storageKey + "-user", {
          user: sessionToProcess.user
        });
      }
      const mainSessionData = Object.assign({}, sessionToProcess);
      delete mainSessionData.user;
      const clonedMainSessionData = deepClone(mainSessionData);
      await setItemAsync(this.storage, this.storageKey, clonedMainSessionData);
    } else {
      const clonedSession = deepClone(sessionToProcess);
      await setItemAsync(this.storage, this.storageKey, clonedSession);
    }
  }
  async _removeSession() {
    this._debug("#_removeSession()");
    this.suppressGetSessionWarning = false;
    await removeItemAsync(this.storage, this.storageKey);
    await removeItemAsync(this.storage, this.storageKey + "-code-verifier");
    await removeItemAsync(this.storage, this.storageKey + "-user");
    if (this.userStorage) {
      await removeItemAsync(this.userStorage, this.storageKey + "-user");
    }
    await this._notifyAllSubscribers("SIGNED_OUT", null);
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const callback = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
        window.removeEventListener("visibilitychange", callback);
      }
    } catch (e2) {
      console.error("removing visibilitychange callback failed", e2);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  async _startAutoRefresh() {
    await this._stopAutoRefresh();
    this._debug("#_startAutoRefresh()");
    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION_MS);
    this.autoRefreshTicker = ticker;
    if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") {
      ticker.unref();
    } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
      Deno.unrefTimer(ticker);
    }
    setTimeout(async () => {
      await this.initializePromise;
      await this._autoRefreshTokenTick();
    }, 0);
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const ticker = this.autoRefreshTicker;
    this.autoRefreshTicker = null;
    if (ticker) {
      clearInterval(ticker);
    }
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._startAutoRefresh();
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._stopAutoRefresh();
  }
  /**
   * Runs the auto refresh token tick.
   */
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const now = Date.now();
          try {
            return await this._useSession(async (result) => {
              const { data: { session } } = result;
              if (!session || !session.refresh_token || !session.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const expiresInTicks = Math.floor((session.expires_at * 1e3 - now) / AUTO_REFRESH_TICK_DURATION_MS);
              this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
              if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {
                await this._callRefreshToken(session.refresh_token);
              }
            });
          } catch (e2) {
            console.error("Auto refresh tick failed with error. This is likely a transient error.", e2);
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (e2) {
      if (e2.isAcquireTimeout || e2 instanceof LockAcquireTimeoutError) {
        this._debug("auto refresh token tick lock not available");
      } else {
        throw e2;
      }
    }
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  async _handleVisibilityChange() {
    this._debug("#_handleVisibilityChange()");
    if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
      if (this.autoRefreshToken) {
        this.startAutoRefresh();
      }
      return false;
    }
    try {
      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false);
      window === null || window === void 0 ? void 0 : window.addEventListener("visibilitychange", this.visibilityChangedCallback);
      await this._onVisibilityChanged(true);
    } catch (error2) {
      console.error("_handleVisibilityChange", error2);
    }
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  async _onVisibilityChanged(calledFromInitialize) {
    const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
    this._debug(methodName, "visibilityState", document.visibilityState);
    if (document.visibilityState === "visible") {
      if (this.autoRefreshToken) {
        this._startAutoRefresh();
      }
      if (!calledFromInitialize) {
        await this.initializePromise;
        await this._acquireLock(-1, async () => {
          if (document.visibilityState !== "visible") {
            this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
            return;
          }
          await this._recoverAndRefresh();
        });
      }
    } else if (document.visibilityState === "hidden") {
      if (this.autoRefreshToken) {
        this._stopAutoRefresh();
      }
    }
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  async _getUrlForProvider(url, provider, options) {
    const urlParams = [`provider=${encodeURIComponent(provider)}`];
    if (options === null || options === void 0 ? void 0 : options.redirectTo) {
      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
    }
    if (options === null || options === void 0 ? void 0 : options.scopes) {
      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
    }
    if (this.flowType === "pkce") {
      const [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
      const flowParams = new URLSearchParams({
        code_challenge: `${encodeURIComponent(codeChallenge)}`,
        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
      });
      urlParams.push(flowParams.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.queryParams) {
      const query = new URLSearchParams(options.queryParams);
      urlParams.push(query.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
      urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
    }
    return `${url}?${urlParams.join("&")}`;
  }
  async _unenroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        return await _request(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: null, error: error2 });
      }
      throw error2;
    }
  }
  async _enroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        const body = Object.assign({ friendly_name: params.friendlyName, factor_type: params.factorType }, params.factorType === "phone" ? { phone: params.phone } : params.factorType === "totp" ? { issuer: params.issuer } : {});
        const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/factors`, {
          body,
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
        if (error2) {
          return this._returnResult({ data: null, error: error2 });
        }
        if (params.factorType === "totp" && data.type === "totp" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {
          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
        }
        return this._returnResult({ data, error: null });
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: null, error: error2 });
      }
      throw error2;
    }
  }
  async _verify(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (result) => {
          var _a2;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          const body = Object.assign({ challenge_id: params.challengeId }, "webauthn" in params ? {
            webauthn: Object.assign(Object.assign({}, params.webauthn), { credential_response: params.webauthn.type === "create" ? serializeCredentialCreationResponse(params.webauthn.credential_response) : serializeCredentialRequestResponse(params.webauthn.credential_response) })
          } : { code: params.code });
          const { data, error: error2 } = await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {
            body,
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
          if (error2) {
            return this._returnResult({ data: null, error: error2 });
          }
          await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));
          await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
          return this._returnResult({ data, error: error2 });
        });
      } catch (error2) {
        if (isAuthError$1(error2)) {
          return this._returnResult({ data: null, error: error2 });
        }
        throw error2;
      }
    });
  }
  async _challenge(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (result) => {
          var _a2;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          const response = await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {
            body: params,
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
          if (response.error) {
            return response;
          }
          const { data } = response;
          if (data.type !== "webauthn") {
            return { data, error: null };
          }
          switch (data.webauthn.type) {
            case "create":
              return {
                data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: deserializeCredentialCreationOptions(data.webauthn.credential_options.publicKey) }) }) }),
                error: null
              };
            case "request":
              return {
                data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: deserializeCredentialRequestOptions(data.webauthn.credential_options.publicKey) }) }) }),
                error: null
              };
          }
        });
      } catch (error2) {
        if (isAuthError$1(error2)) {
          return this._returnResult({ data: null, error: error2 });
        }
        throw error2;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  async _challengeAndVerify(params) {
    const { data: challengeData, error: challengeError } = await this._challenge({
      factorId: params.factorId
    });
    if (challengeError) {
      return this._returnResult({ data: null, error: challengeError });
    }
    return await this._verify({
      factorId: params.factorId,
      challengeId: challengeData.id,
      code: params.code
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  async _listFactors() {
    var _a2;
    const { data: { user }, error: userError } = await this.getUser();
    if (userError) {
      return { data: null, error: userError };
    }
    const data = {
      all: [],
      phone: [],
      totp: [],
      webauthn: []
    };
    for (const factor of (_a2 = user === null || user === void 0 ? void 0 : user.factors) !== null && _a2 !== void 0 ? _a2 : []) {
      data.all.push(factor);
      if (factor.status === "verified") {
        data[factor.factor_type].push(factor);
      }
    }
    return {
      data,
      error: null
    };
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  async _getAuthenticatorAssuranceLevel() {
    var _a2, _b;
    const { data: { session }, error: sessionError } = await this.getSession();
    if (sessionError) {
      return this._returnResult({ data: null, error: sessionError });
    }
    if (!session) {
      return {
        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
        error: null
      };
    }
    const { payload } = decodeJWT(session.access_token);
    let currentLevel = null;
    if (payload.aal) {
      currentLevel = payload.aal;
    }
    let nextLevel = currentLevel;
    const verifiedFactors = (_b = (_a2 = session.user.factors) === null || _a2 === void 0 ? void 0 : _a2.filter((factor) => factor.status === "verified")) !== null && _b !== void 0 ? _b : [];
    if (verifiedFactors.length > 0) {
      nextLevel = "aal2";
    }
    const currentAuthenticationMethods = payload.amr || [];
    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };
  }
  /**
   * Retrieves details about an OAuth authorization request.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * Returns authorization details including client info, scopes, and user information.
   * If the API returns a redirect_uri, it means consent was already given - the caller
   * should handle the redirect manually if needed.
   */
  async _getAuthorizationDetails(authorizationId) {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        if (!session) {
          return this._returnResult({ data: null, error: new AuthSessionMissingError$1() });
        }
        return await _request(this.fetch, "GET", `${this.url}/oauth/authorizations/${authorizationId}`, {
          headers: this.headers,
          jwt: session.access_token,
          xform: (data) => ({ data, error: null })
        });
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: null, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Approves an OAuth authorization request.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   */
  async _approveAuthorization(authorizationId, options) {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        if (!session) {
          return this._returnResult({ data: null, error: new AuthSessionMissingError$1() });
        }
        const response = await _request(this.fetch, "POST", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {
          headers: this.headers,
          jwt: session.access_token,
          body: { action: "approve" },
          xform: (data) => ({ data, error: null })
        });
        if (response.data && response.data.redirect_url) {
          if (isBrowser() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {
            window.location.assign(response.data.redirect_url);
          }
        }
        return response;
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: null, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Denies an OAuth authorization request.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   */
  async _denyAuthorization(authorizationId, options) {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        if (!session) {
          return this._returnResult({ data: null, error: new AuthSessionMissingError$1() });
        }
        const response = await _request(this.fetch, "POST", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {
          headers: this.headers,
          jwt: session.access_token,
          body: { action: "deny" },
          xform: (data) => ({ data, error: null })
        });
        if (response.data && response.data.redirect_url) {
          if (isBrowser() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {
            window.location.assign(response.data.redirect_url);
          }
        }
        return response;
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: null, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Lists all OAuth grants that the authenticated user has authorized.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   */
  async _listOAuthGrants() {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        if (!session) {
          return this._returnResult({ data: null, error: new AuthSessionMissingError$1() });
        }
        return await _request(this.fetch, "GET", `${this.url}/user/oauth/grants`, {
          headers: this.headers,
          jwt: session.access_token,
          xform: (data) => ({ data, error: null })
        });
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: null, error: error2 });
      }
      throw error2;
    }
  }
  /**
   * Revokes a user's OAuth grant for a specific client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   */
  async _revokeOAuthGrant(options) {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        if (!session) {
          return this._returnResult({ data: null, error: new AuthSessionMissingError$1() });
        }
        await _request(this.fetch, "DELETE", `${this.url}/user/oauth/grants`, {
          headers: this.headers,
          jwt: session.access_token,
          query: { client_id: options.clientId },
          noResolveJson: true
        });
        return { data: {}, error: null };
      });
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: null, error: error2 });
      }
      throw error2;
    }
  }
  async fetchJwk(kid, jwks = { keys: [] }) {
    let jwk = jwks.keys.find((key) => key.kid === kid);
    if (jwk) {
      return jwk;
    }
    const now = Date.now();
    jwk = this.jwks.keys.find((key) => key.kid === kid);
    if (jwk && this.jwks_cached_at + JWKS_TTL > now) {
      return jwk;
    }
    const { data, error: error2 } = await _request(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
      headers: this.headers
    });
    if (error2) {
      throw error2;
    }
    if (!data.keys || data.keys.length === 0) {
      return null;
    }
    this.jwks = data;
    this.jwks_cached_at = now;
    jwk = data.keys.find((key) => key.kid === kid);
    if (!jwk) {
      return null;
    }
    return jwk;
  }
  /**
   * Extracts the JWT claims present in the access token by first verifying the
   * JWT against the server's JSON Web Key Set endpoint
   * `/.well-known/jwks.json` which is often cached, resulting in significantly
   * faster responses. Prefer this method over {@link #getUser} which always
   * sends a request to the Auth server for each JWT.
   *
   * If the project is not using an asymmetric JWT signing key (like ECC or
   * RSA) it always sends a request to the Auth server (similar to {@link
   * #getUser}) to verify the JWT.
   *
   * @param jwt An optional specific JWT you wish to verify, not the one you
   *            can obtain from {@link #getSession}.
   * @param options Various additional options that allow you to customize the
   *                behavior of this method.
   */
  async getClaims(jwt, options = {}) {
    try {
      let token = jwt;
      if (!token) {
        const { data, error: error2 } = await this.getSession();
        if (error2 || !data.session) {
          return this._returnResult({ data: null, error: error2 });
        }
        token = data.session.access_token;
      }
      const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = decodeJWT(token);
      if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {
        validateExp(payload.exp);
      }
      const signingKey = !header.alg || header.alg.startsWith("HS") || !header.kid || !("crypto" in globalThis && "subtle" in globalThis.crypto) ? null : await this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? { keys: options.keys } : options === null || options === void 0 ? void 0 : options.jwks);
      if (!signingKey) {
        const { error: error2 } = await this.getUser(token);
        if (error2) {
          throw error2;
        }
        return {
          data: {
            claims: payload,
            header,
            signature
          },
          error: null
        };
      }
      const algorithm = getAlgorithm(header.alg);
      const publicKey = await crypto.subtle.importKey("jwk", signingKey, algorithm, true, [
        "verify"
      ]);
      const isValid = await crypto.subtle.verify(algorithm, publicKey, signature, stringToUint8Array(`${rawHeader}.${rawPayload}`));
      if (!isValid) {
        throw new AuthInvalidJwtError$1("Invalid JWT signature");
      }
      return {
        data: {
          claims: payload,
          header,
          signature
        },
        error: null
      };
    } catch (error2) {
      if (isAuthError$1(error2)) {
        return this._returnResult({ data: null, error: error2 });
      }
      throw error2;
    }
  }
};
GoTrueClient$1.nextInstanceID = {};
const AuthAdminApi$1 = GoTrueAdminApi$1;
const AuthClient$1 = GoTrueClient$1;
const module$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AuthAdminApi: AuthAdminApi$1,
  AuthApiError: AuthApiError$1,
  AuthClient: AuthClient$1,
  AuthError: AuthError$1,
  AuthImplicitGrantRedirectError: AuthImplicitGrantRedirectError$1,
  AuthInvalidCredentialsError: AuthInvalidCredentialsError$1,
  AuthInvalidJwtError: AuthInvalidJwtError$1,
  AuthInvalidTokenResponseError: AuthInvalidTokenResponseError$1,
  AuthPKCEGrantCodeExchangeError: AuthPKCEGrantCodeExchangeError$1,
  AuthRetryableFetchError: AuthRetryableFetchError$1,
  AuthSessionMissingError: AuthSessionMissingError$1,
  AuthUnknownError: AuthUnknownError$1,
  AuthWeakPasswordError: AuthWeakPasswordError$1,
  CustomAuthError: CustomAuthError$1,
  GoTrueAdminApi: GoTrueAdminApi$1,
  GoTrueClient: GoTrueClient$1,
  NavigatorLockAcquireTimeoutError: NavigatorLockAcquireTimeoutError$1,
  SIGN_OUT_SCOPES: SIGN_OUT_SCOPES$1,
  isAuthApiError: isAuthApiError$1,
  isAuthError: isAuthError$1,
  isAuthImplicitGrantRedirectError: isAuthImplicitGrantRedirectError$1,
  isAuthRetryableFetchError: isAuthRetryableFetchError$1,
  isAuthSessionMissingError: isAuthSessionMissingError$1,
  isAuthWeakPasswordError: isAuthWeakPasswordError$1,
  lockInternals: internals,
  navigatorLock: navigatorLock$1,
  processLock: processLock$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(module$1);
var hasRequiredSupabaseAuthClient;
function requireSupabaseAuthClient() {
  if (hasRequiredSupabaseAuthClient) return SupabaseAuthClient;
  hasRequiredSupabaseAuthClient = 1;
  Object.defineProperty(SupabaseAuthClient, "__esModule", { value: true });
  SupabaseAuthClient.SupabaseAuthClient = void 0;
  const auth_js_1 = require$$1;
  let SupabaseAuthClient$1 = class SupabaseAuthClient extends auth_js_1.AuthClient {
    constructor(options) {
      super(options);
    }
  };
  SupabaseAuthClient.SupabaseAuthClient = SupabaseAuthClient$1;
  return SupabaseAuthClient;
}
var hasRequiredSupabaseClient;
function requireSupabaseClient() {
  if (hasRequiredSupabaseClient) return SupabaseClient$1;
  hasRequiredSupabaseClient = 1;
  Object.defineProperty(SupabaseClient$1, "__esModule", { value: true });
  const functions_js_1 = require$$3$1;
  const postgrest_js_1 = requireCjs();
  const realtime_js_1 = require$$4;
  const storage_js_1 = require$$3;
  const constants_1 = /* @__PURE__ */ requireConstants();
  const fetch_1 = /* @__PURE__ */ requireFetch();
  const helpers_1 = /* @__PURE__ */ requireHelpers();
  const SupabaseAuthClient_1 = /* @__PURE__ */ requireSupabaseAuthClient();
  class SupabaseClient2 {
    /**
     * Create a new client for use in the browser.
     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
     * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
     * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
     * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
     * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
     * @param options.realtime Options passed along to realtime-js constructor.
     * @param options.storage Options passed along to the storage-js constructor.
     * @param options.global.fetch A custom fetch implementation.
     * @param options.global.headers Any additional headers to send with each network request.
     * @example
     * ```ts
     * import { createClient } from '@supabase/supabase-js'
     *
     * const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')
     * const { data } = await supabase.from('profiles').select('*')
     * ```
     */
    constructor(supabaseUrl, supabaseKey, options) {
      var _a2, _b, _c;
      this.supabaseUrl = supabaseUrl;
      this.supabaseKey = supabaseKey;
      const baseUrl = (0, helpers_1.validateSupabaseUrl)(supabaseUrl);
      if (!supabaseKey)
        throw new Error("supabaseKey is required.");
      this.realtimeUrl = new URL("realtime/v1", baseUrl);
      this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws");
      this.authUrl = new URL("auth/v1", baseUrl);
      this.storageUrl = new URL("storage/v1", baseUrl);
      this.functionsUrl = new URL("functions/v1", baseUrl);
      const defaultStorageKey = `sb-${baseUrl.hostname.split(".")[0]}-auth-token`;
      const DEFAULTS = {
        db: constants_1.DEFAULT_DB_OPTIONS,
        realtime: constants_1.DEFAULT_REALTIME_OPTIONS,
        auth: Object.assign(Object.assign({}, constants_1.DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),
        global: constants_1.DEFAULT_GLOBAL_OPTIONS
      };
      const settings = (0, helpers_1.applySettingDefaults)(options !== null && options !== void 0 ? options : {}, DEFAULTS);
      this.storageKey = (_a2 = settings.auth.storageKey) !== null && _a2 !== void 0 ? _a2 : "";
      this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};
      if (!settings.accessToken) {
        this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);
      } else {
        this.accessToken = settings.accessToken;
        this.auth = new Proxy({}, {
          get: (_2, prop) => {
            throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
          }
        });
      }
      this.fetch = (0, fetch_1.fetchWithAuth)(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
      this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, settings.realtime));
      if (this.accessToken) {
        this.accessToken().then((token) => this.realtime.setAuth(token)).catch((e2) => console.warn("Failed to set initial Realtime auth token:", e2));
      }
      this.rest = new postgrest_js_1.PostgrestClient(new URL("rest/v1", baseUrl).href, {
        headers: this.headers,
        schema: settings.db.schema,
        fetch: this.fetch
      });
      this.storage = new storage_js_1.StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);
      if (!settings.accessToken) {
        this._listenForAuthEvents();
      }
    }
    /**
     * Supabase Functions allows you to deploy and invoke edge functions.
     */
    get functions() {
      return new functions_js_1.FunctionsClient(this.functionsUrl.href, {
        headers: this.headers,
        customFetch: this.fetch
      });
    }
    /**
     * Perform a query on a table or a view.
     *
     * @param relation - The table or view name to query
     */
    from(relation) {
      return this.rest.from(relation);
    }
    // NOTE: signatures must be kept in sync with PostgrestClient.schema
    /**
     * Select a schema to query or perform an function (rpc) call.
     *
     * The schema needs to be on the list of exposed schemas inside Supabase.
     *
     * @param schema - The schema to query
     */
    schema(schema) {
      return this.rest.schema(schema);
    }
    // NOTE: signatures must be kept in sync with PostgrestClient.rpc
    /**
     * Perform a function call.
     *
     * @param fn - The function name to call
     * @param args - The arguments to pass to the function call
     * @param options - Named parameters
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     * @param options.get - When set to `true`, the function will be called with
     * read-only access mode.
     * @param options.count - Count algorithm to use to count rows returned by the
     * function. Only applicable for [set-returning
     * functions](https://www.postgresql.org/docs/current/functions-srf.html).
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    rpc(fn, args = {}, options = {
      head: false,
      get: false,
      count: void 0
    }) {
      return this.rest.rpc(fn, args, options);
    }
    /**
     * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
     *
     * @param {string} name - The name of the Realtime channel.
     * @param {Object} opts - The options to pass to the Realtime channel.
     *
     */
    channel(name, opts = { config: {} }) {
      return this.realtime.channel(name, opts);
    }
    /**
     * Returns all Realtime channels.
     */
    getChannels() {
      return this.realtime.getChannels();
    }
    /**
     * Unsubscribes and removes Realtime channel from Realtime client.
     *
     * @param {RealtimeChannel} channel - The name of the Realtime channel.
     *
     */
    removeChannel(channel) {
      return this.realtime.removeChannel(channel);
    }
    /**
     * Unsubscribes and removes all Realtime channels from Realtime client.
     */
    removeAllChannels() {
      return this.realtime.removeAllChannels();
    }
    async _getAccessToken() {
      var _a2, _b;
      if (this.accessToken) {
        return await this.accessToken();
      }
      const { data } = await this.auth.getSession();
      return (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;
    }
    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, throwOnError }, headers, fetch2) {
      const authHeaders = {
        Authorization: `Bearer ${this.supabaseKey}`,
        apikey: `${this.supabaseKey}`
      };
      return new SupabaseAuthClient_1.SupabaseAuthClient({
        url: this.authUrl.href,
        headers: Object.assign(Object.assign({}, authHeaders), headers),
        storageKey,
        autoRefreshToken,
        persistSession,
        detectSessionInUrl,
        storage,
        userStorage,
        flowType,
        lock,
        debug,
        throwOnError,
        fetch: fetch2,
        // auth checks if there is a custom authorizaiton header using this flag
        // so it knows whether to return an error when getUser is called with no session
        hasCustomAuthorizationHeader: Object.keys(this.headers).some((key) => key.toLowerCase() === "authorization")
      });
    }
    _initRealtimeClient(options) {
      return new realtime_js_1.RealtimeClient(this.realtimeUrl.href, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));
    }
    _listenForAuthEvents() {
      const data = this.auth.onAuthStateChange((event, session) => {
        this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
      });
      return data;
    }
    _handleTokenChanged(event, source, token) {
      if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
        this.changedAccessToken = token;
        this.realtime.setAuth(token);
      } else if (event === "SIGNED_OUT") {
        this.realtime.setAuth();
        if (source == "STORAGE")
          this.auth.signOut();
        this.changedAccessToken = void 0;
      }
    }
  }
  SupabaseClient$1.default = SupabaseClient2;
  return SupabaseClient$1;
}
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main;
  hasRequiredMain = 1;
  (function(exports$1) {
    var __createBinding2 = main && main.__createBinding || (Object.create ? (function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    }) : (function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    }));
    var __exportStar2 = main && main.__exportStar || function(m2, exports$12) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p2)) __createBinding2(exports$12, m2, p2);
    };
    var __importDefault2 = main && main.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.createClient = exports$1.SupabaseClient = exports$1.FunctionRegion = exports$1.FunctionsError = exports$1.FunctionsRelayError = exports$1.FunctionsFetchError = exports$1.FunctionsHttpError = exports$1.PostgrestError = void 0;
    const SupabaseClient_1 = __importDefault2(/* @__PURE__ */ requireSupabaseClient());
    __exportStar2(require$$1, exports$1);
    var postgrest_js_1 = requireCjs();
    Object.defineProperty(exports$1, "PostgrestError", { enumerable: true, get: function() {
      return postgrest_js_1.PostgrestError;
    } });
    var functions_js_1 = require$$3$1;
    Object.defineProperty(exports$1, "FunctionsHttpError", { enumerable: true, get: function() {
      return functions_js_1.FunctionsHttpError;
    } });
    Object.defineProperty(exports$1, "FunctionsFetchError", { enumerable: true, get: function() {
      return functions_js_1.FunctionsFetchError;
    } });
    Object.defineProperty(exports$1, "FunctionsRelayError", { enumerable: true, get: function() {
      return functions_js_1.FunctionsRelayError;
    } });
    Object.defineProperty(exports$1, "FunctionsError", { enumerable: true, get: function() {
      return functions_js_1.FunctionsError;
    } });
    Object.defineProperty(exports$1, "FunctionRegion", { enumerable: true, get: function() {
      return functions_js_1.FunctionRegion;
    } });
    __exportStar2(require$$4, exports$1);
    var SupabaseClient_2 = /* @__PURE__ */ requireSupabaseClient();
    Object.defineProperty(exports$1, "SupabaseClient", { enumerable: true, get: function() {
      return __importDefault2(SupabaseClient_2).default;
    } });
    const createClient2 = (supabaseUrl, supabaseKey, options) => {
      return new SupabaseClient_1.default(supabaseUrl, supabaseKey, options);
    };
    exports$1.createClient = createClient2;
    function shouldShowDeprecationWarning() {
      if (typeof window !== "undefined") {
        return false;
      }
      if (typeof process === "undefined") {
        return false;
      }
      const processVersion = process["version"];
      if (processVersion === void 0 || processVersion === null) {
        return false;
      }
      const versionMatch = processVersion.match(/^v(\d+)\./);
      if (!versionMatch) {
        return false;
      }
      const majorVersion = parseInt(versionMatch[1], 10);
      return majorVersion <= 18;
    }
    if (shouldShowDeprecationWarning()) {
      console.warn(`  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217`);
    }
  })(main);
  return main;
}
var mainExports = /* @__PURE__ */ requireMain();
const index = /* @__PURE__ */ getDefaultExportFromCjs(mainExports);
const index$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [mainExports]);
const {
  PostgrestError,
  FunctionsHttpError: FunctionsHttpError2,
  FunctionsFetchError: FunctionsFetchError2,
  FunctionsRelayError: FunctionsRelayError2,
  FunctionsError: FunctionsError2,
  FunctionRegion,
  SupabaseClient,
  createClient,
  GoTrueAdminApi: GoTrueAdminApi2,
  GoTrueClient: GoTrueClient2,
  AuthAdminApi,
  AuthClient,
  navigatorLock,
  NavigatorLockAcquireTimeoutError: NavigatorLockAcquireTimeoutError2,
  lockInternals,
  processLock,
  SIGN_OUT_SCOPES,
  AuthError: AuthError2,
  AuthApiError: AuthApiError2,
  AuthUnknownError: AuthUnknownError2,
  CustomAuthError: CustomAuthError2,
  AuthSessionMissingError: AuthSessionMissingError2,
  AuthInvalidTokenResponseError: AuthInvalidTokenResponseError2,
  AuthInvalidCredentialsError: AuthInvalidCredentialsError2,
  AuthImplicitGrantRedirectError: AuthImplicitGrantRedirectError2,
  AuthPKCEGrantCodeExchangeError: AuthPKCEGrantCodeExchangeError2,
  AuthRetryableFetchError: AuthRetryableFetchError2,
  AuthWeakPasswordError: AuthWeakPasswordError2,
  AuthInvalidJwtError: AuthInvalidJwtError2,
  isAuthError,
  isAuthApiError,
  isAuthSessionMissingError,
  isAuthImplicitGrantRedirectError,
  isAuthRetryableFetchError,
  isAuthWeakPasswordError,
  RealtimePresence: RealtimePresence2,
  RealtimeChannel: RealtimeChannel2,
  RealtimeClient: RealtimeClient2,
  REALTIME_LISTEN_TYPES,
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT,
  REALTIME_PRESENCE_LISTEN_EVENTS,
  REALTIME_SUBSCRIBE_STATES,
  REALTIME_CHANNEL_STATES
} = index || index$1;
var define_process_env_default$1 = {};
class SupabaseContext {
  constructor(tableName) {
    const supabaseUrl = "https://kbwrcqhogrwjzhutbqew.supabase.co";
    let supabaseKey = "";
    {
      supabaseKey = define_process_env_default$1.VITE_SUPABASE_KEY || define_process_env_default$1.SUPABASE_KEY || "";
    }
    if (!supabaseKey) {
      throw new Error("Supabase key is required. Set VITE_SUPABASE_KEY or SUPABASE_KEY environment variable.");
    }
    this.supabase = createClient(supabaseUrl, supabaseKey);
    this.tableName = tableName;
  }
  // Field mapping utilities for camelCase  snake_case conversion
  toSnakeCase(str) {
    return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }
  toCamelCase(str) {
    return str.replace(/_([a-z])/g, (_2, letter) => letter.toUpperCase());
  }
  mapObjectToSnakeCase(obj) {
    if (obj === null || obj === void 0 || typeof obj !== "object") {
      return obj;
    }
    if (obj instanceof Date) {
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => this.mapObjectToSnakeCase(item));
    }
    const mapped = {};
    for (const [key, value] of Object.entries(obj)) {
      const snakeKey = this.toSnakeCase(key);
      mapped[snakeKey] = this.mapObjectToSnakeCase(value);
    }
    return mapped;
  }
  mapObjectToCamelCase(obj) {
    if (obj === null || obj === void 0 || typeof obj !== "object") {
      return obj;
    }
    if (obj instanceof Date) {
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => this.mapObjectToCamelCase(item));
    }
    const mapped = {};
    for (const [key, value] of Object.entries(obj)) {
      const camelKey = this.toCamelCase(key);
      mapped[camelKey] = this.mapObjectToCamelCase(value);
    }
    return mapped;
  }
  async ensureTableExists(sampleItem) {
    try {
      const { error: testError } = await this.supabase.from(this.tableName).select("*").limit(1);
      if (testError && testError.code === "42P01") {
        throw new Error(`Table '${this.tableName}' does not exist. Please create it using database migrations or Supabase dashboard.`);
      }
    } catch (error2) {
      if (error2 instanceof Error && error2.message.includes("does not exist")) {
        throw error2;
      }
    }
  }
  // IRepository interface implementation
  async get(id) {
    try {
      const idString = String(id);
      const { data, error: error2 } = await this.supabase.from(this.tableName).select("*").eq("id", idString).single();
      if (error2) {
        if (error2.code === "PGRST116") {
          throw new Error(`Item with id ${id} not found`);
        }
        throw new Error(`Failed to get item: ${error2.message}`);
      }
      return this.mapObjectToCamelCase(data);
    } catch (error2) {
      throw new Error(`Repository get operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async getAll() {
    try {
      const { data, error: error2 } = await this.supabase.from(this.tableName).select("*");
      if (error2) {
        throw new Error(`Failed to get all items: ${error2.message}`);
      }
      return this.mapObjectToCamelCase(data || []);
    } catch (error2) {
      throw new Error(`Repository getAll operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async add(item) {
    try {
      await this.ensureTableExists(item);
      const dbItem = this.mapObjectToSnakeCase(item);
      const { data, error: error2 } = await this.supabase.from(this.tableName).insert([dbItem]).select().single();
      if (error2) {
        if (error2.code === "42P01") {
          throw new Error(`Table '${this.tableName}' does not exist. Please create it using the SQL schema provided in sql/article.sql`);
        }
        throw new Error(`Failed to add item: ${error2.message}`);
      }
      return this.mapObjectToCamelCase(data);
    } catch (error2) {
      throw new Error(`Repository add operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async addRange(...items) {
    try {
      if (items.length === 0) {
        return 0;
      }
      await this.ensureTableExists(items[0]);
      const dbItems = items.map((item) => this.mapObjectToSnakeCase(item));
      const { data, error: error2 } = await this.supabase.from(this.tableName).insert(dbItems).select();
      if (error2) {
        if (error2.code === "42P01") {
          throw new Error(`Table '${this.tableName}' does not exist. Please create it using the SQL schema provided in sql/article.sql`);
        }
        throw new Error(`Failed to add items: ${error2.message}`);
      }
      return (data || []).length;
    } catch (error2) {
      throw new Error(`Repository addRange operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async remove(item) {
    try {
      const itemWithId = item;
      if (!itemWithId.id) {
        throw new Error("Item must have an id property for removal");
      }
      const { error: error2 } = await this.supabase.from(this.tableName).delete().eq("id", itemWithId.id);
      if (error2) {
        throw new Error(`Failed to remove item: ${error2.message}`);
      }
      return 1;
    } catch (error2) {
      throw new Error(`Repository remove operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async removeRange(...items) {
    try {
      if (items.length === 0) {
        return 0;
      }
      const { error: error2 } = await this.supabase.from(this.tableName).delete().in("id", items.map(String));
      if (error2) {
        throw new Error(`Failed to remove items: ${error2.message}`);
      }
      return items.length;
    } catch (error2) {
      throw new Error(`Repository removeRange operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async find(gql) {
    try {
      let query = this.supabase.from(this.tableName).select("*");
      if (gql && typeof gql === "object") {
        const dbQuery = this.mapObjectToSnakeCase(gql);
        Object.entries(dbQuery).forEach(([key, value]) => {
          if (value !== void 0 && value !== null) {
            query = query.eq(key, value);
          }
        });
      }
      const { data, error: error2 } = await query;
      if (error2) {
        throw new Error(`Failed to find items: ${error2.message}`);
      }
      return this.mapObjectToCamelCase(data || []);
    } catch (error2) {
      throw new Error(`Repository find operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async count() {
    try {
      const { count, error: error2 } = await this.supabase.from(this.tableName).select("*", { count: "exact", head: true });
      if (error2) {
        throw new Error(`Failed to count items: ${error2.message}`);
      }
      return count || 0;
    } catch (error2) {
      throw new Error(`Repository count operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async serverFun(fun, gql) {
    try {
      const { data, error: error2 } = await this.supabase.rpc(fun, gql || {});
      if (error2) {
        throw new Error(`Failed to execute server function: ${error2.message}`);
      }
      return data;
    } catch (error2) {
      throw new Error(`Repository serverFun operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  // Additional update method for better performance (not part of IRepository interface)
  async update(item) {
    try {
      const itemWithId = item;
      if (!itemWithId.id) {
        throw new Error("Item must have an id property for update");
      }
      const dbItem = this.mapObjectToSnakeCase(item);
      const { id, ...updateData } = dbItem;
      const { data, error: error2 } = await this.supabase.from(this.tableName).update(updateData).eq("id", itemWithId.id).select().single();
      if (error2) {
        if (error2.code === "PGRST116") {
          throw new Error(`Item with id ${itemWithId.id} not found for update`);
        }
        throw new Error(`Failed to update item: ${error2.message}`);
      }
      return this.mapObjectToCamelCase(data);
    } catch (error2) {
      throw new Error(`Repository update operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  // Additional utility methods (not part of IRepository interface)
  async getTableStats() {
    const total = await this.count();
    return {
      total,
      size: "N/A"
      // Supabase doesn't expose table size directly
    };
  }
  /**
   * Update item by ID with optional custom id field name (IRepository interface)
   * @param id - The ID value to match
   * @param updates - Partial item with fields to update
   * @param idField - Optional custom id field name (defaults to 'id')
   */
  async updateById(id, updates, idField) {
    try {
      const dbUpdates = this.mapObjectToSnakeCase(updates);
      const dbIdField = idField ? this.toSnakeCase(idField) : "id";
      const { data, error: error2 } = await this.supabase.from(this.tableName).update(dbUpdates).eq(dbIdField, id).select().single();
      if (error2) {
        if (error2.code === "PGRST116") {
          throw new Error(`Item with ${idField || "id"} ${id} not found for update`);
        }
        throw new Error(`Failed to update item: ${error2.message}`);
      }
      return this.mapObjectToCamelCase(data);
    } catch (error2) {
      throw new Error(`Repository update operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  /**
   * Delete item by ID with optional custom id field name (IRepository interface)
   * @param id - The ID value to match
   * @param idField - Optional custom id field name (defaults to 'id')
   */
  async deleteById(id, idField) {
    try {
      const dbIdField = idField ? this.toSnakeCase(idField) : "id";
      const { error: error2 } = await this.supabase.from(this.tableName).delete().eq(dbIdField, id);
      if (error2) {
        throw new Error(`Failed to delete item: ${error2.message}`);
      }
      return true;
    } catch (error2) {
      throw new Error(`Repository deleteById operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  subscribeToChanges(callback, filter) {
    const channel = this.supabase.channel(`${this.tableName}_changes`).on(
      "postgres_changes",
      {
        event: "*",
        schema: "public",
        table: this.tableName,
        filter
      },
      (payload) => {
        callback({
          eventType: payload.eventType,
          new: payload.new ? this.mapObjectToCamelCase(payload.new) : void 0,
          old: payload.old ? this.mapObjectToCamelCase(payload.old) : void 0
        });
      }
    ).subscribe();
    return () => {
      this.supabase.removeChannel(channel);
    };
  }
}
class PWAContext {
  constructor(tableName, dbName = "tldr_pwa", options = {}) {
    this.syncInProgress = false;
    this.syncQueue = /* @__PURE__ */ new Set();
    this.lastSyncTime = null;
    this.syncInterval = 3e4;
    this.syncTimer = null;
    this.localRepo = new IndexedDBContext(dbName, tableName);
    this.remoteRepo = new SupabaseContext(tableName);
    if (options.syncInterval) {
      this.syncInterval = options.syncInterval;
    }
    if (options.enableAutoSync !== false) {
      this.startAutoSync();
    }
    if (typeof window !== "undefined") {
      window.addEventListener("online", () => this.handleOnlineEvent());
      window.addEventListener("beforeunload", () => this.stopAutoSync());
    }
  }
  // IRepository interface implementation - all operations go through IndexedDB first
  async get(id) {
    try {
      const result = await this.localRepo.get(id);
      this.queueForSync(String(id));
      return result;
    } catch (error2) {
      if (navigator.onLine) {
        try {
          const remoteItem = await this.remoteRepo.get(id);
          await this.localRepo.add(remoteItem);
          return remoteItem;
        } catch (remoteError) {
          throw error2;
        }
      }
      throw error2;
    }
  }
  async getAll() {
    const localItems = await this.localRepo.getAll();
    this.scheduleSync();
    return localItems;
  }
  async add(item) {
    const itemWithTimestamp = {
      ...item,
      updatedAt: /* @__PURE__ */ new Date()
    };
    const localResult = await this.localRepo.add(itemWithTimestamp);
    this.queueForSync(itemWithTimestamp.id);
    if (navigator.onLine) {
      this.syncSingle(itemWithTimestamp.id).catch((error2) => {
        console.warn("Background sync failed:", error2);
      });
    }
    return localResult;
  }
  async addRange(...items) {
    const itemsWithTimestamps = items.map((item) => ({
      ...item,
      updatedAt: /* @__PURE__ */ new Date()
    }));
    const result = await this.localRepo.addRange(...itemsWithTimestamps);
    itemsWithTimestamps.forEach((item) => this.queueForSync(item.id));
    if (navigator.onLine) {
      this.scheduleSync();
    }
    return result;
  }
  async remove(item) {
    const result = await this.localRepo.remove(item);
    if (navigator.onLine) {
      this.remoteRepo.remove(item).catch((error2) => {
        console.warn("Remote removal failed:", error2);
      });
    }
    return result;
  }
  async removeRange(...items) {
    const result = await this.localRepo.removeRange(...items);
    if (navigator.onLine) {
      this.remoteRepo.removeRange(...items).catch((error2) => {
        console.warn("Remote bulk removal failed:", error2);
      });
    }
    return result;
  }
  async find(gql) {
    const localResults = await this.localRepo.find(gql);
    this.scheduleSync();
    return localResults;
  }
  async count() {
    return await this.localRepo.count();
  }
  async serverFun(fun, gql) {
    if (!navigator.onLine) {
      throw new Error("Server functions require internet connection");
    }
    return await this.remoteRepo.serverFun(fun, gql);
  }
  // Sync management methods
  /**
   * Force immediate synchronization between local and remote repositories
   */
  async forceSync() {
    if (!navigator.onLine) {
      console.warn("Cannot sync while offline");
      return;
    }
    await this.performFullSync();
  }
  /**
   * Get sync status information
   */
  getSyncStatus() {
    return {
      inProgress: this.syncInProgress,
      lastSync: this.lastSyncTime,
      queueSize: this.syncQueue.size,
      isOnline: navigator.onLine
    };
  }
  /**
   * Stop automatic synchronization (useful for cleanup)
   */
  stopAutoSync() {
    if (this.syncTimer) {
      clearInterval(this.syncTimer);
      this.syncTimer = null;
    }
  }
  // Private sync implementation
  startAutoSync() {
    if (navigator.onLine) {
      this.scheduleSync();
    }
    this.syncTimer = setInterval(() => {
      if (navigator.onLine && !this.syncInProgress) {
        this.performFullSync().catch((error2) => {
          console.warn("Scheduled sync failed:", error2);
        });
      }
    }, this.syncInterval);
  }
  scheduleSync() {
    setTimeout(() => {
      if (navigator.onLine && !this.syncInProgress) {
        this.performFullSync().catch((error2) => {
          console.warn("Scheduled sync failed:", error2);
        });
      }
    }, 1e3);
  }
  queueForSync(id) {
    this.syncQueue.add(id);
  }
  async syncSingle(id) {
    try {
      const localItem = await this.localRepo.get(Number(id));
      try {
        const remoteItem = await this.remoteRepo.get(Number(id));
        if (localItem.updatedAt > remoteItem.updatedAt) {
          await this.remoteRepo.add(localItem);
        } else if (remoteItem.updatedAt > localItem.updatedAt) {
          await this.localRepo.add(remoteItem);
        }
      } catch (error2) {
        await this.remoteRepo.add(localItem);
      }
      this.syncQueue.delete(id);
    } catch (error2) {
      console.warn(`Failed to sync item ${id}:`, error2);
    }
  }
  async performFullSync() {
    if (this.syncInProgress) {
      return;
    }
    this.syncInProgress = true;
    try {
      await this.syncRepositories();
      this.lastSyncTime = /* @__PURE__ */ new Date();
      this.syncQueue.clear();
    } catch (error2) {
      console.error("Full sync failed:", error2);
      throw error2;
    } finally {
      this.syncInProgress = false;
    }
  }
  async syncRepositories() {
    const [localItems, remoteItems] = await Promise.all([
      this.localRepo.getAll(),
      this.remoteRepo.getAll()
    ]);
    const localMap = new Map(localItems.map((item) => [item.id, item]));
    const remoteMap = new Map(remoteItems.map((item) => [item.id, item]));
    const toUpdateRemote = [];
    const toUpdateLocal = [];
    const toAddToRemote = [];
    const toAddToLocal = [];
    for (const [id, localItem] of localMap.entries()) {
      const remoteItem = remoteMap.get(id);
      if (!remoteItem) {
        toAddToRemote.push(localItem);
      } else {
        const localTime = new Date(localItem.updatedAt).getTime();
        const remoteTime = new Date(remoteItem.updatedAt).getTime();
        if (localTime > remoteTime) {
          toUpdateRemote.push(localItem);
        } else if (remoteTime > localTime) {
          toUpdateLocal.push(remoteItem);
        }
      }
    }
    for (const [id, remoteItem] of remoteMap.entries()) {
      if (!localMap.has(id)) {
        toAddToLocal.push(remoteItem);
      }
    }
    const syncPromises = [];
    if (toAddToRemote.length > 0) {
      syncPromises.push(this.remoteRepo.addRange(...toAddToRemote));
    }
    toUpdateRemote.forEach((item) => {
      syncPromises.push(this.remoteRepo.add(item));
    });
    if (toAddToLocal.length > 0) {
      syncPromises.push(this.localRepo.addRange(...toAddToLocal));
    }
    toUpdateLocal.forEach((item) => {
      syncPromises.push(this.localRepo.add(item));
    });
    await Promise.all(syncPromises);
  }
  handleOnlineEvent() {
    if (this.syncQueue.size > 0 || this.lastSyncTime === null) {
      this.scheduleSync();
    }
  }
  /**
   * Update an item by ID with optional custom ID field name
   * @param id - The ID value to match
   * @param updates - Partial updates to apply
   * @param idField - Optional custom ID field name (defaults to 'id')
   * @returns The updated item
   */
  async update(id, updates, idField) {
    const updatedItem = await this.localRepo.update(id, updates, idField);
    if (navigator.onLine) {
      try {
        await this.remoteRepo.update(id, updates, idField);
      } catch (error2) {
        this.queueForSync("update", { id, updates, idField });
      }
    } else {
      this.queueForSync("update", { id, updates, idField });
    }
    return updatedItem;
  }
  /**
   * Delete an item by ID with optional custom ID field name
   * @param id - The ID value to match
   * @param idField - Optional custom ID field name (defaults to 'id')
   * @returns True if deletion was successful
   */
  async deleteById(id, idField) {
    const success = await this.localRepo.deleteById(id, idField);
    if (navigator.onLine) {
      try {
        await this.remoteRepo.deleteById(id, idField);
      } catch (error2) {
        this.queueForSync("delete", { id, idField });
      }
    } else {
      this.queueForSync("delete", { id, idField });
    }
    return success;
  }
}
class Repository {
  constructor(context) {
    this.context = context;
  }
  async get(id) {
    return await this.context.get(id);
  }
  async getAll() {
    return await this.context.getAll();
  }
  async add(item) {
    return await this.context.add(item);
  }
  async addRange(...items) {
    return await this.context.addRange(...items);
  }
  async remove(item) {
    return await this.context.remove(item);
  }
  async removeRange(...items) {
    return await this.context.removeRange(...items);
  }
  async find(gql) {
    return await this.context.find(gql);
  }
  async count() {
    return await this.context.count();
  }
  async serverFun(fun, gql) {
    return await this.context.serverFun(fun, gql);
  }
  async update(id, item, idField) {
    return await this.context.update(id, item, idField);
  }
  async deleteById(id, idField) {
    return await this.context.deleteById(id, idField);
  }
}
async function seedEmployee(employee) {
  return await employeeRepository.add(employee);
}
async function seedManager(manager) {
  return await managerRepository.add(manager);
}
async function seedUser(user) {
  return await userRepository.add(user);
}
async function createUserAndLogin(domainServices2, user) {
  await domainServices2.createUser(user);
  await domainServices2.login({ email: user.email, password: user.password });
}
async function seedBusinessGoal(businessGoal) {
  return await businessGoalRepository.add(businessGoal);
}
async function seedGoal(goal) {
  return await goalRepository.add(goal);
}
async function seedDevelopmentPlan(plan) {
  return await developmentPlanRepository.add(plan);
}
async function seedAppraisalPeriod(period) {
  return await appraisalPeriodRepository.add(period);
}
async function seedGoalProgress(progress) {
  return await goalProgressRepository.createGoalProgress(progress);
}
async function seedSurvey(survey) {
  return await feedbackRepository.add({
    ...survey,
    feedback_type: "survey"
  });
}
async function seedSurveyResponse(response) {
  return await feedbackRepository.add({
    ...response,
    feedback_type: "survey_response"
  });
}
async function seedPerformanceMetric(metric) {
  return await performanceMetricRepository.add(metric);
}
async function seedPerformanceReview(review) {
  return await performanceReviewRepository.add(review);
}
async function seedPerformanceCriteria(criteria) {
  return await performanceCriteriaRepository.add(criteria);
}
async function seedDepartment(department) {
  return await departmentRepository.add(department);
}
const testFixtures = {
  // ========== Demo Users (Manual Testing & App Runtime) ==========
  // These users are auto-seeded on first login for manual testing without test framework
  demoUsers: [
    {
      email: "admin@nshrm.com",
      password: "admin123",
      userType: "admin",
      name: "System Admin",
      employeeID: "EMP0001",
      firstname: "System",
      lastname: "Admin"
    },
    {
      email: "admin.test.2025@nshrm.com",
      password: "AdminPass123!",
      userType: "admin",
      name: "Test Admin",
      employeeID: "EMP001",
      firstname: "Admin",
      lastname: "Test"
    },
    {
      email: "manager@nshrm.com",
      password: "manager123",
      userType: "manager",
      name: "Department Manager",
      employeeID: "EMP0003",
      firstname: "Department",
      lastname: "Manager"
    },
    {
      email: "manager.test.2025@nshrm.com",
      password: "ManagerPass123!",
      userType: "manager",
      name: "Manager Test User",
      employeeID: "MGR001",
      firstname: "Manager",
      lastname: "Test"
    },
    {
      email: "employee@nshrm.com",
      password: "employee123",
      userType: "employee",
      name: "John Employee",
      employeeID: "EMP0004",
      firstname: "John",
      lastname: "Employee"
    },
    {
      email: "employee.test.2025@nshrm.com",
      password: "EmployeePass123!",
      userType: "employee",
      name: "Employee Test User",
      employeeID: "EMP002",
      firstname: "Employee",
      lastname: "Test"
    }
  ],
  // ========== Goal Workflow Fixtures (Approval Tracking Demo) ==========
  // Complete workflow: Create Goal  Submit  Manager Review  Approve  Track Progress
  goalWorkflowEmployee: {
    employeeID: "EMP-GOAL-001",
    title: "Mr",
    firstname: "Goal",
    lastname: "Tracker",
    gender: "Male",
    phonenumber: "5551112222",
    email: "goal.tracker@nshrm.com",
    address: "100 Goal Street",
    ethnicity: "Other",
    deptcode: "DEPT-GOAL",
    managerID: "MGR-GOAL-001",
    job_role: "Software Developer",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2023-01-15")).toISOString(),
    branch: "HQ",
    training: "Agile",
    certification: "Scrum",
    skills: "JavaScript, React, Node.js",
    interests: "Performance Improvement",
    status: "active"
  },
  goalWorkflowEmployeeUser: {
    userID: "USER-GOAL-001",
    employeeID: "EMP-GOAL-001",
    email: "goal.tracker@nshrm.com",
    password: "GoalTracker123!",
    securecode: "",
    userType: "employee",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  goalWorkflowManager: {
    employeeID: "MGR-GOAL-001",
    title: "Ms",
    firstname: "Goal",
    lastname: "Approver",
    gender: "Female",
    phonenumber: "5553334444",
    email: "goal.approver@nshrm.com",
    address: "200 Manager Ave",
    ethnicity: "Other",
    deptcode: "DEPT-GOAL",
    managerID: "EXEC001",
    job_role: "Engineering Manager",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2020-06-01")).toISOString(),
    branch: "HQ",
    training: "Leadership",
    certification: "PMP",
    skills: "Management, Coaching, Technical Leadership",
    interests: "Team Development",
    status: "active"
  },
  goalWorkflowManagerUser: {
    userID: "USER-MGR-GOAL-001",
    employeeID: "MGR-GOAL-001",
    email: "goal.approver@nshrm.com",
    password: "GoalApprover123!",
    securecode: "",
    userType: "manager",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  goalWorkflowDepartment: {
    dept_id: "DEPT-GOAL",
    dept_name: "Engineering",
    dept_head: "MGR-GOAL-001",
    description: "Software Engineering Department",
    budget: 75e4,
    headcount: 12
  },
  goalWorkflowAppraisalPeriod: {
    period_id: "AP-2025-Q1",
    period_name: "Q1 2025 Performance Cycle",
    start_date: (/* @__PURE__ */ new Date("2025-01-01")).toISOString(),
    end_date: (/* @__PURE__ */ new Date("2025-03-31")).toISOString(),
    status: "active",
    description: "First quarter performance appraisal period"
  },
  goalWorkflowBusinessGoal: {
    busgoal_id: "BG-2025-001",
    busgoal_title: "Improve Product Quality",
    busgoal_description: "Reduce defect rate by 30% through improved testing practices",
    department: "DEPT-GOAL",
    fiscal_year: "2025",
    target_metric: "defect_rate",
    target_value: 30,
    current_value: 0,
    status: "active",
    priority: "high",
    owner: "MGR-GOAL-001",
    created_date: (/* @__PURE__ */ new Date()).toISOString()
  },
  // Individual Goals - Different States for Demo
  goalPendingApproval: {
    goalID: 1001,
    busgoal: "BG-2025-001",
    employee: "EMP-GOAL-001",
    ID: "GOAL-PEND-001",
    goal_title: "Implement Unit Testing Framework",
    goal_description: "Set up Jest testing framework with 80% code coverage target",
    key_result: "Achieve 80% code coverage on core modules",
    projected_start_date: (/* @__PURE__ */ new Date("2025-01-15")).toISOString(),
    projected_target_date: (/* @__PURE__ */ new Date("2025-02-28")).toISOString(),
    actual_start_date: null,
    actual_completion_date: null,
    goal_progress: 0,
    goal_status: "pending",
    approval: 0,
    // Not yet approved
    appraisal_period: "AP-2025-Q1",
    date_modified: (/* @__PURE__ */ new Date()).toISOString()
  },
  goalApproved: {
    goalID: 1002,
    busgoal: "BG-2025-001",
    employee: "EMP-GOAL-001",
    ID: "GOAL-APPR-001",
    goal_title: "Reduce API Response Time",
    goal_description: "Optimize database queries to reduce average API response time to under 200ms",
    key_result: "Average API response time < 200ms",
    projected_start_date: (/* @__PURE__ */ new Date("2025-01-01")).toISOString(),
    projected_target_date: (/* @__PURE__ */ new Date("2025-03-15")).toISOString(),
    actual_start_date: (/* @__PURE__ */ new Date("2025-01-05")).toISOString(),
    actual_completion_date: null,
    goal_progress: 45,
    goal_status: "in_progress",
    approval: 1,
    // Approved by manager
    appraisal_period: "AP-2025-Q1",
    date_modified: (/* @__PURE__ */ new Date()).toISOString()
  },
  goalCompleted: {
    goalID: 1003,
    busgoal: "BG-2025-001",
    employee: "EMP-GOAL-001",
    ID: "GOAL-COMP-001",
    goal_title: "Complete Security Audit",
    goal_description: "Conduct comprehensive security audit and fix all critical vulnerabilities",
    key_result: "Zero critical vulnerabilities in production",
    projected_start_date: (/* @__PURE__ */ new Date("2025-01-01")).toISOString(),
    projected_target_date: (/* @__PURE__ */ new Date("2025-01-31")).toISOString(),
    actual_start_date: (/* @__PURE__ */ new Date("2025-01-02")).toISOString(),
    actual_completion_date: (/* @__PURE__ */ new Date("2025-01-28")).toISOString(),
    goal_progress: 100,
    goal_status: "completed",
    approval: 1,
    appraisal_period: "AP-2025-Q1",
    date_modified: (/* @__PURE__ */ new Date()).toISOString()
  },
  // Goal Progress Tracking Records
  goalProgressRecords: [
    {
      progressID: 2001,
      goalID: 1002,
      // Links to goalApproved
      progress_percentage: 15,
      progress_notes: "Completed initial database query analysis. Identified 5 slow queries.",
      milestones_completed: "Query Analysis",
      progress_date: (/* @__PURE__ */ new Date("2025-01-10")).toISOString(),
      updated_by: "EMP-GOAL-001"
    },
    {
      progressID: 2002,
      goalID: 1002,
      progress_percentage: 30,
      progress_notes: "Optimized 3 of 5 slow queries. Average response time reduced from 450ms to 280ms.",
      milestones_completed: "Query Analysis, Initial Optimization",
      progress_date: (/* @__PURE__ */ new Date("2025-01-20")).toISOString(),
      updated_by: "EMP-GOAL-001"
    },
    {
      progressID: 2003,
      goalID: 1002,
      progress_percentage: 45,
      progress_notes: "Added database indexes and caching layer. Response time now at 220ms average.",
      milestones_completed: "Query Analysis, Initial Optimization, Indexing",
      progress_date: (/* @__PURE__ */ new Date("2025-01-30")).toISOString(),
      updated_by: "EMP-GOAL-001"
    }
  ],
  // Development Plan linked to goals
  goalWorkflowDevelopmentPlan: {
    plan_id: "DP-GOAL-001",
    employee_id: "EMP-GOAL-001",
    plan_title: "Q1 2025 Development Plan",
    description: "Focus on testing skills and performance optimization techniques",
    goals: ["GOAL-PEND-001", "GOAL-APPR-001", "GOAL-COMP-001"],
    skills_to_develop: ["Unit Testing", "Performance Optimization", "Security Best Practices"],
    training_required: ["Jest Masterclass", "Database Optimization Workshop"],
    mentor: "MGR-GOAL-001",
    start_date: (/* @__PURE__ */ new Date("2025-01-01")).toISOString(),
    target_completion: (/* @__PURE__ */ new Date("2025-03-31")).toISOString(),
    status: "in_progress",
    created_date: (/* @__PURE__ */ new Date()).toISOString()
  },
  // ========== Survey Manager Fixtures (Module 6) ==========
  surveyEmployee: {
    employeeID: "EMP-SURVEY-001",
    title: "Mr",
    firstname: "Survey",
    lastname: "Employee",
    gender: "Male",
    phonenumber: "9876543210",
    email: "survey.employee@nshrm.com",
    address: "456 Survey Ave",
    ethnicity: "Other",
    deptcode: "DEPT002",
    managerID: "MGR002",
    job_role: "Analyst",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2024-01-15")).toISOString(),
    branch: "HQ",
    training: "",
    certification: "",
    skills: "Data Analysis, Surveys",
    interests: "Analytics",
    status: "active"
  },
  surveyEmployeeUser: {
    userID: "USER-SURVEY-001",
    employeeID: "EMP-SURVEY-001",
    email: "survey.employee@nshrm.com",
    password: "SurveyPass123!",
    securecode: "",
    userType: "employee",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  survey: {
    survey_id: "SURVEY001",
    survey_title: "Employee Engagement Survey 2024",
    survey_description: "Annual employee engagement and satisfaction assessment",
    survey_type: "engagement",
    target_audience: "DEPT002",
    start_date: (/* @__PURE__ */ new Date()).toISOString(),
    end_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3).toISOString(),
    status: "active",
    anonymity: 1,
    created_by: "ADMIN001",
    created_date: (/* @__PURE__ */ new Date()).toISOString(),
    question_count: 5,
    questions: [
      { q_id: "Q1", question_text: "How satisfied are you with your role?", type: "rating", scale: 5, mandatory: true },
      { q_id: "Q2", question_text: "Do you have clear career development goals?", type: "yes_no", mandatory: true },
      { q_id: "Q3", question_text: "How effective is your manager?", type: "rating", scale: 5 },
      { q_id: "Q4", question_text: "What areas need improvement?", type: "text" },
      { q_id: "Q5", question_text: "Would you recommend this company?", type: "rating", scale: 5 }
    ]
  },
  surveyResponse: {
    response_id: "RESPONSE001",
    survey_id: "SURVEY001",
    employee_id: "EMP-SURVEY-001",
    submission_date: (/* @__PURE__ */ new Date()).toISOString(),
    responses: [
      { q_id: "Q1", answer: "5", answer_type: "rating" },
      { q_id: "Q2", answer: "yes", answer_type: "yes_no" },
      { q_id: "Q3", answer: "4", answer_type: "rating" },
      { q_id: "Q4", answer: "More remote work flexibility", answer_type: "text" },
      { q_id: "Q5", answer: "5", answer_type: "rating" }
    ],
    status: "submitted",
    completion_percentage: 100
  },
  // Additional fixtures for independent survey tests
  surveyEmployee2: {
    employeeID: "EMP-SURVEY-002",
    title: "Ms",
    firstname: "Survey",
    lastname: "Validator",
    gender: "Female",
    phonenumber: "9876543211",
    email: "survey.validator@nshrm.com",
    address: "457 Survey Ave",
    ethnicity: "Other",
    deptcode: "DEPT002",
    managerID: "MGR002",
    job_role: "Quality Analyst",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2024-02-01")).toISOString(),
    branch: "HQ",
    training: "",
    certification: "",
    skills: "Quality Assurance",
    interests: "Testing",
    status: "active"
  },
  surveyEmployee2User: {
    userID: "USER-SURVEY-002",
    employeeID: "EMP-SURVEY-002",
    email: "survey.validator@nshrm.com",
    password: "ValidatorPass123!",
    securecode: "",
    userType: "employee",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  survey2: {
    survey_id: "SURVEY002",
    survey_title: "Compliance Training Survey",
    survey_description: "Annual compliance training assessment",
    survey_type: "compliance",
    target_audience: "DEPT002",
    start_date: (/* @__PURE__ */ new Date()).toISOString(),
    end_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3).toISOString(),
    status: "active",
    anonymity: 1,
    created_by: "ADMIN001",
    created_date: (/* @__PURE__ */ new Date()).toISOString(),
    question_count: 5,
    questions: [
      { q_id: "Q1", question_text: "Completed compliance training?", type: "yes_no", mandatory: true },
      { q_id: "Q2", question_text: "Understand policies?", type: "yes_no", mandatory: true },
      { q_id: "Q3", question_text: "Overall rating", type: "rating", scale: 5 },
      { q_id: "Q4", question_text: "Comments", type: "text" },
      { q_id: "Q5", question_text: "Will apply knowledge?", type: "yes_no", mandatory: true }
    ]
  },
  surveyResponse2: {
    response_id: "RESPONSE002",
    survey_id: "SURVEY002",
    employee_id: "EMP-SURVEY-002",
    submission_date: (/* @__PURE__ */ new Date()).toISOString(),
    responses: [
      { q_id: "Q1", answer: "yes", answer_type: "yes_no" },
      { q_id: "Q2", answer: "yes", answer_type: "yes_no" },
      { q_id: "Q3", answer: "5", answer_type: "rating" },
      { q_id: "Q4", answer: "Very informative", answer_type: "text" },
      { q_id: "Q5", answer: "yes", answer_type: "yes_no" }
    ],
    status: "submitted",
    completion_percentage: 100
  },
  // ========== Report Manager Fixtures (Module 7) ==========
  reportManager: {
    employeeID: "MGR-REPORT-001",
    title: "Mr",
    firstname: "Report",
    lastname: "Manager",
    gender: "Male",
    phonenumber: "5551234567",
    email: "manager.report@nshrm.com",
    address: "789 Manager Blvd",
    ethnicity: "Other",
    deptcode: "DEPT-REPORT",
    managerID: "EXEC001",
    job_role: "Department Manager",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2023-06-01")).toISOString(),
    branch: "HQ",
    training: "Leadership",
    certification: "PMP",
    skills: "Management, Analytics, Reporting",
    interests: "Strategic Planning",
    status: "active"
  },
  reportManagerUser: {
    userID: "USER-REPORT-MGR-001",
    employeeID: "MGR-REPORT-001",
    email: "manager.report@nshrm.com",
    password: "ManagerPass123!",
    securecode: "",
    userType: "manager",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  reportEmployee1: {
    employeeID: "EMP-REPORT-001",
    title: "Ms",
    firstname: "Alice",
    lastname: "Report",
    gender: "Female",
    phonenumber: "5559876543",
    email: "alice.report@nshrm.com",
    address: "123 Report Lane",
    ethnicity: "Other",
    deptcode: "DEPT-REPORT",
    managerID: "MGR-REPORT-001",
    job_role: "Senior Analyst",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2023-09-01")).toISOString(),
    branch: "HQ",
    training: "Data Analysis",
    certification: "Tableau",
    skills: "Analytics, SQL, Python",
    interests: "Data Science",
    status: "active"
  },
  reportEmployee2: {
    employeeID: "EMP-REPORT-002",
    title: "Mr",
    firstname: "Bob",
    lastname: "Report",
    gender: "Male",
    phonenumber: "5554443333",
    email: "bob.report@nshrm.com",
    address: "456 Report Ave",
    ethnicity: "Other",
    deptcode: "DEPT-REPORT",
    managerID: "MGR-REPORT-001",
    job_role: "Analyst",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2024-02-15")).toISOString(),
    branch: "HQ",
    training: "Python",
    certification: "",
    skills: "Python, Excel, Analytics",
    interests: "Machine Learning",
    status: "active"
  },
  reportDepartment: {
    dept_id: "DEPT-REPORT",
    dept_name: "Analytics",
    dept_head: "MGR-REPORT-001",
    description: "Analytics and Reporting Department",
    budget: 5e5,
    headcount: 5
  },
  performanceMetrics: [
    {
      metric_id: "METRIC-EFF-001",
      metric_name: "Efficiency Score",
      category: "efficiency",
      metric_category: "efficiency",
      target: 80,
      target_value: 80,
      weight: 0.3,
      department: "DEPT-REPORT",
      description: "Measure of task completion rate and time management"
    },
    {
      metric_id: "METRIC-QUA-001",
      metric_name: "Quality Score",
      category: "quality",
      metric_category: "quality",
      target: 85,
      target_value: 85,
      weight: 0.4,
      department: "DEPT-REPORT",
      description: "Measure of work quality and accuracy"
    },
    {
      metric_id: "METRIC-ENG-001",
      metric_name: "Engagement Score",
      category: "engagement",
      metric_category: "engagement",
      target: 80,
      target_value: 80,
      weight: 0.3,
      department: "DEPT-REPORT",
      description: "Measure of employee engagement and participation"
    }
  ],
  performanceReviews: [
    {
      review_id: "REV-REPORT-001",
      employee_id: "EMP-REPORT-001",
      employeeID: "EMP-REPORT-001",
      manager_id: "MGR-REPORT-001",
      department: "DEPT-REPORT",
      review_period: "Q4-2024",
      period: "Q4-2024",
      overall_rating: 4.5,
      overallRating: 4.5,
      review_date: (/* @__PURE__ */ new Date("2024-10-15")).toISOString(),
      technical_skills: 4.5,
      communication: 4.3,
      teamwork: 4.4,
      metrics: {
        efficiency: 85,
        quality: 92,
        engagement: 88
      },
      feedback: "Excellent performance in Q4",
      createdAt: (/* @__PURE__ */ new Date("2024-10-15")).toISOString(),
      status: "completed"
    },
    {
      review_id: "REV-REPORT-002",
      employee_id: "EMP-REPORT-002",
      employeeID: "EMP-REPORT-002",
      manager_id: "MGR-REPORT-001",
      department: "DEPT-REPORT",
      review_period: "Q4-2024",
      period: "Q4-2024",
      overall_rating: 4.2,
      overallRating: 4.2,
      review_date: (/* @__PURE__ */ new Date("2024-10-20")).toISOString(),
      technical_skills: 4,
      communication: 4.2,
      teamwork: 4.3,
      metrics: {
        efficiency: 78,
        quality: 88,
        engagement: 80
      },
      feedback: "Good performance with room for improvement",
      createdAt: (/* @__PURE__ */ new Date("2024-10-20")).toISOString(),
      status: "completed"
    }
  ],
  performanceCriteria: [
    {
      criteria_id: "CRIT-001",
      criteria_name: "Technical Skills",
      description: "Proficiency in technical competencies",
      weight: 0.3
    },
    {
      criteria_id: "CRIT-002",
      criteria_name: "Teamwork",
      description: "Collaboration and team contribution",
      weight: 0.2
    },
    {
      criteria_id: "CRIT-003",
      criteria_name: "Leadership",
      description: "Leadership and initiative demonstration",
      weight: 0.25
    }
  ],
  // ========== Login/Dashboard/Empman Test Fixtures ==========
  // Admin user for login and dashboard tests
  loginAdminUser: {
    userID: "USER-LOGIN-ADMIN-001",
    employeeID: "EMP-LOGIN-ADMIN-001",
    email: "admin.test.2025@nshrm.com",
    password: "AdminPass123!",
    securecode: "",
    userType: "admin",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  loginAdminEmployee: {
    employeeID: "EMP001",
    title: "Mr",
    firstname: "Admin",
    lastname: "Test",
    gender: "Male",
    phonenumber: "5559999999",
    email: "admin.test.2025@nshrm.com",
    address: "999 Admin Ave",
    ethnicity: "Other",
    deptcode: "ENG001",
    managerID: "",
    job_role: "System Administrator",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2020-01-01")).toISOString(),
    branch: "HQ",
    training: "Administration",
    certification: "",
    skills: "Administration, System Management",
    interests: "System Operations",
    status: "active"
  },
  // Employee user for empman tests
  empmanEmployeeUser: {
    userID: "USER-EMPMAN-001",
    employeeID: "EMP002",
    email: "employee.test.2025@nshrm.com",
    password: "EmployeePass123!",
    securecode: "",
    userType: "employee",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  empmanEmployee: {
    employeeID: "EMP002",
    title: "Ms",
    firstname: "Employee",
    lastname: "Test",
    gender: "Female",
    phonenumber: "5558888888",
    email: "employee.test.2025@nshrm.com",
    address: "888 Employee Rd",
    ethnicity: "Other",
    deptcode: "ENG001",
    managerID: "MGR001",
    job_role: "Software Developer",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2022-06-15")).toISOString(),
    branch: "HQ",
    training: "Software Development",
    certification: "",
    skills: "JavaScript, React, Node.js",
    interests: "Web Development",
    status: "active"
  },
  // Second employee for team member tests
  empmanEmployee2User: {
    userID: "USER-EMPMAN-002",
    employeeID: "EMP003",
    email: "employee2.test.2025@nshrm.com",
    password: "EmpPass123!",
    securecode: "",
    userType: "employee",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  empmanEmployee2: {
    employeeID: "EMP003",
    title: "Mr",
    firstname: "Employee2",
    lastname: "Test",
    gender: "Male",
    phonenumber: "5558888889",
    email: "employee2.test.2025@nshrm.com",
    address: "889 Employee Rd",
    ethnicity: "Other",
    deptcode: "ENG001",
    managerID: "MGR001",
    job_role: "Quality Assurance",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2023-01-15")).toISOString(),
    branch: "HQ",
    training: "QA",
    certification: "",
    skills: "Testing, Automation",
    interests: "Quality Assurance",
    status: "active"
  },
  // Manager user for empman tests
  empmanManagerUser: {
    userID: "USER-EMPMAN-MGR-001",
    employeeID: "MGR001",
    email: "manager.test.2025@nshrm.com",
    password: "ManagerPass123!",
    securecode: "",
    userType: "manager",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  empmanManager: {
    employeeID: "MGR001",
    title: "Mr",
    firstname: "Manager",
    lastname: "Test",
    gender: "Male",
    phonenumber: "5557777777",
    email: "manager.test.2025@nshrm.com",
    address: "777 Manager Way",
    ethnicity: "Other",
    deptcode: "ENG001",
    managerID: "EMP001",
    job_role: "Team Lead",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2021-03-01")).toISOString(),
    branch: "HQ",
    training: "Leadership",
    certification: "",
    skills: "Leadership, Project Management, Development",
    interests: "Team Development",
    status: "active"
  },
  // Debug user for repo operations (empman.integration.test.js)
  repoDebugUser: {
    userID: "USER-REPO-DEBUG-001",
    employeeID: "EMP-REPO-DEBUG-001",
    email: "repo.debug.delete@nshrm.com",
    password: "RepoDebug123!",
    securecode: "",
    userType: "employee",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  repoDebugEmployee: {
    employeeID: "EMP-REPO-DEBUG-001",
    title: "Mr",
    firstname: "Debug",
    lastname: "User",
    gender: "Male",
    phonenumber: "5556666666",
    email: "repo.debug.delete@nshrm.com",
    address: "666 Debug St",
    ethnicity: "Other",
    deptcode: "DEPT003",
    managerID: "MGR-EMPMAN-001",
    job_role: "Quality Assurance",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2023-01-10")).toISOString(),
    branch: "HQ",
    training: "QA",
    certification: "",
    skills: "Testing, Automation",
    interests: "Quality Assurance",
    status: "active"
  },
  // Delete test user (user-delete.integration.test.js)
  deleteReproUser: {
    userID: "USER-DELETE-REPRO-001",
    employeeID: "EMP-DELETE-REPRO-001",
    email: "delete.repro.test@nshrm.com",
    password: "DeleteRepro123!",
    securecode: "",
    userType: "employee",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  deleteReproEmployee: {
    employeeID: "EMP-DELETE-REPRO-001",
    title: "Ms",
    firstname: "Delete",
    lastname: "Repro",
    gender: "Female",
    phonenumber: "5555555555",
    email: "delete.repro.test@nshrm.com",
    address: "555 Delete Lane",
    ethnicity: "Other",
    deptcode: "DEPT003",
    managerID: "MGR-EMPMAN-001",
    job_role: "Tester",
    contract_type: "Contract",
    employment_date: (/* @__PURE__ */ new Date("2024-01-01")).toISOString(),
    branch: "HQ",
    training: "",
    certification: "",
    skills: "Testing",
    interests: "Testing",
    status: "active"
  },
  // Additional test users for empman cascade/delete tests
  cascadeTestUser: {
    userID: "USER-CASCADE-TEST-001",
    employeeID: "EMPCAS001",
    email: "cascade.test@nshrm.com",
    password: "CascadeTest123!",
    securecode: "",
    userType: "employee",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  cascadeTestEmployee: {
    employeeID: "EMPCAS001",
    title: "Mr",
    firstname: "Cascade",
    lastname: "Test",
    gender: "Male",
    phonenumber: "5554444444",
    email: "cascade.test@nshrm.com",
    address: "444 Cascade Way",
    ethnicity: "Other",
    deptcode: "DEPT003",
    managerID: "MGR-EMPMAN-001",
    job_role: "Associate",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2023-07-01")).toISOString(),
    branch: "HQ",
    training: "",
    certification: "",
    skills: "General",
    interests: "General",
    status: "active"
  },
  // Delete test users
  deleteTestUser: {
    userID: "USER-DELETE-TEST-001",
    employeeID: "EMP-DELETE-TEST-001",
    email: "delete.test@nshrm.com",
    password: "DeleteTest123!",
    securecode: "",
    userType: "employee",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  deleteTestEmployee: {
    employeeID: "EMP-DELETE-TEST-001",
    title: "Ms",
    firstname: "Delete",
    lastname: "Test",
    gender: "Female",
    phonenumber: "5553333333",
    email: "delete.test@nshrm.com",
    address: "333 Delete Ave",
    ethnicity: "Other",
    deptcode: "DEPT003",
    managerID: "MGR-EMPMAN-001",
    job_role: "Staff",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2023-05-15")).toISOString(),
    branch: "HQ",
    training: "",
    certification: "",
    skills: "General",
    interests: "General",
    status: "active"
  },
  // Auth test user
  authTestUser: {
    userID: "USER-AUTH-TEST-001",
    employeeID: "EMP-AUTH-TEST-001",
    email: "authtest.user@nshrm.com",
    password: "AuthTest123!",
    securecode: "",
    userType: "employee",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  authTestEmployee: {
    employeeID: "EMP-AUTH-TEST-001",
    title: "Mr",
    firstname: "Auth",
    lastname: "Test",
    gender: "Male",
    phonenumber: "5552222222",
    email: "authtest.user@nshrm.com",
    address: "222 Auth St",
    ethnicity: "Other",
    deptcode: "DEPT003",
    managerID: "MGR-EMPMAN-001",
    job_role: "Staff",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2023-08-01")).toISOString(),
    branch: "HQ",
    training: "",
    certification: "",
    skills: "General",
    interests: "General",
    status: "active"
  },
  // Temp user
  tempUser: {
    userID: "USER-TEMP-001",
    employeeID: "EMP-TEMP-001",
    email: "temp.user@nshrm.com",
    password: "TempPass123!",
    securecode: "",
    userType: "employee",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  tempEmployee: {
    employeeID: "EMP-TEMP-001",
    title: "Ms",
    firstname: "Temp",
    lastname: "User",
    gender: "Female",
    phonenumber: "5551111111",
    email: "temp.user@nshrm.com",
    address: "111 Temp Blvd",
    ethnicity: "Other",
    deptcode: "DEPT003",
    managerID: "MGR-EMPMAN-001",
    job_role: "Contractor",
    contract_type: "Contract",
    employment_date: (/* @__PURE__ */ new Date("2024-03-01")).toISOString(),
    branch: "HQ",
    training: "",
    certification: "",
    skills: "Consulting",
    interests: "Consulting",
    status: "active"
  },
  // Email delete test user
  emailDeleteTestUser: {
    userID: "USER-EMAIL-DELETE-001",
    employeeID: "EMP-EMAIL-DELETE-001",
    email: "email.delete.test@nshrm.com",
    password: "EmailDelete123!",
    securecode: "",
    userType: "employee",
    time_stamp: (/* @__PURE__ */ new Date()).toISOString()
  },
  emailDeleteTestEmployee: {
    employeeID: "EMP-EMAIL-DELETE-001",
    title: "Mr",
    firstname: "EmailDelete",
    lastname: "Test",
    gender: "Male",
    phonenumber: "5550000000",
    email: "email.delete.test@nshrm.com",
    address: "000 Email St",
    ethnicity: "Other",
    deptcode: "DEPT003",
    managerID: "MGR-EMPMAN-001",
    job_role: "Associate",
    contract_type: "Full-time",
    employment_date: (/* @__PURE__ */ new Date("2023-09-15")).toISOString(),
    branch: "HQ",
    training: "",
    certification: "",
    skills: "General",
    interests: "General",
    status: "active"
  }
};
async function seedLoginAdminTestData() {
  await seedEmployee(testFixtures.loginAdminEmployee);
  await seedUser(testFixtures.loginAdminUser);
}
async function seedEmpmanTestData() {
  await seedEmployee(testFixtures.loginAdminEmployee);
  await seedUser(testFixtures.loginAdminUser);
  await seedManager(testFixtures.empmanManager);
  await seedUser(testFixtures.empmanManagerUser);
  await seedEmployee(testFixtures.empmanEmployee);
  await seedUser(testFixtures.empmanEmployeeUser);
  await seedEmployee(testFixtures.empmanEmployee2);
  await seedUser(testFixtures.empmanEmployee2User);
  await seedEmployee(testFixtures.repoDebugEmployee);
  await seedUser(testFixtures.repoDebugUser);
  await seedEmployee(testFixtures.cascadeTestEmployee);
  await seedUser(testFixtures.cascadeTestUser);
  await seedEmployee(testFixtures.deleteTestEmployee);
  await seedUser(testFixtures.deleteTestUser);
  await seedEmployee(testFixtures.authTestEmployee);
  await seedUser(testFixtures.authTestUser);
  await seedEmployee(testFixtures.tempEmployee);
  await seedUser(testFixtures.tempUser);
  await seedEmployee(testFixtures.emailDeleteTestEmployee);
  await seedUser(testFixtures.emailDeleteTestUser);
}
async function seedUserDeleteTestData() {
  await seedEmployee(testFixtures.loginAdminEmployee);
  await seedUser(testFixtures.loginAdminUser);
  await seedEmployee(testFixtures.deleteReproEmployee);
  await seedUser(testFixtures.deleteReproUser);
}
async function seedSurveyManagerTestData() {
  await seedEmployee(testFixtures.surveyEmployee);
  await seedUser(testFixtures.surveyEmployeeUser);
  await seedSurvey(testFixtures.survey);
  await seedEmployee(testFixtures.surveyEmployee2);
  await seedUser(testFixtures.surveyEmployee2User);
  await seedSurvey(testFixtures.survey2);
}
async function seedReportManagerTestData() {
  await seedDepartment(testFixtures.reportDepartment);
  await seedManager(testFixtures.reportManager);
  await seedUser(testFixtures.reportManagerUser);
  await seedEmployee(testFixtures.reportEmployee1);
  await seedEmployee(testFixtures.reportEmployee2);
  for (const metric of testFixtures.performanceMetrics) {
    await seedPerformanceMetric(metric);
  }
  for (const review of testFixtures.performanceReviews) {
    await seedPerformanceReview(review);
  }
  for (const criteria of testFixtures.performanceCriteria) {
    await seedPerformanceCriteria(criteria);
  }
}
async function seedGoalWorkflowTestData() {
  await seedDepartment(testFixtures.goalWorkflowDepartment);
  await seedManager(testFixtures.goalWorkflowManager);
  await seedUser(testFixtures.goalWorkflowManagerUser);
  await seedEmployee(testFixtures.goalWorkflowEmployee);
  await seedUser(testFixtures.goalWorkflowEmployeeUser);
  await seedAppraisalPeriod(testFixtures.goalWorkflowAppraisalPeriod);
  await seedBusinessGoal(testFixtures.goalWorkflowBusinessGoal);
  await seedGoal(testFixtures.goalPendingApproval);
  await seedGoal(testFixtures.goalApproved);
  await seedGoal(testFixtures.goalCompleted);
  for (const progress of testFixtures.goalProgressRecords) {
    await seedGoalProgress(progress);
  }
  await seedDevelopmentPlan(testFixtures.goalWorkflowDevelopmentPlan);
  console.log("[seedHelper] Goal workflow test data seeded successfully");
}
async function seedDemoData() {
  console.log("[seedHelper] Starting comprehensive demo data seeding...");
  for (const demoUser of testFixtures.demoUsers) {
    try {
      const existingUsers = await userRepository.find({ email: demoUser.email });
      if (existingUsers.length === 0) {
        await userRepository.add({
          userID: crypto.randomUUID(),
          employeeID: demoUser.employeeID,
          email: demoUser.email,
          password: demoUser.password,
          securecode: "",
          userType: demoUser.userType,
          time_stamp: /* @__PURE__ */ new Date()
        });
        console.log(`[seedHelper] Demo user seeded: ${demoUser.email}`);
      }
    } catch (error2) {
      console.warn(`[seedHelper] Failed to seed demo user ${demoUser.email}:`, error2);
    }
  }
  await seedGoalWorkflowTestData();
  await seedSurveyManagerTestData();
  await seedReportManagerTestData();
  console.log("[seedHelper] Demo data seeding complete!");
  console.log("[seedHelper] Available demo logins:");
  testFixtures.demoUsers.forEach((u2) => {
    console.log(`  - ${u2.email} / ${u2.password} (${u2.userType})`);
  });
}
async function clearTestData() {
  localStorage.clear();
  sessionStorage.clear();
}
const seedHelper = {
  // Repository seed functions
  seedEmployee,
  seedManager,
  seedUser,
  createUserAndLogin,
  seedBusinessGoal,
  seedGoal,
  seedDevelopmentPlan,
  seedAppraisalPeriod,
  seedGoalProgress,
  seedSurvey,
  seedSurveyResponse,
  seedPerformanceMetric,
  seedPerformanceReview,
  seedPerformanceCriteria,
  seedDepartment,
  // Batch seeding utilities
  seedLoginAdminTestData,
  seedEmpmanTestData,
  seedUserDeleteTestData,
  seedSurveyManagerTestData,
  seedReportManagerTestData,
  seedGoalWorkflowTestData,
  // NEW: Goal approval workflow
  seedDemoData,
  // NEW: Complete demo setup
  clearTestData,
  // Test fixtures
  testFixtures
};
const seedHelper$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clearTestData,
  createUserAndLogin,
  default: seedHelper,
  seedAppraisalPeriod,
  seedBusinessGoal,
  seedDemoData,
  seedDepartment,
  seedDevelopmentPlan,
  seedEmployee,
  seedEmpmanTestData,
  seedGoal,
  seedGoalProgress,
  seedGoalWorkflowTestData,
  seedLoginAdminTestData,
  seedManager,
  seedPerformanceCriteria,
  seedPerformanceMetric,
  seedPerformanceReview,
  seedReportManagerTestData,
  seedSurvey,
  seedSurveyManagerTestData,
  seedSurveyResponse,
  seedUser,
  seedUserDeleteTestData,
  testFixtures
}, Symbol.toStringTag, { value: "Module" }));
class UserRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  // ============================================================================
  // Demo User Seeding - Seeds testFixtures.demoUsers into repository if they don't exist
  // Called automatically on login for manual testing convenience
  // Source of Truth: seedHelper.ts  testFixtures.demoUsers
  // ============================================================================
  async seedDemoUsers() {
    for (const demoUser of testFixtures.demoUsers) {
      try {
        const existingUsers = await this.find({ email: demoUser.email });
        if (existingUsers.length === 0) {
          await this.createUser({
            email: demoUser.email,
            password: demoUser.password,
            userType: demoUser.userType,
            employeeID: demoUser.employeeID,
            securecode: ""
          });
          console.log(`[UserRepository] Demo user seeded: ${demoUser.email}`);
        }
      } catch (error2) {
        console.warn(`[UserRepository] Failed to seed user ${demoUser.email}:`, error2);
      }
    }
  }
  // Authentication
  async login(email2, password) {
    await this.seedDemoUsers();
    const users = await this.find({ email: email2 });
    const authenticatedUser = users.find((u2) => u2.password === password);
    if (!authenticatedUser) {
      throw new Error("Invalid email or password");
    }
    const access_token = btoa(JSON.stringify({
      userId: authenticatedUser.userID,
      email: authenticatedUser.email,
      userType: authenticatedUser.userType,
      employeeID: authenticatedUser.employeeID,
      // Include employeeID for employee repository queries
      exp: Date.now() + 24 * 60 * 60 * 1e3
      // 24 hours
    }));
    const userResponse = {
      ...authenticatedUser,
      password: ""
      // Don't expose password
    };
    return {
      user: userResponse,
      access_token,
      token_type: "bearer"
    };
  }
  // Profile Management
  async getCurrentUser() {
    try {
      const token = localStorage.getItem("auth_token") || sessionStorage.getItem("auth_token");
      console.log("[DEBUG] UserRepository.getCurrentUser - token (first 50 chars):", token ? token.substring(0, 50) : "null");
      if (!token) {
        throw new Error("No authentication token found");
      }
      const tokenData = JSON.parse(atob(token));
      console.log("[DEBUG] UserRepository.getCurrentUser - tokenData:", tokenData);
      const users = await this.find({ email: tokenData.email });
      console.log("[DEBUG] UserRepository.getCurrentUser - users found count:", users.length);
      if (users.length === 0) {
        throw new Error("User not found in repository");
      }
      const user = users[0];
      return {
        ...user,
        password: "",
        // Don't expose password
        securecode: ""
        // Don't expose secure code
      };
    } catch (error2) {
      console.error("Failed to get current user:", error2);
      throw new Error("User not authenticated");
    }
  }
  async getUserById(userId) {
    return await this.get(Number(userId));
  }
  async updateProfile(updates) {
    const currentUser = await this.getCurrentUser();
    const users = await this.find({ email: currentUser.email });
    const userToUpdate = users[0];
    if (!userToUpdate) {
      throw new Error("User not found");
    }
    const updatedUser = {
      ...userToUpdate,
      ...updates,
      time_stamp: /* @__PURE__ */ new Date()
    };
    await this.context.add(updatedUser);
    return updatedUser;
  }
  async changePassword(currentPassword, newPassword) {
    const currentUser = await this.getCurrentUser();
    const users = await this.find({ email: currentUser.email });
    const userToUpdate = users.find((u2) => u2.password === currentPassword);
    if (!userToUpdate) {
      throw new Error("Current password is incorrect");
    }
    const updatedUser = {
      ...userToUpdate,
      password: newPassword,
      time_stamp: /* @__PURE__ */ new Date()
    };
    await this.context.add(updatedUser);
    return true;
  }
  async uploadProfilePicture(file) {
    throw new Error("Method not implemented");
  }
  // Admin Operations
  async getAllUsers() {
    return await this.getAll();
  }
  async createUser(userData) {
    const newUser = {
      userID: crypto.randomUUID(),
      employeeID: userData.employeeID || "",
      email: userData.email || "",
      password: userData.password || "",
      securecode: userData.securecode || "",
      userType: userData.userType || "employee",
      time_stamp: /* @__PURE__ */ new Date(),
      ...userData
    };
    const createdUser = await this.add(newUser);
    if (createdUser.userType === "employee" || createdUser.userType === "manager") {
      try {
        const { employeeRepository: employeeRepository2 } = await __vitePreload(async () => {
          const { employeeRepository: employeeRepository3 } = await Promise.resolve().then(() => RepoService$1);
          return { employeeRepository: employeeRepository3 };
        }, true ? void 0 : void 0);
        const existingEmployees = await employeeRepository2.find({ email: createdUser.email });
        if (existingEmployees.length === 0) {
          const extendedData = userData;
          await employeeRepository2.add({
            employeeID: createdUser.employeeID || crypto.randomUUID(),
            email: createdUser.email,
            firstname: extendedData.firstname || "",
            lastname: extendedData.lastname || "",
            title: extendedData.title || "",
            gender: extendedData.gender || "",
            phonenumber: extendedData.phonenumber || "",
            address: extendedData.address || "",
            deptcode: extendedData.deptcode || "",
            job_role: extendedData.job_role || "",
            contract_type: extendedData.contract_type || "full-time",
            status: "active",
            time_stamp: /* @__PURE__ */ new Date()
          });
          console.log(`[UserRepository] Auto-created employee record for ${createdUser.email}`);
        }
      } catch (error2) {
        console.warn(`[UserRepository] Failed to auto-create employee record:`, error2);
      }
    }
    return createdUser;
  }
  async updateUser(userId, updates) {
    const user = await this.get(Number(userId));
    if (!user) throw new Error(`User with id ${userId} not found`);
    const updatedUser = { ...user, ...updates };
    const contextWithUpdate = this.context;
    if (contextWithUpdate.update) {
      return await contextWithUpdate.update(updatedUser);
    }
    throw new Error("Update operation not supported");
  }
  async deleteUser(userId) {
    try {
      let users = [];
      users = await this.find({ email: userId });
      if (users.length === 0) {
        users = await this.find({ userID: userId });
      }
      if (users.length === 0 && !isNaN(Number(userId))) {
        users = await this.find({ ID: Number(userId) });
      }
      if (users.length === 0) {
        console.warn(`[UserRepository.deleteUser] User not found for deletion: ${userId}`);
        const allUsers = await this.getAll();
        console.log("[UserRepository.deleteUser] All users count:", allUsers.length);
        if (allUsers.length > 0) console.log("[UserRepository.deleteUser] First user sample:", allUsers[0]);
        return false;
      }
      const removed = await this.remove(users[0]);
      console.log(`[UserRepository.deleteUser] Removed count: ${removed} for userId: ${userId}`);
      return removed > 0;
    } catch (error2) {
      console.error(`Error deleting user ${userId}:`, error2);
      return false;
    }
  }
  // Additional Queries
  async getUsersByType(userType) {
    return await this.find({ userType });
  }
  async getUsersByEmployeeId(employeeId) {
    return await this.find({ employeeID: employeeId });
  }
  async searchUsers(query) {
    return await this.find({
      $or: [
        { email: { $regex: query, $options: "i" } },
        { userID: { $regex: query, $options: "i" } }
      ]
    });
  }
}
class EmployeeRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async getCurrentEmployee() {
    try {
      await this.seedDemoEmployees();
      const token = localStorage.getItem("auth_token") || sessionStorage.getItem("auth_token");
      if (!token) {
        throw new Error("No authentication token found");
      }
      const tokenData = JSON.parse(atob(token));
      if (!tokenData.employeeID) {
        const userRepo = JSON.parse(localStorage.getItem("tldr_users") || "[]");
        const user = userRepo.find((u2) => u2.email === tokenData.email);
        if (!user || !user.employeeID) {
          throw new Error("Employee ID not found for current user");
        }
        tokenData.employeeID = user.employeeID;
      }
      const employees = await this.find({ employeeID: tokenData.employeeID });
      if (employees.length === 0) {
        throw new Error("Employee record not found in repository");
      }
      return employees[0];
    } catch (error2) {
      console.error("Failed to get current employee:", error2);
      throw new Error("Failed to retrieve current employee");
    }
  }
  async updateEmployeeProfile(updates) {
    const currentEmployee = await this.getCurrentEmployee();
    const employees = await this.find({ employeeID: currentEmployee.employeeID });
    const employeeToUpdate = employees[0];
    if (!employeeToUpdate) {
      throw new Error("Employee not found");
    }
    const updatedEmployee = {
      ...employeeToUpdate,
      ...updates
    };
    const contextWithUpdate = this.context;
    if (contextWithUpdate.update) {
      return await contextWithUpdate.update(updatedEmployee);
    }
    throw new Error("Update operation not supported");
  }
  async getEmployeeProfile() {
    return await this.getCurrentEmployee();
  }
  async getEmployeesByDepartment(deptCode) {
    return await this.find({ deptcode: deptCode });
  }
  async getEmployeesByManager(managerId) {
    return await this.find({ managerID: managerId });
  }
  async getEmployeesByStatus(status) {
    return await this.find({ status });
  }
  async searchEmployees(query) {
    return await this.find({
      $or: [
        { firstname: { $regex: query, $options: "i" } },
        { lastname: { $regex: query, $options: "i" } },
        { employeeID: { $regex: query, $options: "i" } }
      ]
    });
  }
  async getEmployeesByJobRole(jobRole) {
    return await this.find({ job_role: jobRole });
  }
  async getEmployeesByContractType(contractType) {
    return await this.find({ contract_type: contractType });
  }
  async deleteEmployee(employeeId) {
    try {
      let employees = [];
      employees = await this.find({ email: employeeId });
      if (employees.length === 0) {
        employees = await this.find({ employeeID: employeeId });
      }
      if (employees.length === 0 && !isNaN(Number(employeeId))) {
        employees = await this.find({ ID: Number(employeeId) });
      }
      if (employees.length === 0) {
        console.warn(`Employee not found for deletion: ${employeeId}`);
        return false;
      }
      const removed = await this.remove(employees[0]);
      return removed > 0;
    } catch (error2) {
      console.error(`Error deleting employee ${employeeId}:`, error2);
      return false;
    }
  }
  async seedDemoEmployees() {
    const existingEmployees = await this.find({});
    if (existingEmployees.length >= 7) {
      return;
    }
    console.log("Seeding demo employees (existing count:", existingEmployees.length, ")");
    if (existingEmployees.length > 0) {
      localStorage.removeItem("tldr_employees");
    }
    const demoEmployees = [
      {
        employeeID: "EMP001",
        title: "Mr",
        firstname: "Admin",
        lastname: "Test User",
        gender: "Male",
        phonenumber: "+1234567890",
        email: "admin.test.2025@nshrm.com",
        address: "123 Admin Street",
        ethnicity: "Not Specified",
        deptcode: "IT001",
        managerID: "",
        job_role: "System Administrator",
        contract_type: "Permanent",
        employment_date: /* @__PURE__ */ new Date("2024-01-01"),
        branch: "Headquarters",
        training: "System Administration",
        certification: "CISSP",
        skills: "Linux, Python, Docker",
        interests: "Automation",
        status: "Active"
      },
      {
        employeeID: "EMP002",
        title: "Ms",
        firstname: "Employee",
        lastname: "Test User",
        gender: "Female",
        phonenumber: "+1234567891",
        email: "employee.test.2025@nshrm.com",
        address: "456 Employee Avenue",
        ethnicity: "Not Specified",
        deptcode: "ENG001",
        managerID: "MGR001",
        job_role: "Software Developer",
        contract_type: "Permanent",
        employment_date: /* @__PURE__ */ new Date("2024-03-15"),
        branch: "Engineering Hub",
        training: "React.js, Node.js",
        certification: "AWS Certified Developer",
        skills: "JavaScript, TypeScript, React",
        interests: "Web Development",
        status: "Active"
      },
      {
        employeeID: "EMP003",
        title: "Mr",
        firstname: "Manager",
        lastname: "Test User",
        gender: "Male",
        phonenumber: "+1234567892",
        email: "manager.test.2025@nshrm.com",
        address: "789 Manager Boulevard",
        ethnicity: "Not Specified",
        deptcode: "ENG001",
        managerID: "",
        job_role: "Development Manager",
        contract_type: "Permanent",
        employment_date: /* @__PURE__ */ new Date("2023-06-01"),
        branch: "Engineering Hub",
        training: "Leadership, Team Management",
        certification: "PMP, Certified Scrum Master",
        skills: "Team Leadership, Project Management",
        interests: "Team Development",
        status: "Active"
      },
      {
        employeeID: "EMP0001",
        title: "Mr",
        firstname: "System",
        lastname: "Admin",
        gender: "Male",
        phonenumber: "+1234567893",
        email: "admin@nshrm.com",
        address: "100 System Lane",
        ethnicity: "Not Specified",
        deptcode: "IT001",
        managerID: "",
        job_role: "System Administrator",
        contract_type: "Permanent",
        employment_date: /* @__PURE__ */ new Date("2020-01-01"),
        branch: "Headquarters",
        training: "System Administration",
        certification: "CISSP, RHCE",
        skills: "Linux, Security, Networking",
        interests: "Infrastructure",
        status: "Active"
      },
      {
        employeeID: "EMP0003",
        title: "Mr",
        firstname: "Department",
        lastname: "Manager",
        gender: "Male",
        phonenumber: "+1234567894",
        email: "manager@nshrm.com",
        address: "200 Manager Street",
        ethnicity: "Not Specified",
        deptcode: "ENG001",
        managerID: "",
        job_role: "Department Manager",
        contract_type: "Permanent",
        employment_date: /* @__PURE__ */ new Date("2021-01-01"),
        branch: "Engineering Hub",
        training: "Management, Leadership",
        certification: "MBA, PMP",
        skills: "Team Management, Strategic Planning",
        interests: "Leadership Development",
        status: "Active"
      },
      {
        employeeID: "EMP0004",
        title: "Mr",
        firstname: "John",
        lastname: "Employee",
        gender: "Male",
        phonenumber: "+1234567895",
        email: "employee@nshrm.com",
        address: "300 Employee Road",
        ethnicity: "Not Specified",
        deptcode: "ENG001",
        managerID: "EMP0003",
        job_role: "Senior Developer",
        contract_type: "Permanent",
        employment_date: /* @__PURE__ */ new Date("2022-06-01"),
        branch: "Engineering Hub",
        training: "Full Stack Development",
        certification: "AWS Certified Solutions Architect",
        skills: "Java, Python, React, AWS",
        interests: "Cloud Architecture",
        status: "Active"
      }
    ];
    console.log("Seeding demo employees...");
    for (const employee of demoEmployees) {
      try {
        await this.context.add(employee);
        console.log(`Seeded employee: ${employee.employeeID}`);
      } catch (error2) {
        console.warn(`Failed to seed employee ${employee.employeeID}:`, error2);
      }
    }
    console.log("Demo employees seeded successfully");
  }
}
class GoalRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createGoal(goalData) {
    const newGoal = {
      goalID: Date.now(),
      // Simple ID generation
      busgoal: goalData.busgoal || "",
      employee: goalData.employee || "",
      ID: goalData.ID || "",
      goal_title: goalData.goal_title || "",
      goal_description: goalData.goal_description || "",
      key_result: goalData.key_result || "",
      projected_start_date: goalData.projected_start_date || /* @__PURE__ */ new Date(),
      projected_target_date: goalData.projected_target_date || /* @__PURE__ */ new Date(),
      actual_start_date: goalData.actual_start_date || /* @__PURE__ */ new Date(),
      actual_completion_date: goalData.actual_completion_date || /* @__PURE__ */ new Date(),
      goal_progress: goalData.goal_progress || 0,
      goal_status: goalData.goal_status || "pending",
      approval: goalData.approval || 0,
      appraisal_period: goalData.appraisal_period || "",
      date_modified: /* @__PURE__ */ new Date(),
      ...goalData
    };
    return await this.add(newGoal);
  }
  async updateGoal(goalId, updates) {
    const updatedGoal = await this.context.update(goalId, { ...updates, date_modified: /* @__PURE__ */ new Date() }, "goalID");
    return updatedGoal;
  }
  async getGoalById(goalId) {
    const goals = await this.find({ goalID: goalId });
    if (!goals || goals.length === 0) {
      throw new Error(`Goal with id ${goalId} not found`);
    }
    return goals[0];
  }
  async deleteGoal(goalId) {
    return await this.context.deleteById(goalId, "goalID");
  }
  async bulkCreateGoals(goals) {
    const createdGoals = [];
    for (const goalData of goals) {
      const goal = await this.createGoal(goalData);
      createdGoals.push(goal);
    }
    return createdGoals;
  }
  async countGoals() {
    return await this.count();
  }
  async approveGoal(goalId) {
    return await this.updateGoal(goalId, { approval: 1 });
  }
  async rejectGoal(goalId) {
    return await this.updateGoal(goalId, { approval: 0 });
  }
  async createGoalProgress(goalId, progressData) {
    throw new Error("Method not implemented");
  }
  async getGoalProgress(goalId) {
    throw new Error("Method not implemented");
  }
  async getLatestGoalProgress(goalId) {
    throw new Error("Method not implemented");
  }
  async updateGoalProgress(progressId, updates) {
    throw new Error("Method not implemented");
  }
  async deleteGoalProgress(progressId) {
    throw new Error("Method not implemented");
  }
  async getGoalsByEmployee(employeeId) {
    return await this.find({ employee: employeeId });
  }
  async getGoalsByStatus(status) {
    return await this.find({ goal_status: status });
  }
  async getGoalsByAppraisalPeriod(period) {
    return await this.find({ appraisal_period: period });
  }
  async getGoalsByBusinessGoal(busGoalId) {
    return await this.find({ busgoal: busGoalId });
  }
  async searchGoals(query) {
    return await this.find({
      $or: [
        { goal_title: { $regex: query, $options: "i" } },
        { goal_description: { $regex: query, $options: "i" } }
      ]
    });
  }
}
class DevelopmentPlanRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createDevelopmentPlan(planData) {
    const newPlan = {
      planID: Date.now(),
      employee: planData.employee || "",
      ID: planData.ID || "",
      competency_area: planData.competency_area || "",
      plan_description: planData.plan_description || "",
      skills: planData.skills || "",
      projected_start_date: planData.projected_start_date || /* @__PURE__ */ new Date(),
      projected_target_date: planData.projected_target_date || /* @__PURE__ */ new Date(),
      dev_year: planData.dev_year || (/* @__PURE__ */ new Date()).getFullYear(),
      mode: planData.mode || "",
      plan_status: planData.plan_status || "draft",
      dev_progress: planData.dev_progress || 0,
      ...planData
    };
    return await this.add(newPlan);
  }
  async getDevelopmentPlanById(planId) {
    return await this.get(planId);
  }
  async updateDevelopmentPlan(planId, updates) {
    const plans = await this.find({ planID: planId });
    if (!plans || plans.length === 0) {
      throw new Error(`Development plan with id ${planId} not found`);
    }
    const contextWithUpdate = this.context;
    if (contextWithUpdate.update) {
      return await contextWithUpdate.update(planId, updates, "planID");
    }
    throw new Error("Update operation not supported");
  }
  async deleteDevelopmentPlan(planId) {
    const contextWithDelete = this.context;
    if (contextWithDelete.deleteById) {
      return await contextWithDelete.deleteById(planId, "planID");
    }
    await this.remove(planId);
    return true;
  }
  async getDevelopmentPlansByEmployee(employeeId) {
    return await this.find({ employee: employeeId });
  }
  async getDevelopmentPlansByStatus(status) {
    return await this.find({ plan_status: status });
  }
  async getDevelopmentPlansByYear(year) {
    return await this.find({ dev_year: year });
  }
  async getDevelopmentPlansByCompetencyArea(area) {
    return await this.find({ competency_area: { $regex: area, $options: "i" } });
  }
  async searchDevelopmentPlans(query) {
    return await this.find({
      $or: [
        { competency_area: { $regex: query, $options: "i" } },
        { plan_description: { $regex: query, $options: "i" } },
        { skills: { $regex: query, $options: "i" } }
      ]
    });
  }
}
class PerformanceCriteriaRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createPerformanceCriteria(criteriaData) {
    const newCriteria = {
      criteriaID: criteriaData.criteriaID || crypto.randomUUID().substring(0, 4).toUpperCase(),
      criteriaName: criteriaData.criteriaName || "",
      ...criteriaData
    };
    return await this.add(newCriteria);
  }
  async getPerformanceCriteriaById(criteriaId) {
    return await this.get(criteriaId);
  }
  async updatePerformanceCriteria(criteriaId, updates) {
    const criteria = await this.get(criteriaId);
    if (!criteria) throw new Error(`Performance criteria with id ${criteriaId} not found`);
    const updatedCriteria = { ...criteria, ...updates };
    const contextWithUpdate = this.context;
    if (contextWithUpdate.update) {
      return await contextWithUpdate.update(updatedCriteria);
    }
    throw new Error("Update operation not supported");
  }
  async deletePerformanceCriteria(criteriaId) {
    await this.remove(criteriaId);
    return true;
  }
  async getAllPerformanceCriteria() {
    return await this.getAll();
  }
  async getPerformanceCriteriaByName(name) {
    const criteria = await this.find({ criteriaName: { $regex: name, $options: "i" } });
    return criteria[0];
  }
  async searchPerformanceCriteria(query) {
    return await this.find({
      criteriaName: { $regex: query, $options: "i" }
    });
  }
}
class PerformanceReviewRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createPerformanceReview(reviewData) {
    throw new Error("Method not implemented");
  }
  async getPerformanceReviewById(reviewId) {
    return await this.get(reviewId);
  }
  async updatePerformanceReview(reviewId, updates) {
    throw new Error("Method not implemented");
  }
  async deletePerformanceReview(reviewId) {
    await this.remove(reviewId);
    return true;
  }
  async getPerformanceReviewsByEmployee(employeeId) {
    return await this.find({ employee: employeeId });
  }
  async getPerformanceReviewsByPeriod(periodStart, periodEnd) {
    return await this.find({
      period_start: periodStart,
      period_end: periodEnd
    });
  }
  async getPerformanceReviewsByReviewer(reviewerId) {
    return await this.find({ reviewerID: reviewerId });
  }
  async getPerformanceReviewsByStatus(status) {
    return await this.find({ status });
  }
  async getPerformanceReviewsByType(reviewType) {
    return await this.find({ reviewType });
  }
  async searchPerformanceReviews(query) {
    throw new Error("Method not implemented");
  }
}
class PerformanceScoreRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createPerformanceScore(scoreData) {
    throw new Error("Method not implemented");
  }
  async getPerformanceScoreById(scoreId) {
    return await this.get(scoreId);
  }
  async updatePerformanceScore(scoreId, updates) {
    throw new Error("Method not implemented");
  }
  async deletePerformanceScore(scoreId) {
    await this.remove(scoreId);
    return true;
  }
  async approvePerformanceScore(scoreId) {
    throw new Error("Method not implemented");
  }
  async getPerformanceScoresByEmployee(employeeId) {
    return await this.find({ employee: employeeId });
  }
  async getPerformanceScoresByPeriod(period) {
    return await this.find({ period_covered: period });
  }
  async getPerformanceScoresByGrade(grade) {
    return await this.find({ grade });
  }
  async getApprovedPerformanceScores() {
    return await this.find({ approval: true });
  }
  async searchPerformanceScores(query) {
    throw new Error("Method not implemented");
  }
}
class FeedbackRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createFeedback(feedbackData) {
    throw new Error("Method not implemented");
  }
  async getFeedbackById(feedbackId) {
    return await this.get(feedbackId);
  }
  async updateFeedback(feedbackId, updates) {
    throw new Error("Method not implemented");
  }
  async deleteFeedback(feedbackId) {
    await this.remove(feedbackId);
    return true;
  }
  async approveFeedback(feedbackId) {
    throw new Error("Method not implemented");
  }
  async getFeedbackByEmployee(employeeId) {
    return await this.find({ employee: employeeId });
  }
  async getFeedbackByPeriod(period) {
    return await this.find({ reviewPeriod: period });
  }
  async getFeedbackByGrade(grade) {
    return await this.find({ finalGrade: grade });
  }
  async getApprovedFeedback() {
    return await this.find({ approved: 1 });
  }
  async searchFeedback(query) {
    throw new Error("Method not implemented");
  }
}
class DepartmentRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createDepartment(deptData) {
    const newDept = {
      deptcode: deptData.deptcode || "",
      deptname: deptData.deptname || "",
      ...deptData
    };
    return await this.add(newDept);
  }
  async getDepartmentById(deptCode) {
    return await this.get(deptCode);
  }
  async updateDepartment(deptCode, updates) {
    const depts = await this.find({ deptcode: deptCode });
    if (!depts || depts.length === 0) {
      throw new Error(`Department with code ${deptCode} not found`);
    }
    const dept = depts[0];
    ({ ...dept, ...updates });
    const contextWithUpdate = this.context;
    if (contextWithUpdate.update) {
      return await contextWithUpdate.update(deptCode, updates, "deptcode");
    }
    throw new Error("Update operation not supported");
  }
  async deleteDepartment(deptCode) {
    const contextWithDelete = this.context;
    if (contextWithDelete.deleteById) {
      return await contextWithDelete.deleteById(deptCode, "deptcode");
    }
    await this.remove(deptCode);
    return true;
  }
  async getAllDepartments() {
    return await this.getAll();
  }
  async getDepartmentByName(name) {
    const depts = await this.find({ deptname: { $regex: name, $options: "i" } });
    return depts[0];
  }
  async searchDepartments(query) {
    return await this.find({
      deptname: { $regex: query, $options: "i" }
    });
  }
}
class BusinessGoalRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createBusinessGoal(goalData) {
    throw new Error("Method not implemented");
  }
  async getBusinessGoalById(goalId) {
    return await this.get(goalId);
  }
  async updateBusinessGoal(goalId, updates) {
    throw new Error("Method not implemented");
  }
  async deleteBusinessGoal(goalId) {
    await this.remove(goalId);
    return true;
  }
  async getBusinessGoalsByDepartment(deptCode) {
    return await this.find({ department: deptCode });
  }
  async getBusinessGoalsByCategory(category) {
    return await this.find({ goal_category: category });
  }
  async getBusinessGoalsByDateRange(startDate, endDate) {
    return await this.find({
      start_date: { $gte: startDate },
      end_date: { $lte: endDate }
    });
  }
  async searchBusinessGoals(query) {
    throw new Error("Method not implemented");
  }
}
class GoalCategoryRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createGoalCategory(categoryData) {
    throw new Error("Method not implemented");
  }
  async getGoalCategoryById(categoryId) {
    return await this.get(categoryId);
  }
  async updateGoalCategory(categoryId, updates) {
    throw new Error("Method not implemented");
  }
  async deleteGoalCategory(categoryId) {
    await this.remove(categoryId);
    return true;
  }
  async getAllGoalCategories() {
    return await this.getAll();
  }
  async getGoalCategoriesByType(type) {
    return await this.find({ category_type: type });
  }
  async getActiveGoalCategories() {
    return await this.find({ is_active: true });
  }
  async getGoalCategoryByName(name) {
    const categories = await this.find({ category_name: name });
    return categories[0];
  }
  async searchGoalCategories(query) {
    throw new Error("Method not implemented");
  }
}
class ManagerRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createManager(managerData) {
    throw new Error("Method not implemented");
  }
  async getManagerById(managerId) {
    return await this.get(managerId);
  }
  async updateManager(managerId, updates) {
    throw new Error("Method not implemented");
  }
  async deleteManager(managerId) {
    await this.remove(managerId);
    return true;
  }
  async getManagersByDepartment(deptCode) {
    return await this.find({ department: deptCode });
  }
  async getManagerByEmployeeId(employeeId) {
    const managers = await this.find({ employee_id: employeeId });
    return managers[0];
  }
  async getAllManagers() {
    return await this.getAll();
  }
  async getManagerHierarchy(managerId) {
    throw new Error("Method not implemented");
  }
  async getManagerByEmail(email2) {
    const managers = await this.find({ email: email2 });
    return managers[0];
  }
  async getDirectReports(managerId) {
    throw new Error("Method not implemented - requires cross-repository access");
  }
  async searchManagers(query) {
    throw new Error("Method not implemented");
  }
}
class PerformanceMetricRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createPerformanceMetric(metricData) {
    throw new Error("Method not implemented");
  }
  async getPerformanceMetricById(metricId) {
    return await this.get(metricId);
  }
  async updatePerformanceMetric(metricId, updates) {
    throw new Error("Method not implemented");
  }
  async deletePerformanceMetric(metricId) {
    await this.remove(metricId);
    return true;
  }
  async getPerformanceMetricsByCriteria(criteriaId) {
    return await this.find({ criteria_id: criteriaId });
  }
  async getAllPerformanceMetrics() {
    return await this.getAll();
  }
  async searchPerformanceMetrics(query) {
    throw new Error("Method not implemented");
  }
}
class GoalProgressRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createGoalProgress(progressData) {
    const newProgress = {
      progressID: progressData.progressID || Date.now(),
      goalID: progressData.goalID || 0,
      progress_percentage: progressData.progress_percentage || 0,
      progress_notes: progressData.progress_notes || "",
      milestones_completed: progressData.milestones_completed || "",
      progress_date: progressData.progress_date || /* @__PURE__ */ new Date(),
      updated_by: progressData.updated_by || "",
      ...progressData
    };
    if (progressData.progressID) {
      newProgress.id = newProgress.progressID;
    }
    return await this.add(newProgress);
  }
  async getGoalProgress(goalId) {
    return await this.find({ goalID: goalId });
  }
  async getLatestGoalProgress(goalId) {
    const list = await this.find({ goalID: goalId });
    if (!list || list.length === 0) return null;
    list.sort((a2, b2) => {
      const ta = a2.progress_date ? new Date(a2.progress_date).getTime() : a2.progressID;
      const tb = b2.progress_date ? new Date(b2.progress_date).getTime() : b2.progressID;
      return ta - tb;
    });
    return list[list.length - 1];
  }
  async updateGoalProgress(progressId, updates) {
    const updated = await this.update(progressId, updates, "id");
    return updated;
  }
  async deleteGoalProgress(progressId) {
    await this.deleteById(progressId, "id");
    return true;
  }
}
class AppraisalPeriodRepository extends Repository {
  constructor(dataContext) {
    super(dataContext);
  }
  async createAppraisalPeriod(periodData) {
    const newPeriod = {
      periodID: periodData.periodID || Date.now(),
      period_start: periodData.period_start || "",
      period_end: periodData.period_end || "",
      review_start_date: periodData.review_start_date || /* @__PURE__ */ new Date(),
      review_end_date: periodData.review_end_date || /* @__PURE__ */ new Date(),
      review_status: periodData.review_status || "scheduled",
      ...periodData
    };
    return await this.add(newPeriod);
  }
  async getAppraisalPeriodById(periodId) {
    const periods = await this.find({ periodID: periodId });
    if (!periods || periods.length === 0) {
      throw new Error(`Appraisal period with id ${periodId} not found`);
    }
    return periods[0];
  }
  async updateAppraisalPeriod(periodId, updates) {
    const periods = await this.find({ periodID: periodId });
    if (!periods || periods.length === 0) {
      throw new Error(`Appraisal period with id ${periodId} not found`);
    }
    const contextWithUpdate = this.context;
    if (contextWithUpdate.update) {
      return await contextWithUpdate.update(periodId, updates, "periodID");
    }
    throw new Error("Update operation not supported");
  }
  async deleteAppraisalPeriod(periodId) {
    const contextWithDelete = this.context;
    if (contextWithDelete.deleteById) {
      return await contextWithDelete.deleteById(periodId, "periodID");
    }
    await this.remove(periodId);
    return true;
  }
  async getAllAppraisalPeriods() {
    return await this.getAll();
  }
  async getAppraisalPeriodsByStatus(status) {
    return await this.find({ status });
  }
  async getCurrentAppraisalPeriod() {
    const currentDate = /* @__PURE__ */ new Date();
    const periods = await this.find({
      start_date: { $lte: currentDate },
      end_date: { $gte: currentDate }
    });
    return periods[0];
  }
  async getAppraisalPeriodsByDateRange(startDate, endDate) {
    return await this.find({
      start_date: { $gte: startDate },
      end_date: { $lte: endDate }
    });
  }
  async searchAppraisalPeriods(query) {
    throw new Error("Method not implemented");
  }
}
function getContext(ctx, source) {
  switch (ctx) {
    case "Local":
      return new LocalStoreContext(source);
    case "Supabase":
      return new SupabaseContext(source);
    case "PWA":
      return new PWAContext(source);
    default:
      return new LocalStoreContext(source);
  }
}
class RepoService {
  constructor(context) {
    this.UserContext = new UserRepository(getContext(context, "users"));
    this.EmployeeContext = new EmployeeRepository(getContext(context, "employees"));
    this.GoalContext = new GoalRepository(getContext(context, "goals"));
    this.DevelopmentPlanContext = new DevelopmentPlanRepository(getContext(context, "development_plans"));
    this.PerformanceCriteriaContext = new PerformanceCriteriaRepository(getContext(context, "performance_criteria"));
    this.PerformanceReviewContext = new PerformanceReviewRepository(getContext(context, "performance_reviews"));
    this.PerformanceScoreContext = new PerformanceScoreRepository(getContext(context, "performance_scores"));
    this.FeedbackContext = new FeedbackRepository(getContext(context, "feedback"));
    this.DepartmentContext = new DepartmentRepository(getContext(context, "departments"));
    this.BusinessGoalContext = new BusinessGoalRepository(getContext(context, "business_goals"));
    this.GoalCategoryContext = new GoalCategoryRepository(getContext(context, "goal_categories"));
    this.ManagerContext = new ManagerRepository(getContext(context, "managers"));
    this.PerformanceMetricContext = new PerformanceMetricRepository(getContext(context, "performance_metrics"));
    this.AppraisalPeriodContext = new AppraisalPeriodRepository(getContext(context, "appraisal_periods"));
    this.GoalProgressContext = new GoalProgressRepository(getContext(context, "goal_progress"));
  }
}
let repo = {};
try {
  repo = new RepoService("Supabase");
} catch (error2) {
  console.error("Failed to initialize repository service:", error2);
  repo = new RepoService("Local");
}
const repoService = repo;
const userRepository = repoService.UserContext;
const employeeRepository = repoService.EmployeeContext;
const goalRepository = repoService.GoalContext;
const developmentPlanRepository = repoService.DevelopmentPlanContext;
const performanceCriteriaRepository = repoService.PerformanceCriteriaContext;
const performanceReviewRepository = repoService.PerformanceReviewContext;
repoService.PerformanceScoreContext;
const feedbackRepository = repoService.FeedbackContext;
const departmentRepository = repoService.DepartmentContext;
const businessGoalRepository = repoService.BusinessGoalContext;
const goalCategoryRepository = repoService.GoalCategoryContext;
const managerRepository = repoService.ManagerContext;
const performanceMetricRepository = repoService.PerformanceMetricContext;
const appraisalPeriodRepository = repoService.AppraisalPeriodContext;
const goalProgressRepository = repoService.GoalProgressContext;
const RepoService$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RepoService,
  appraisalPeriodRepository,
  businessGoalRepository,
  departmentRepository,
  developmentPlanRepository,
  employeeRepository,
  feedbackRepository,
  goalCategoryRepository,
  goalProgressRepository,
  goalRepository,
  managerRepository,
  performanceCriteriaRepository,
  performanceMetricRepository,
  performanceReviewRepository,
  repoService,
  userRepository
}, Symbol.toStringTag, { value: "Module" }));
function $constructor(name, initializer2, params) {
  function init2(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _2,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer2(inst, def);
    const proto = _2.prototype;
    const keys = Object.keys(proto);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const k2 = keys[i2];
      if (!(k2 in inst)) {
        inst[k2] = proto[k2].bind(inst);
      }
    }
  }
  const Parent = (params == null ? void 0 : params.Parent) ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _2(def) {
    var _a2;
    const inst = (params == null ? void 0 : params.Parent) ? new Definition() : this;
    init2(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_2, "init", { value: init2 });
  Object.defineProperty(_2, Symbol.hasInstance, {
    value: (inst) => {
      var _a2, _b;
      if ((params == null ? void 0 : params.Parent) && inst instanceof params.Parent)
        return true;
      return (_b = (_a2 = inst == null ? void 0 : inst._zod) == null ? void 0 : _a2.traits) == null ? void 0 : _b.has(name);
    }
  });
  Object.defineProperty(_2, "name", { value: name });
  return _2;
}
class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}
class $ZodEncodeError extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
}
const globalConfig = {};
function config(newConfig) {
  return globalConfig;
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v2) => typeof v2 === "number");
  const values = Object.entries(entries).filter(([k2, _2]) => numericValues.indexOf(+k2) === -1).map(([_2, v2]) => v2);
  return values;
}
function jsonStringifyReplacer(_2, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  return {
    get value() {
      {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match == null ? void 0 : match[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
const EVALUATING = Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v2) {
      Object.defineProperty(object2, key, {
        value: v2
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject$1(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
  var _a2;
  if (typeof navigator !== "undefined" && ((_a2 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a2.includes("Cloudflare"))) {
    return false;
  }
  try {
    const F2 = Function;
    new F2("");
    return true;
  } catch (_2) {
    return false;
  }
});
function isPlainObject(o2) {
  if (isObject$1(o2) === false)
    return false;
  const ctor = o2.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject$1(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o2) {
  if (isPlainObject(o2))
    return { ...o2 };
  if (Array.isArray(o2))
    return [...o2];
  return o2;
}
const propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || (params == null ? void 0 : params.parent))
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if ((params == null ? void 0 : params.message) !== void 0) {
    if ((params == null ? void 0 : params.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k2) => {
    return shape[k2]._zod.optin === "optional" && shape[k2]._zod.optout === "optional";
  });
}
const NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function pick$1(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit$1(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone(schema, def);
}
function merge(a2, b2) {
  const def = mergeDefs(a2._zod.def, {
    get shape() {
      const _shape = { ...a2._zod.def.shape, ...b2._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b2._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a2, def);
}
function partial(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function aborted(x2, startIndex = 0) {
  var _a2;
  if (x2.aborted === true)
    return true;
  for (let i2 = startIndex; i2 < x2.issues.length; i2++) {
    if (((_a2 = x2.issues[i2]) == null ? void 0 : _a2.continue) !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message == null ? void 0 : message.message;
}
function finalizeIssue(iss, ctx, config2) {
  var _a2, _b, _c, _d, _e, _f;
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage((_c = (_b = (_a2 = iss.inst) == null ? void 0 : _a2._zod.def) == null ? void 0 : _b.error) == null ? void 0 : _c.call(_b, iss)) ?? unwrapMessage((_d = ctx == null ? void 0 : ctx.error) == null ? void 0 : _d.call(ctx, iss)) ?? unwrapMessage((_e = config2.customError) == null ? void 0 : _e.call(config2, iss)) ?? unwrapMessage((_f = config2.localeError) == null ? void 0 : _f.call(config2, iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!(ctx == null ? void 0 : ctx.reportInput)) {
    delete full.input;
  }
  return full;
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
const initializer$1 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error2, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error2.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error2, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error3) => {
    for (const issue2 of error3.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i2 = 0;
        while (i2 < issue2.path.length) {
          const el = issue2.path[i2];
          const terminal = i2 === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i2++;
        }
      }
    }
  };
  processError(error2);
  return fieldErrors;
}
const _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e2 = new ((_params == null ? void 0 : _params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, _params == null ? void 0 : _params.callee);
    throw e2;
  }
  return result.value;
};
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e2 = new ((params == null ? void 0 : params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, params == null ? void 0 : params.callee);
    throw e2;
  }
  return result.value;
};
const _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
const safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
const _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
const _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
const _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
const uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$2 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time$1(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string$1 = (params) => {
  const regex = params ? `[\\s\\S]{${(params == null ? void 0 : params.minimum) ?? 0},${(params == null ? void 0 : params.maximum) ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
const integer = /^-?\d+$/;
const number$1 = /^-?\d+(?:\.\d+)?/;
const boolean$1 = /^(?:true|false)$/i;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
const numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = (_a2 = def.format) == null ? void 0 : _a2.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x2) => x2);
    const minIndent = Math.min(...lines.map((x2) => x2.length - x2.trimStart().length));
    const dedented = lines.map((x2) => x2.slice(minIndent)).map((x2) => " ".repeat(this.indent * 2) + x2);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F2 = Function;
    const args = this == null ? void 0 : this.args;
    const content = (this == null ? void 0 : this.content) ?? [``];
    const lines = [...content.map((x2) => `  ${x2}`)];
    return new F2(...args, lines.join("\n"));
  }
}
const version = {
  major: 4,
  minor: 1,
  patch: 13
};
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a3;
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    (_a3 = inst._zod.deferred) == null ? void 0 : _a3.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _2 = ch._zod.check(payload);
        if (_2 instanceof Promise && (ctx == null ? void 0 : ctx.async) === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _2 instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _2;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      var _a4;
      try {
        const r2 = safeParse$1(inst, value);
        return r2.success ? { value: r2.data } : { issues: (_a4 = r2.error) == null ? void 0 : _a4.issues };
      } catch (_2) {
        return safeParseAsync$1(inst, value).then((r2) => {
          var _a5;
          return r2.success ? { value: r2.data } : { issues: (_a5 = r2.error) == null ? void 0 : _a5.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  };
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  var _a2;
  $ZodType.init(inst, def);
  inst._zod.pattern = [...((_a2 = inst == null ? void 0 : inst._zod.bag) == null ? void 0 : _a2.patterns) ?? []].pop() ?? string$1(inst._zod.bag);
  inst._zod.parse = (payload, _2) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_3) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v2 = versionMap[def.version];
    if (v2 === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v2));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_2) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date$2);
  $ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c2) => c2 === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && (parsedHeader == null ? void 0 : parsedHeader.typ) !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number$1;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_2) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean$1;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_2) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
const $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index2) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index2, result.issues));
  }
  final.value[index2] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const item = input[i2];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i2)));
      } else {
        handleArrayResult(result, payload, i2);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  var _a2, _b, _c, _d;
  const keys = Object.keys(def.shape);
  for (const k2 of keys) {
    if (!((_d = (_c = (_b = (_a2 = def.shape) == null ? void 0 : _a2[k2]) == null ? void 0 : _b._zod) == null ? void 0 : _c.traits) == null ? void 0 : _d.has("$ZodType"))) {
      throw new Error(`Invalid element at key "${k2}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t2 = _catchall.def.type;
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t2 === "never") {
      unrecognized.push(key);
      continue;
    }
    const r2 = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r2 instanceof Promise) {
      proms.push(r2.then((r3) => handlePropertyResult(r3, payload, key, input)));
    } else {
      handlePropertyResult(r2, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!(desc == null ? void 0 : desc.get)) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v2 of field.values)
          propValues[key].add(v2);
      }
    }
    return propValues;
  });
  const isObject2 = isObject$1;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r2 = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r2 instanceof Promise) {
        proms.push(r2.then((r3) => handlePropertyResult(r3, payload, key, input)));
      } else {
        handlePropertyResult(r2, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
const $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k2 = esc(key);
      return `shape[${k2}]._zod.run({ value: input[${k2}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k2 = esc(key);
      doc.write(`const ${id} = ${parseStr(key)};`);
      doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k2}, ...iss.path] : [${k2}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k2} in input) {
            newResult[${k2}] = undefined;
          }
        } else {
          newResult[${k2}] = ${id}.value;
        }
        
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject$1;
  const jit = !globalConfig.jitless;
  const allowsEval$1 = allowsEval;
  const fastEnabled = jit && allowsEval$1.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && (ctx == null ? void 0 : ctx.async) === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r2) => !aborted(r2));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o2) => o2._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o2) => o2._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o2) => o2._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o2) => o2._zod.pattern)) {
      const patterns = def.options.map((o2) => o2._zod.pattern);
      return new RegExp(`^(${patterns.map((p2) => cleanRegex(p2.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a2, b2) {
  if (a2 === b2) {
    return { valid: true, data: a2 };
  }
  if (a2 instanceof Date && b2 instanceof Date && +a2 === +b2) {
    return { valid: true, data: a2 };
  }
  if (isPlainObject(a2) && isPlainObject(b2)) {
    const bKeys = Object.keys(b2);
    const sharedKeys = Object.keys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a2) && Array.isArray(b2)) {
    if (a2.length !== b2.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index2, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k2) => propertyKeyTypes.has(typeof k2)).map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r2) => handleOptionalResult(r2, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v2 = def.innerType._zod.values;
    return v2 ? new Set([...v2].filter((x2) => x2 !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => {
    var _a2, _b;
    return (_b = (_a2 = def.innerType) == null ? void 0 : _a2._zod) == null ? void 0 : _b.optin;
  });
  defineLazy(inst._zod, "optout", () => {
    var _a2, _b;
    return (_b = (_a2 = def.innerType) == null ? void 0 : _a2._zod) == null ? void 0 : _b.optout;
  });
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _2) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r2 = def.fn(input);
    if (r2 instanceof Promise) {
      return r2.then((r3) => handleRefineResult(r3, payload, input, inst));
    }
    handleRefineResult(r2, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var _a;
class $ZodRegistry {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p2 = schema._zod.parent;
    if (p2) {
      const pm = { ...this.get(p2) ?? {} };
      delete pm.id;
      const f2 = { ...pm, ...this._map.get(schema) };
      return Object.keys(f2).length ? f2 : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
const globalRegistry = globalThis.__zod_globalRegistry;
function _string(Class, params) {
  return new Class({
    type: "string",
    ...normalizeParams(params)
  });
}
function _email(Class, params) {
  return new Class({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class, params) {
  return new Class({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class, params) {
  return new Class({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji(Class, params) {
  return new Class({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class, params) {
  return new Class({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class, params) {
  return new Class({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class, params) {
  return new Class({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class, params) {
  return new Class({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class, params) {
  return new Class({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class, params) {
  return new Class({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class, params) {
  return new Class({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class, params) {
  return new Class({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class, params) {
  return new Class({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class, params) {
  return new Class({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class, params) {
  return new Class({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class, params) {
  return new Class({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class, params) {
  return new Class({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class, params) {
  return new Class({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class, params) {
  return new Class({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class, params) {
  return new Class({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class, params) {
  return new Class({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class, params) {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _boolean(Class, params) {
  return new Class({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _unknown(Class) {
  return new Class({
    type: "unknown"
  });
}
function _never(Class, params) {
  return new Class({
    type: "never",
    ...normalizeParams(params)
  });
}
function _date(Class, params) {
  return new Class({
    type: "date",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _slugify() {
  return _overwrite((input) => slugify(input));
}
function _array(Class, element, params) {
  return new Class({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _refine(Class, fn, _params) {
  const schema = new Class({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime(params) {
  return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date$1(params) {
  return _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time(params) {
  return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration(params) {
  return _isoDuration(ZodISODuration, params);
}
const initializer = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
const ZodError = $constructor("ZodError", initializer);
const ZodRealError = $constructor("ZodError", initializer, {
  Parent: Error
});
const parse = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
const encode = /* @__PURE__ */ _encode(ZodRealError);
const decode = /* @__PURE__ */ _decode(ZodRealError);
const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
const ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }));
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta) => {
    reg.add(inst, meta);
    return inst;
  });
  inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode(inst, data, params);
  inst.decode = (data, params) => decode(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      var _a2;
      return (_a2 = globalRegistry.get(inst)) == null ? void 0 : _a2.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
  inst.slugify = () => inst.check(_slugify());
});
const ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime(params));
  inst.date = (params) => inst.check(date$1(params));
  inst.time = (params) => inst.check(time(params));
  inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
  return _string(ZodString, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number(params) {
  return _number(ZodNumber, params);
}
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
const ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean(params) {
  return _boolean(ZodBoolean, params);
}
const ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
const ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c2 = inst._zod.bag;
  inst.minDate = c2.minimum ? new Date(c2.minimum) : null;
  inst.maxDate = c2.maximum ? new Date(c2.maximum) : null;
});
function date(params) {
  return _date(ZodDate, params);
}
const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return safeExtend(inst, incoming);
  };
  inst.merge = (other) => merge(inst, other);
  inst.pick = (mask) => pick$1(inst, mask);
  inst.omit = (mask) => omit$1(inst, mask);
  inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...normalizeParams(params)
  };
  return new ZodObject(def);
}
const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v2) => [v2, v2])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
const CreateUserCommandSchema = object({
  email: string().email("Invalid email format"),
  password: string().min(8, "Password must be at least 8 characters"),
  name: string().min(1, "Name is required"),
  userType: _enum(["admin", "manager", "employee"]).optional().default("employee"),
  employeeId: string().optional()
});
const UpdateProfileCommandSchema = object({
  userId: string(),
  updates: object({
    name: string().min(1).optional(),
    email: string().email().optional(),
    userType: _enum(["admin", "manager", "employee"]).optional(),
    employeeId: string().optional(),
    isActive: boolean().optional()
  })
});
const ChangePasswordCommandSchema = object({
  userId: string(),
  currentPassword: string().min(1, "Current password is required"),
  newPassword: string().min(8, "New password must be at least 8 characters")
});
const UploadProfilePictureCommandSchema = object({
  userId: string(),
  file: _instanceof(File)
});
const DeleteUserCommandSchema = object({
  userId: string(),
  deletedBy: string()
  // User ID of the admin/manager performing deletion
});
const LoginCommandSchema = object({
  email: string().email("Invalid email format"),
  password: string().min(1, "Password is required")
});
function createUserCommandHandler(bus) {
  const messageName = "CreateUserCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = CreateUserCommandSchema.parse(message);
      console.log(`[USER COMMAND HANDLER] Creating user: ${validatedData.email}`);
      const newUser = await userRepository.createUser(validatedData);
      const result = {
        userId: newUser.userID || "",
        success: true,
        message: "User created successfully"
      };
      resolve(result);
      bus.publish("UserCreatedNotification", {
        userId: newUser.userID,
        email: validatedData.email,
        name: validatedData.name
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[USER COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[USER COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to create user"));
      }
    }
  });
}
function updateProfileCommandHandler(bus) {
  const messageName = "UpdateProfileCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = UpdateProfileCommandSchema.parse(message);
      console.log(`[USER COMMAND HANDLER] Updating profile for user: ${validatedData.userId}`);
      const updatedUser = await userRepository.updateProfile(validatedData.updates);
      const result = {
        user: updatedUser,
        success: true,
        message: "Profile updated successfully"
      };
      resolve(result);
      bus.publish("UserProfileUpdatedNotification", {
        userId: validatedData.userId,
        updatedFields: Object.keys(validatedData.updates)
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[USER COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[USER COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to update profile"));
      }
    }
  });
}
function changePasswordCommandHandler(bus) {
  const messageName = "ChangePasswordCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = ChangePasswordCommandSchema.parse(message);
      console.log(`[USER COMMAND HANDLER] Changing password for user: ${validatedData.userId}`);
      const success = await userRepository.changePassword(
        validatedData.currentPassword,
        validatedData.newPassword
      );
      const result = {
        success,
        message: success ? "Password changed successfully" : "Failed to change password"
      };
      resolve(result);
      if (success) {
        bus.publish("UserPasswordChangedNotification", {
          userId: validatedData.userId
        });
      }
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[USER COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[USER COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to change password"));
      }
    }
  });
}
function uploadProfilePictureCommandHandler(bus) {
  const messageName = "UploadProfilePictureCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = UploadProfilePictureCommandSchema.parse(message);
      console.log(`[USER COMMAND HANDLER] Uploading profile picture for user: ${validatedData.userId}`);
      const fileUrl = await userRepository.uploadProfilePicture(validatedData.file);
      const result = {
        success: true,
        message: "Profile picture uploaded successfully",
        fileUrl
      };
      resolve(result);
      bus.publish("UserProfilePictureUpdatedNotification", {
        userId: validatedData.userId,
        fileUrl
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[USER COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[USER COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to upload profile picture"));
      }
    }
  });
}
function deleteUserCommandHandler(bus) {
  const messageName = "DeleteUserCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = DeleteUserCommandSchema.parse(message);
      console.error(`[USER COMMAND HANDLER] Deleting user: ${validatedData.userId} by ${validatedData.deletedBy}`);
      try {
        const foundByEmail = await userRepository.find({ email: validatedData.userId });
        const foundByUserId = await userRepository.find({ userID: validatedData.userId });
        const foundByID = !isNaN(Number(validatedData.userId)) ? await userRepository.find({ ID: Number(validatedData.userId) }) : [];
        console.error(`[USER COMMAND HANDLER] find by email result count: ${foundByEmail.length}`);
        console.error(`[USER COMMAND HANDLER] find by userID result count: ${foundByUserId.length}`);
        console.error(`[USER COMMAND HANDLER] find by ID result count: ${foundByID.length}`);
        if (foundByEmail.length > 0) console.error("Found by email:", foundByEmail[0]);
        if (foundByUserId.length > 0) console.error("Found by userID:", foundByUserId[0]);
        if (foundByID.length > 0) console.error("Found by ID:", foundByID[0]);
      } catch (err) {
        console.warn("[USER COMMAND HANDLER] Error during debug lookup:", err);
      }
      const success = await userRepository.deleteUser(validatedData.userId);
      const result = {
        success,
        message: success ? "User deleted successfully" : "Failed to delete user"
      };
      resolve(result);
      if (success) {
        bus.publish("UserDeletedNotification", {
          userId: validatedData.userId,
          deletedBy: validatedData.deletedBy
        });
      }
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[USER COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[USER COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to delete user"));
      }
    }
  });
}
function loginCommandHandler(bus) {
  const messageName = "LoginCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = LoginCommandSchema.parse(message);
      console.log(`[USER COMMAND HANDLER] Authenticating user: ${validatedData.email}`);
      const loginResult = await userRepository.login(validatedData.email, validatedData.password);
      const result = {
        user: loginResult.user,
        access_token: loginResult.access_token,
        token_type: loginResult.token_type,
        success: true,
        message: "Login successful"
      };
      resolve(result);
      bus.publish("UserLoggedInNotification", {
        userId: loginResult.user.userID,
        email: validatedData.email
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[USER COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[USER COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Invalid email or password"));
      }
    }
  });
}
const GetCurrentUserQuerySchema = object({
  // No parameters needed - uses authenticated user context
});
const GetUserByIdQuerySchema = object({
  userId: string()
});
const GetAllUsersQuerySchema = object({
  page: number().min(1).optional().default(1),
  limit: number().min(1).max(100).optional().default(20),
  sortBy: _enum(["name", "email", "createdAt"]).optional().default("name"),
  sortOrder: _enum(["asc", "desc"]).optional().default("asc")
});
const GetUsersByTypeQuerySchema = object({
  userType: _enum(["admin", "manager", "employee"]),
  page: number().min(1).optional().default(1),
  limit: number().min(1).max(100).optional().default(20)
});
const GetUsersByEmployeeIdQuerySchema = object({
  employeeId: string()
});
const SearchUsersQuerySchema = object({
  query: string().min(1, "Search query is required"),
  userType: _enum(["admin", "manager", "employee"]).optional(),
  page: number().min(1).optional().default(1),
  limit: number().min(1).max(100).optional().default(20)
});
function getCurrentUserQueryHandler(bus) {
  const messageName = "GetCurrentUserQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetCurrentUserQuerySchema.parse(message);
      console.log(`[USER QUERY HANDLER] Getting current user`);
      const user = await userRepository.getCurrentUser();
      console.log("Retrieved user:", user);
      const result = {
        user,
        success: true,
        message: "Current user retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[USER QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[USER QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get current user"));
      }
    }
  });
}
function getUserByIdQueryHandler(bus) {
  const messageName = "GetUserByIdQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetUserByIdQuerySchema.parse(message);
      console.log(`[USER QUERY HANDLER] Getting user by ID: ${validatedData.userId}`);
      const user = await userRepository.getUserById(validatedData.userId);
      const result = {
        user,
        success: true,
        message: "User retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[USER QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[USER QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get user by ID"));
      }
    }
  });
}
function getAllUsersQueryHandler(bus) {
  const messageName = "GetAllUsersQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetAllUsersQuerySchema.parse(message);
      console.log(`[USER QUERY HANDLER] Getting all users - page: ${validatedData.page}, limit: ${validatedData.limit}`);
      const users = await userRepository.getAllUsers();
      const startIndex = (validatedData.page - 1) * validatedData.limit;
      const endIndex = startIndex + validatedData.limit;
      const paginatedUsers = users.slice(startIndex, endIndex);
      const totalPages = Math.ceil(users.length / validatedData.limit);
      const result = {
        users: paginatedUsers,
        total: users.length,
        page: validatedData.page,
        limit: validatedData.limit,
        totalPages,
        success: true,
        message: "Users retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[USER QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[USER QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get all users"));
      }
    }
  });
}
function getUsersByTypeQueryHandler(bus) {
  const messageName = "GetUsersByTypeQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetUsersByTypeQuerySchema.parse(message);
      console.log(`[USER QUERY HANDLER] Getting users by type: ${validatedData.userType}`);
      const users = await userRepository.getUsersByType(validatedData.userType);
      const startIndex = (validatedData.page - 1) * validatedData.limit;
      const endIndex = startIndex + validatedData.limit;
      const paginatedUsers = users.slice(startIndex, endIndex);
      const result = {
        users: paginatedUsers,
        total: users.length,
        page: validatedData.page,
        limit: validatedData.limit,
        success: true,
        message: "Users retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[USER QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[USER QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get users by type"));
      }
    }
  });
}
function getUsersByEmployeeIdQueryHandler(bus) {
  const messageName = "GetUsersByEmployeeIdQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetUsersByEmployeeIdQuerySchema.parse(message);
      console.log(`[USER QUERY HANDLER] Getting users by employee ID: ${validatedData.employeeId}`);
      const users = await userRepository.getUsersByEmployeeId(validatedData.employeeId);
      const result = {
        users,
        success: true,
        message: "Users retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[USER QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[USER QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get users by employee ID"));
      }
    }
  });
}
function searchUsersQueryHandler(bus) {
  const messageName = "SearchUsersQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = SearchUsersQuerySchema.parse(message);
      console.log(`[USER QUERY HANDLER] Searching users with query: ${validatedData.query}`);
      const users = await userRepository.searchUsers(validatedData.query);
      let filteredUsers = users;
      if (validatedData.userType) {
        filteredUsers = users.filter((user) => user.userType === validatedData.userType);
      }
      const startIndex = (validatedData.page - 1) * validatedData.limit;
      const endIndex = startIndex + validatedData.limit;
      const paginatedUsers = filteredUsers.slice(startIndex, endIndex);
      const result = {
        users: paginatedUsers,
        total: filteredUsers.length,
        page: validatedData.page,
        limit: validatedData.limit,
        success: true,
        message: "Users search completed successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[USER QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[USER QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to search users"));
      }
    }
  });
}
const UpdateEmployeeProfileCommandSchema = object({
  employeeId: string(),
  updates: object({
    title: string().optional(),
    firstname: string().optional(),
    lastname: string().optional(),
    gender: string().optional(),
    phonenumber: string().optional(),
    address: string().optional(),
    ethnicity: string().optional(),
    deptcode: string().optional(),
    managerID: string().optional(),
    job_role: string().optional(),
    contract_type: string().optional(),
    employment_date: date().optional(),
    branch: string().optional(),
    training: string().optional(),
    certification: string().optional(),
    skills: string().optional(),
    interests: string().optional(),
    status: string().optional()
  })
});
const DeleteEmployeeCommandSchema = object({
  employeeId: string(),
  deletedBy: string()
});
function updateEmployeeProfileCommandHandler(bus) {
  const messageName = "UpdateEmployeeProfileCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = UpdateEmployeeProfileCommandSchema.parse(message);
      console.log(`[EMPLOYEE COMMAND HANDLER] Updating profile for employee: ${validatedData.employeeId}`);
      const updatedEmployee = await employeeRepository.updateEmployeeProfile(validatedData.updates);
      const result = {
        employee: updatedEmployee,
        success: true,
        message: "Employee profile updated successfully"
      };
      resolve(result);
      bus.publish("EmployeeProfileUpdatedNotification", {
        employeeId: validatedData.employeeId,
        updatedFields: Object.keys(validatedData.updates)
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[EMPLOYEE COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[EMPLOYEE COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to update employee profile"));
      }
    }
  });
}
function deleteEmployeeCommandHandler(bus) {
  const messageName = "DeleteEmployeeCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = DeleteEmployeeCommandSchema.parse(message);
      console.log(`[EMPLOYEE COMMAND HANDLER] Deleting employee: ${validatedData.employeeId}`);
      const success = await employeeRepository.deleteEmployee(validatedData.employeeId);
      if (!success) {
        resolve(new Error("Employee not found"));
        return;
      }
      const result = {
        success: true,
        message: "Employee deleted successfully"
      };
      resolve(result);
      bus.publish("EmployeeDeletedNotification", {
        employeeId: validatedData.employeeId,
        deletedBy: validatedData.deletedBy
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[EMPLOYEE COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[EMPLOYEE COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to delete employee"));
      }
    }
  });
}
const GetAllEmployeesQuerySchema = object({
  page: number().min(1).optional().default(1),
  limit: number().min(1).max(100).optional().default(50)
});
const GetCurrentEmployeeQuerySchema = object({
  // No parameters needed - uses authenticated user context
});
const GetEmployeeProfileQuerySchema = object({
  // No parameters needed - uses authenticated user context
});
const GetEmployeesByDepartmentQuerySchema = object({
  deptCode: string(),
  page: number().min(1).optional().default(1),
  limit: number().min(1).max(100).optional().default(20)
});
const GetEmployeesByManagerQuerySchema = object({
  managerId: string(),
  page: number().min(1).optional().default(1),
  limit: number().min(1).max(100).optional().default(20)
});
const GetEmployeesByStatusQuerySchema = object({
  status: string(),
  page: number().min(1).optional().default(1),
  limit: number().min(1).max(100).optional().default(20)
});
const SearchEmployeesQuerySchema = object({
  query: string().min(1, "Search query is required"),
  page: number().min(1).optional().default(1),
  limit: number().min(1).max(100).optional().default(20)
});
const GetEmployeesByJobRoleQuerySchema = object({
  jobRole: string(),
  page: number().min(1).optional().default(1),
  limit: number().min(1).max(100).optional().default(20)
});
const GetEmployeesByContractTypeQuerySchema = object({
  contractType: string(),
  page: number().min(1).optional().default(1),
  limit: number().min(1).max(100).optional().default(20)
});
function getAllEmployeesQueryHandler(bus) {
  const messageName = "GetAllEmployeesQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetAllEmployeesQuerySchema.parse(message);
      console.log(`[EMPLOYEE QUERY HANDLER] Getting all employees`);
      const employees = await employeeRepository.find({});
      const startIndex = (validatedData.page - 1) * validatedData.limit;
      const endIndex = startIndex + validatedData.limit;
      const paginatedEmployees = employees.slice(startIndex, endIndex);
      const result = {
        employees: paginatedEmployees,
        total: employees.length,
        page: validatedData.page,
        limit: validatedData.limit,
        success: true,
        message: "All employees retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[EMPLOYEE QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[EMPLOYEE QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get all employees"));
      }
    }
  });
}
function getCurrentEmployeeQueryHandler(bus) {
  const messageName = "GetCurrentEmployeeQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetCurrentEmployeeQuerySchema.parse(message);
      console.log(`[EMPLOYEE QUERY HANDLER] Getting current employee`);
      const employee = await employeeRepository.getCurrentEmployee();
      const result = {
        employee,
        success: true,
        message: "Current employee retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[EMPLOYEE QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[EMPLOYEE QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get current employee"));
      }
    }
  });
}
function getEmployeeProfileQueryHandler(bus) {
  const messageName = "GetEmployeeProfileQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetEmployeeProfileQuerySchema.parse(message);
      console.log(`[EMPLOYEE QUERY HANDLER] Getting employee profile`);
      const employee = await employeeRepository.getEmployeeProfile();
      const result = {
        employee,
        success: true,
        message: "Employee profile retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[EMPLOYEE QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[EMPLOYEE QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get employee profile"));
      }
    }
  });
}
function getEmployeesByDepartmentQueryHandler(bus) {
  const messageName = "GetEmployeesByDepartmentQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetEmployeesByDepartmentQuerySchema.parse(message);
      console.log(`[EMPLOYEE QUERY HANDLER] Getting employees by department: ${validatedData.deptCode}`);
      const employees = await employeeRepository.getEmployeesByDepartment(validatedData.deptCode);
      const startIndex = (validatedData.page - 1) * validatedData.limit;
      const endIndex = startIndex + validatedData.limit;
      const paginatedEmployees = employees.slice(startIndex, endIndex);
      const result = {
        employees: paginatedEmployees,
        total: employees.length,
        page: validatedData.page,
        limit: validatedData.limit,
        success: true,
        message: "Employees retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[EMPLOYEE QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[EMPLOYEE QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get employees by department"));
      }
    }
  });
}
function getEmployeesByManagerQueryHandler(bus) {
  const messageName = "GetEmployeesByManagerQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetEmployeesByManagerQuerySchema.parse(message);
      console.log(`[EMPLOYEE QUERY HANDLER] Getting employees by manager: ${validatedData.managerId}`);
      const employees = await employeeRepository.getEmployeesByManager(validatedData.managerId);
      const startIndex = (validatedData.page - 1) * validatedData.limit;
      const endIndex = startIndex + validatedData.limit;
      const paginatedEmployees = employees.slice(startIndex, endIndex);
      const result = {
        employees: paginatedEmployees,
        total: employees.length,
        page: validatedData.page,
        limit: validatedData.limit,
        success: true,
        message: "Employees retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[EMPLOYEE QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[EMPLOYEE QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get employees by manager"));
      }
    }
  });
}
function getEmployeesByStatusQueryHandler(bus) {
  const messageName = "GetEmployeesByStatusQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetEmployeesByStatusQuerySchema.parse(message);
      console.log(`[EMPLOYEE QUERY HANDLER] Getting employees by status: ${validatedData.status}`);
      const employees = await employeeRepository.getEmployeesByStatus(validatedData.status);
      const startIndex = (validatedData.page - 1) * validatedData.limit;
      const endIndex = startIndex + validatedData.limit;
      const paginatedEmployees = employees.slice(startIndex, endIndex);
      const result = {
        employees: paginatedEmployees,
        total: employees.length,
        page: validatedData.page,
        limit: validatedData.limit,
        success: true,
        message: "Employees retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[EMPLOYEE QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[EMPLOYEE QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get employees by status"));
      }
    }
  });
}
function searchEmployeesQueryHandler(bus) {
  const messageName = "SearchEmployeesQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = SearchEmployeesQuerySchema.parse(message);
      console.log(`[EMPLOYEE QUERY HANDLER] Searching employees with query: ${validatedData.query}`);
      const employees = await employeeRepository.searchEmployees(validatedData.query);
      const startIndex = (validatedData.page - 1) * validatedData.limit;
      const endIndex = startIndex + validatedData.limit;
      const paginatedEmployees = employees.slice(startIndex, endIndex);
      const result = {
        employees: paginatedEmployees,
        total: employees.length,
        page: validatedData.page,
        limit: validatedData.limit,
        success: true,
        message: "Employee search completed successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[EMPLOYEE QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[EMPLOYEE QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to search employees"));
      }
    }
  });
}
function getEmployeesByJobRoleQueryHandler(bus) {
  const messageName = "GetEmployeesByJobRoleQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetEmployeesByJobRoleQuerySchema.parse(message);
      console.log(`[EMPLOYEE QUERY HANDLER] Getting employees by job role: ${validatedData.jobRole}`);
      const employees = await employeeRepository.getEmployeesByJobRole(validatedData.jobRole);
      const startIndex = (validatedData.page - 1) * validatedData.limit;
      const endIndex = startIndex + validatedData.limit;
      const paginatedEmployees = employees.slice(startIndex, endIndex);
      const result = {
        employees: paginatedEmployees,
        total: employees.length,
        page: validatedData.page,
        limit: validatedData.limit,
        success: true,
        message: "Employees retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[EMPLOYEE QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[EMPLOYEE QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get employees by job role"));
      }
    }
  });
}
function getEmployeesByContractTypeQueryHandler(bus) {
  const messageName = "GetEmployeesByContractTypeQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetEmployeesByContractTypeQuerySchema.parse(message);
      console.log(`[EMPLOYEE QUERY HANDLER] Getting employees by contract type: ${validatedData.contractType}`);
      const employees = await employeeRepository.getEmployeesByContractType(validatedData.contractType);
      const startIndex = (validatedData.page - 1) * validatedData.limit;
      const endIndex = startIndex + validatedData.limit;
      const paginatedEmployees = employees.slice(startIndex, endIndex);
      const result = {
        employees: paginatedEmployees,
        total: employees.length,
        page: validatedData.page,
        limit: validatedData.limit,
        success: true,
        message: "Employees retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[EMPLOYEE QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[EMPLOYEE QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(new Error("Failed to get employees by contract type"));
      }
    }
  });
}
const CreateGoalCommandSchema = object({
  busgoal: string().optional(),
  employee: string().min(1, "Employee ID is required"),
  ID: string().optional(),
  goal_title: string().min(3, "Goal title must be at least 3 characters"),
  goal_description: string().min(5, "Goal description must be at least 5 characters"),
  key_result: string().optional(),
  projected_start_date: union([date(), string()]).optional(),
  projected_target_date: union([date(), string()]).optional(),
  appraisal_period: string().optional()
});
const UpdateGoalCommandSchema = object({
  goalID: number(),
  updates: object({
    goal_title: string().optional(),
    goal_description: string().optional(),
    key_result: string().optional(),
    projected_start_date: union([date(), string()]).optional(),
    projected_target_date: union([date(), string()]).optional(),
    goal_progress: number().min(0).max(100).optional(),
    goal_status: string().optional()
  })
});
const DeleteGoalCommandSchema = object({
  goalID: number()
});
const ApproveGoalCommandSchema = object({
  goalID: number()
});
const RejectGoalCommandSchema = object({
  goalID: number(),
  reason: string().optional()
});
const CreateGoalProgressCommandSchema = object({
  goalID: number(),
  progress_percentage: number().min(0).max(100),
  progress_notes: string().optional(),
  updated_by: string().optional()
});
function createGoalCommandHandler(bus) {
  const messageName = "CreateGoalCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = CreateGoalCommandSchema.parse(message);
      console.log(`[GOAL COMMAND HANDLER] Creating goal: ${validatedData.goal_title}`);
      if (validatedData.busgoal) {
        try {
          const businessGoals = await businessGoalRepository.find({ busgoalID: validatedData.busgoal });
          if (!businessGoals || businessGoals.length === 0) {
            resolve(new Error(`Business goal with ID ${validatedData.busgoal} not found`));
            return;
          }
        } catch (err) {
          resolve(new Error(`Business goal with ID ${validatedData.busgoal} not found`));
          return;
        }
      }
      const newGoal = await goalRepository.createGoal({
        busgoal: validatedData.busgoal || "",
        employee: validatedData.employee,
        ID: validatedData.ID || "",
        goal_title: validatedData.goal_title,
        goal_description: validatedData.goal_description,
        key_result: validatedData.key_result || "",
        projected_start_date: validatedData.projected_start_date ? new Date(validatedData.projected_start_date) : /* @__PURE__ */ new Date(),
        projected_target_date: validatedData.projected_target_date ? new Date(validatedData.projected_target_date) : /* @__PURE__ */ new Date(),
        appraisal_period: validatedData.appraisal_period || "",
        goal_status: "pending",
        approval: 0,
        goal_progress: 0
      });
      const result = {
        goalID: newGoal.goalID,
        goal: newGoal,
        success: true,
        message: "Goal created successfully"
      };
      resolve(result);
      bus.publish("GoalCreatedNotification", {
        goalID: newGoal.goalID,
        title: validatedData.goal_title,
        employee: validatedData.employee
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[GOAL COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to create goal"));
      }
    }
  });
}
function updateGoalCommandHandler(bus) {
  const messageName = "UpdateGoalCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = UpdateGoalCommandSchema.parse(message);
      console.log(`[GOAL COMMAND HANDLER] Updating goal: ${validatedData.goalID}`);
      const existingGoal = await goalRepository.getGoalById(validatedData.goalID);
      if (!existingGoal) {
        resolve(new Error(`Goal with ID ${validatedData.goalID} not found`));
        return;
      }
      if (existingGoal.approval === 1) {
        resolve(new Error("Cannot edit approved goals"));
        return;
      }
      const updatedGoal = await goalRepository.updateGoal(validatedData.goalID, validatedData.updates);
      const result = {
        goal: updatedGoal,
        success: true,
        message: "Goal updated successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to update goal"));
      }
    }
  });
}
function deleteGoalCommandHandler(bus) {
  const messageName = "DeleteGoalCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = DeleteGoalCommandSchema.parse(message);
      console.log(`[GOAL COMMAND HANDLER] Deleting goal: ${validatedData.goalID}`);
      const existingGoal = await goalRepository.getGoalById(validatedData.goalID);
      if (!existingGoal) {
        resolve(new Error(`Goal with ID ${validatedData.goalID} not found`));
        return;
      }
      if (existingGoal.approval === 1) {
        resolve(new Error("Cannot delete approved goals"));
        return;
      }
      await goalRepository.deleteGoal(validatedData.goalID);
      const result = {
        success: true,
        message: "Goal deleted successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to delete goal"));
      }
    }
  });
}
function approveGoalCommandHandler(bus) {
  const messageName = "ApproveGoalCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = ApproveGoalCommandSchema.parse(message);
      console.log(`[GOAL COMMAND HANDLER] Approving goal: ${validatedData.goalID}`);
      const approvedGoal = await goalRepository.approveGoal(validatedData.goalID);
      const updatedGoal = await goalRepository.updateGoal(validatedData.goalID, { goal_status: "approved" });
      const result = {
        goal: updatedGoal,
        success: true,
        message: "Goal approved successfully"
      };
      resolve(result);
      bus.publish("GoalApprovedNotification", {
        goalID: validatedData.goalID
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to approve goal"));
      }
    }
  });
}
function rejectGoalCommandHandler(bus) {
  const messageName = "RejectGoalCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = RejectGoalCommandSchema.parse(message);
      console.log(`[GOAL COMMAND HANDLER] Rejecting goal: ${validatedData.goalID}`);
      const rejectedGoal = await goalRepository.rejectGoal(validatedData.goalID);
      const updatedGoal = await goalRepository.updateGoal(validatedData.goalID, { goal_status: "rejected" });
      const result = {
        goal: updatedGoal,
        success: true,
        message: "Goal rejected successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to reject goal"));
      }
    }
  });
}
function createGoalProgressCommandHandler(bus) {
  const messageName = "CreateGoalProgressCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = CreateGoalProgressCommandSchema.parse(message);
      console.log(`[GOAL COMMAND HANDLER] Creating progress for goal: ${validatedData.goalID}`);
      const existingGoal = await goalRepository.getGoalById(validatedData.goalID);
      if (!existingGoal) {
        resolve({
          success: false,
          errors: [`Goal with ID ${validatedData.goalID} not found`]
        });
        return;
      }
      if (existingGoal.approval !== 1 && existingGoal.goal_status !== "approved") {
        resolve({
          success: false,
          errors: ["Cannot update progress for an unapproved goal. Please get the goal approved first."]
        });
        return;
      }
      if (validatedData.progress_percentage < 0 || validatedData.progress_percentage > 100) {
        resolve({
          success: false,
          errors: ["Progress percentage must be between 0 and 100"]
        });
        return;
      }
      await goalRepository.updateGoal(validatedData.goalID, {
        goal_progress: validatedData.progress_percentage
      });
      const progressEntry = await goalProgressRepository.createGoalProgress({
        goalID: validatedData.goalID,
        progress_percentage: validatedData.progress_percentage,
        progress_notes: validatedData.progress_notes || "",
        milestones_completed: validatedData.milestones_completed || "",
        progress_date: /* @__PURE__ */ new Date(),
        updated_by: validatedData.updated_by || ""
      });
      const result = {
        progress: progressEntry,
        success: true,
        message: "Goal progress created successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to create goal progress"));
      }
    }
  });
}
const GetAllGoalsQuerySchema = object({
  employeeId: string().optional(),
  status: string().optional(),
  appraisal_period: string().optional()
});
const GetGoalByIdQuerySchema = object({
  goalID: number()
});
const GetGoalsByEmployeeQuerySchema = object({
  employeeId: string()
});
const GetGoalProgressQuerySchema = object({
  goalID: number()
});
const GetLatestGoalProgressQuerySchema = object({
  goalID: number()
});
const CountGoalsQuerySchema = object({
  employeeId: string().optional(),
  status: string().optional()
});
function getAllGoalsQueryHandler(bus) {
  const messageName = "GetAllGoalsQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetAllGoalsQuerySchema.parse(message);
      console.log(`[GOAL QUERY HANDLER] Getting all goals`);
      let goals = await goalRepository.getAll();
      if (validatedData.employeeId) {
        goals = goals.filter((g2) => g2.employee === validatedData.employeeId);
      }
      if (validatedData.status) {
        goals = goals.filter((g2) => g2.goal_status === validatedData.status);
      }
      const result = {
        goals,
        success: true,
        message: "Goals retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to get goals"));
      }
    }
  });
}
function getGoalByIdQueryHandler(bus) {
  const messageName = "GetGoalByIdQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetGoalByIdQuerySchema.parse(message);
      console.log(`[GOAL QUERY HANDLER] Getting goal: ${validatedData.goalID}`);
      const goal = await goalRepository.getGoalById(validatedData.goalID);
      if (!goal) {
        resolve(new Error(`Goal with ID ${validatedData.goalID} not found`));
        return;
      }
      const result = {
        goal,
        success: true,
        message: "Goal retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to get goal"));
      }
    }
  });
}
function getGoalsByEmployeeQueryHandler(bus) {
  const messageName = "GetGoalsByEmployeeQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetGoalsByEmployeeQuerySchema.parse(message);
      console.log(`[GOAL QUERY HANDLER] Getting goals for employee: ${validatedData.employeeId}`);
      const goals = await goalRepository.getGoalsByEmployee(validatedData.employeeId);
      const result = {
        goals,
        success: true,
        message: "Employee goals retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to get employee goals"));
      }
    }
  });
}
function getGoalProgressQueryHandler(bus) {
  const messageName = "GetGoalProgressQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetGoalProgressQuerySchema.parse(message);
      console.log(`[GOAL QUERY HANDLER] Getting progress for goal: ${validatedData.goalID}`);
      const progressHistory = await goalProgressRepository.getGoalProgress(validatedData.goalID);
      const result = {
        history: progressHistory,
        success: true,
        message: "Goal progress history retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to get goal progress"));
      }
    }
  });
}
function getLatestGoalProgressQueryHandler(bus) {
  const messageName = "GetLatestGoalProgressQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetLatestGoalProgressQuerySchema.parse(message);
      console.log(`[GOAL QUERY HANDLER] Getting latest progress for goal: ${validatedData.goalID}`);
      const latestProgress = await goalProgressRepository.getLatestGoalProgress(validatedData.goalID);
      const result = {
        progress: latestProgress,
        success: true,
        message: "Latest goal progress retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to get latest goal progress"));
      }
    }
  });
}
function countGoalsQueryHandler(bus) {
  const messageName = "CountGoalsQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = CountGoalsQuerySchema.parse(message);
      console.log(`[GOAL QUERY HANDLER] Counting goals`);
      let goals = await goalRepository.getAll();
      if (validatedData.employeeId) {
        goals = goals.filter((g2) => g2.employee === validatedData.employeeId);
      }
      if (validatedData.status) {
        goals = goals.filter((g2) => g2.goal_status === validatedData.status);
      }
      const result = {
        count: goals.length,
        success: true,
        message: "Goal count retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to count goals"));
      }
    }
  });
}
const CreateBusinessGoalCommandSchema = object({
  department: string().min(1, "Department is required"),
  busgoal_title: string().min(3, "Title must be at least 3 characters"),
  busgoal_description: string().min(5, "Description must be at least 5 characters"),
  goal_category: string().optional(),
  key_result: string().optional(),
  start_date: union([date(), string()]).optional(),
  end_date: union([date(), string()]).optional()
});
const UpdateBusinessGoalCommandSchema = object({
  busgoalID: string(),
  updates: object({
    department: string().optional(),
    busgoal_title: string().optional(),
    busgoal_description: string().optional(),
    goal_category: string().optional(),
    key_result: string().optional(),
    start_date: union([date(), string()]).optional(),
    end_date: union([date(), string()]).optional()
  })
});
const DeleteBusinessGoalCommandSchema = object({
  busgoalID: string()
});
const GetAllBusinessGoalsQuerySchema = object({
  department: string().optional(),
  category: string().optional()
});
function createBusinessGoalCommandHandler(bus) {
  const messageName = "CreateBusinessGoalCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = CreateBusinessGoalCommandSchema.parse(message);
      console.log(`[BUSINESS GOAL HANDLER] Creating business goal: ${validatedData.busgoal_title}`);
      const newBusinessGoal = {
        busgoalID: `BG${Date.now()}`,
        department: validatedData.department,
        busgoal_title: validatedData.busgoal_title,
        busgoal_description: validatedData.busgoal_description,
        goal_category: validatedData.goal_category || "",
        key_result: validatedData.key_result || "",
        start_date: validatedData.start_date ? new Date(validatedData.start_date).toISOString() : (/* @__PURE__ */ new Date()).toISOString(),
        end_date: validatedData.end_date ? new Date(validatedData.end_date).toISOString() : (/* @__PURE__ */ new Date()).toISOString()
      };
      const existingGoals = JSON.parse(localStorage.getItem("tldr_business_goals") || "[]");
      existingGoals.push(newBusinessGoal);
      localStorage.setItem("tldr_business_goals", JSON.stringify(existingGoals));
      const result = {
        busgoalID: newBusinessGoal.busgoalID,
        businessGoal: newBusinessGoal,
        success: true,
        message: "Business goal created successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[BUSINESS GOAL HANDLER] Error:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to create business goal"));
      }
    }
  });
}
function updateBusinessGoalCommandHandler(bus) {
  const messageName = "UpdateBusinessGoalCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = UpdateBusinessGoalCommandSchema.parse(message);
      console.log(`[BUSINESS GOAL HANDLER] Updating business goal: ${validatedData.busgoalID}`);
      const existingGoals = JSON.parse(localStorage.getItem("tldr_business_goals") || "[]");
      const goalIndex = existingGoals.findIndex((g2) => g2.busgoalID === validatedData.busgoalID);
      if (goalIndex === -1) {
        resolve(new Error(`Business goal with ID ${validatedData.busgoalID} not found`));
        return;
      }
      existingGoals[goalIndex] = { ...existingGoals[goalIndex], ...validatedData.updates };
      localStorage.setItem("tldr_business_goals", JSON.stringify(existingGoals));
      const result = {
        businessGoal: existingGoals[goalIndex],
        success: true,
        message: "Business goal updated successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[BUSINESS GOAL HANDLER] Error:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to update business goal"));
      }
    }
  });
}
function deleteBusinessGoalCommandHandler(bus) {
  const messageName = "DeleteBusinessGoalCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = DeleteBusinessGoalCommandSchema.parse(message);
      console.log(`[BUSINESS GOAL HANDLER] Deleting business goal: ${validatedData.busgoalID}`);
      const existingGoals = JSON.parse(localStorage.getItem("tldr_business_goals") || "[]");
      const updatedGoals = existingGoals.filter((g2) => g2.busgoalID !== validatedData.busgoalID);
      localStorage.setItem("tldr_business_goals", JSON.stringify(updatedGoals));
      const result = {
        success: true,
        message: "Business goal deleted successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[BUSINESS GOAL HANDLER] Error:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to delete business goal"));
      }
    }
  });
}
function getAllBusinessGoalsQueryHandler(bus) {
  const messageName = "GetAllBusinessGoalsQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetAllBusinessGoalsQuerySchema.parse(message);
      console.log(`[BUSINESS GOAL HANDLER] Getting all business goals`);
      let businessGoals = JSON.parse(localStorage.getItem("tldr_business_goals") || "[]");
      if (validatedData.department) {
        businessGoals = businessGoals.filter((g2) => g2.department === validatedData.department);
      }
      if (validatedData.category) {
        businessGoals = businessGoals.filter((g2) => g2.goal_category === validatedData.category);
      }
      const result = {
        businessGoals,
        success: true,
        message: "Business goals retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[BUSINESS GOAL HANDLER] Error:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to get business goals"));
      }
    }
  });
}
const CreateGoalCategoryCommandSchema = object({
  categoryName: string().min(2, "Category name must be at least 2 characters"),
  category_description: string().optional()
});
const UpdateGoalCategoryCommandSchema = object({
  goalCatID: string(),
  updates: object({
    categoryName: string().optional(),
    category_description: string().optional()
  })
});
const DeleteGoalCategoryCommandSchema = object({
  goalCatID: string()
});
object({});
const GetGoalCategoryByIdQuerySchema = object({
  goalCatID: string()
});
function createGoalCategoryCommandHandler(bus) {
  const messageName = "CreateGoalCategoryCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validated = CreateGoalCategoryCommandSchema.parse(message);
      const goalCatID = `gc-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const category = {
        goalCatID,
        categoryName: validated.categoryName,
        category_description: validated.category_description || "",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      await goalCategoryRepository.add(category);
      const result = {
        goalCatID,
        category,
        success: true,
        message: "Goal category created successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL CATEGORY HANDLER] Error:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to create goal category"));
      }
    }
  });
}
function updateGoalCategoryCommandHandler(bus) {
  const messageName = "UpdateGoalCategoryCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validated = UpdateGoalCategoryCommandSchema.parse(message);
      const categories = await goalCategoryRepository.find({ goalCatID: validated.goalCatID });
      if (categories.length === 0) {
        resolve(new Error("Goal category not found"));
        return;
      }
      const existingCategory = categories[0];
      const updates = {
        ...validated.updates,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      const updatedCategory = await goalCategoryRepository.update(
        validated.goalCatID,
        updates,
        "goalCatID"
      );
      const result = {
        category: updatedCategory,
        success: true,
        message: "Goal category updated successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL CATEGORY HANDLER] Error:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to update goal category"));
      }
    }
  });
}
function deleteGoalCategoryCommandHandler(bus) {
  const messageName = "DeleteGoalCategoryCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validated = DeleteGoalCategoryCommandSchema.parse(message);
      const categories = await goalCategoryRepository.find({ goalCatID: validated.goalCatID });
      if (categories.length === 0) {
        resolve(new Error("Goal category not found"));
        return;
      }
      await goalCategoryRepository.deleteById(validated.goalCatID, "goalCatID");
      const result = {
        success: true,
        message: "Goal category deleted successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL CATEGORY HANDLER] Error:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to delete goal category"));
      }
    }
  });
}
function getAllGoalCategoriesQueryHandler(bus) {
  const messageName = "GetAllGoalCategoriesQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const categories = await goalCategoryRepository.find({});
      const result = {
        categories,
        success: true,
        message: "Goal categories retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      console.error(`[GOAL CATEGORY HANDLER] Error:`, error2);
      resolve(error2 instanceof Error ? error2 : new Error("Failed to retrieve goal categories"));
    }
  });
}
function getGoalCategoryByIdQueryHandler(bus) {
  const messageName = "GetGoalCategoryByIdQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validated = GetGoalCategoryByIdQuerySchema.parse(message);
      const categories = await goalCategoryRepository.find({ goalCatID: validated.goalCatID });
      if (categories.length === 0) {
        resolve(new Error("Goal category not found"));
        return;
      }
      const result = {
        category: categories[0],
        success: true,
        message: "Goal category retrieved successfully"
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        resolve(new Error(`Validation failed: ${error2.issues.map((e2) => e2.message).join(", ")}`));
      } else {
        console.error(`[GOAL CATEGORY HANDLER] Error:`, error2);
        resolve(error2 instanceof Error ? error2 : new Error("Failed to retrieve goal category"));
      }
    }
  });
}
const CreateDepartmentCommandSchema = object({
  deptcode: string().min(1, "Department code is required"),
  deptname: string().min(1, "Department name is required")
});
const UpdateDepartmentCommandSchema = object({
  deptcode: string().min(1, "Department code is required"),
  updates: object({
    deptname: string().optional()
  })
});
const DeleteDepartmentCommandSchema = object({
  deptcode: string().min(1, "Department code is required")
});
const GetAllDepartmentsQuerySchema = object({
  limit: number().optional()
});
const GetDepartmentByIdQuerySchema = object({
  deptcode: string().min(1, "Department code is required")
});
function createDepartmentCommandHandler(bus) {
  const messageName = "CreateDepartmentCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = CreateDepartmentCommandSchema.parse(message);
      console.log(`[DEPARTMENT COMMAND HANDLER] Creating department: ${validatedData.deptcode}`);
      const existingDepts = await departmentRepository.find({ deptcode: validatedData.deptcode });
      if (existingDepts && existingDepts.length > 0) {
        resolve({
          success: false,
          errors: [`Department with code ${validatedData.deptcode} already exists`]
        });
        return;
      }
      const newDept = await departmentRepository.createDepartment({
        deptcode: validatedData.deptcode,
        deptname: validatedData.deptname
      });
      const result = {
        department: newDept,
        success: true,
        message: "Department created successfully"
      };
      resolve(result);
      bus.publish("DepartmentCreatedNotification", {
        deptcode: newDept.deptcode,
        deptname: newDept.deptname
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[DEPARTMENT COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[DEPARTMENT COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to create department"]
        });
      }
    }
  });
}
function updateDepartmentCommandHandler(bus) {
  const messageName = "UpdateDepartmentCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = UpdateDepartmentCommandSchema.parse(message);
      console.log(`[DEPARTMENT COMMAND HANDLER] Updating department: ${validatedData.deptcode}`);
      const existingDepts = await departmentRepository.find({ deptcode: validatedData.deptcode });
      if (!existingDepts || existingDepts.length === 0) {
        resolve({
          success: false,
          errors: [`Department with code ${validatedData.deptcode} not found`]
        });
        return;
      }
      const updatedDept = await departmentRepository.updateDepartment(
        validatedData.deptcode,
        validatedData.updates
      );
      const result = {
        department: updatedDept,
        success: true,
        message: "Department updated successfully"
      };
      resolve(result);
      bus.publish("DepartmentUpdatedNotification", {
        deptcode: updatedDept.deptcode,
        deptname: updatedDept.deptname
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[DEPARTMENT COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[DEPARTMENT COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to update department"]
        });
      }
    }
  });
}
function deleteDepartmentCommandHandler(bus) {
  const messageName = "DeleteDepartmentCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = DeleteDepartmentCommandSchema.parse(message);
      console.log(`[DEPARTMENT COMMAND HANDLER] Deleting department: ${validatedData.deptcode}`);
      const existingDepts = await departmentRepository.find({ deptcode: validatedData.deptcode });
      if (!existingDepts || existingDepts.length === 0) {
        resolve({
          success: false,
          errors: [`Department with code ${validatedData.deptcode} not found`]
        });
        return;
      }
      await departmentRepository.deleteDepartment(validatedData.deptcode);
      const result = {
        success: true,
        message: "Department deleted successfully"
      };
      resolve(result);
      bus.publish("DepartmentDeletedNotification", {
        deptcode: validatedData.deptcode
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[DEPARTMENT COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[DEPARTMENT COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to delete department"]
        });
      }
    }
  });
}
function getAllDepartmentsQueryHandler(bus) {
  const messageName = "GetAllDepartmentsQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetAllDepartmentsQuerySchema.parse(message);
      console.log(`[DEPARTMENT QUERY HANDLER] Getting all departments`);
      const departments = await departmentRepository.getAllDepartments();
      const limitedDepts = validatedData.limit ? departments.slice(0, validatedData.limit) : departments;
      const result = {
        success: true,
        departments: limitedDepts
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[DEPARTMENT QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          departments: [],
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[DEPARTMENT QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          departments: [],
          errors: [error2 instanceof Error ? error2.message : "Failed to get departments"]
        });
      }
    }
  });
}
function getDepartmentByIdQueryHandler(bus) {
  const messageName = "GetDepartmentByIdQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetDepartmentByIdQuerySchema.parse(message);
      console.log(`[DEPARTMENT QUERY HANDLER] Getting department: ${validatedData.deptcode}`);
      const departments = await departmentRepository.find({ deptcode: validatedData.deptcode });
      if (!departments || departments.length === 0) {
        resolve({
          success: false,
          errors: [`Department with code ${validatedData.deptcode} not found`]
        });
        return;
      }
      const result = {
        success: true,
        department: departments[0]
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[DEPARTMENT QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[DEPARTMENT QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to get department"]
        });
      }
    }
  });
}
const CreateDevelopmentPlanCommandSchema = object({
  employee: string().min(1, "Employee ID is required"),
  ID: string().optional(),
  // User ID
  competency_area: string().min(1, "Competency area is required"),
  plan_description: string().min(1, "Plan description is required"),
  skills: string().optional(),
  projected_start_date: union([date(), string()]).optional(),
  projected_target_date: union([date(), string()]).optional(),
  dev_year: number().optional(),
  mode: string().optional()
});
const UpdateDevelopmentPlanCommandSchema = object({
  planID: number().min(1, "Plan ID is required"),
  updates: object({
    competency_area: string().optional(),
    plan_description: string().optional(),
    skills: string().optional(),
    projected_start_date: union([date(), string()]).optional(),
    projected_target_date: union([date(), string()]).optional(),
    dev_year: number().optional(),
    mode: string().optional(),
    plan_status: string().optional(),
    dev_progress: number().min(0).max(100).optional()
  })
});
const DeleteDevelopmentPlanCommandSchema = object({
  planID: number().min(1, "Plan ID is required")
});
const GetAllDevelopmentPlansQuerySchema = object({
  employee: string().optional()
});
const GetDevelopmentPlanByIdQuerySchema = object({
  planID: number().min(1, "Plan ID is required")
});
const GetDevelopmentPlansByEmployeeQuerySchema = object({
  employee: string().min(1, "Employee ID is required")
});
const GetDevelopmentPlansByStatusQuerySchema = object({
  plan_status: string().min(1, "Status is required")
});
function createDevelopmentPlanCommandHandler(bus) {
  const messageName = "CreateDevelopmentPlanCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = CreateDevelopmentPlanCommandSchema.parse(message);
      console.log(`[DEVPLAN COMMAND HANDLER] Creating development plan for employee: ${validatedData.employee}`);
      const employees = await employeeRepository.find({ employeeID: validatedData.employee });
      if (!employees || employees.length === 0) {
        resolve({
          success: false,
          errors: [`Employee with ID ${validatedData.employee} not found`]
        });
        return;
      }
      const newPlan = await developmentPlanRepository.createDevelopmentPlan({
        employee: validatedData.employee,
        ID: validatedData.ID || "",
        competency_area: validatedData.competency_area,
        plan_description: validatedData.plan_description,
        skills: validatedData.skills || "",
        projected_start_date: validatedData.projected_start_date ? new Date(validatedData.projected_start_date) : /* @__PURE__ */ new Date(),
        projected_target_date: validatedData.projected_target_date ? new Date(validatedData.projected_target_date) : /* @__PURE__ */ new Date(),
        dev_year: validatedData.dev_year || (/* @__PURE__ */ new Date()).getFullYear(),
        mode: validatedData.mode || "Self-directed",
        plan_status: "draft",
        dev_progress: 0
      });
      const result = {
        plan: newPlan,
        success: true,
        message: "Development plan created successfully"
      };
      resolve(result);
      bus.publish("DevelopmentPlanCreatedNotification", {
        planID: newPlan.planID,
        employee: validatedData.employee,
        competency_area: validatedData.competency_area
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[DEVPLAN COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[DEVPLAN COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to create development plan"]
        });
      }
    }
  });
}
function updateDevelopmentPlanCommandHandler(bus) {
  const messageName = "UpdateDevelopmentPlanCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = UpdateDevelopmentPlanCommandSchema.parse(message);
      console.log(`[DEVPLAN COMMAND HANDLER] Updating development plan: ${validatedData.planID}`);
      const existingPlans = await developmentPlanRepository.find({ planID: validatedData.planID });
      if (!existingPlans || existingPlans.length === 0) {
        resolve({
          success: false,
          errors: [`Development plan with ID ${validatedData.planID} not found`]
        });
        return;
      }
      const updatedPlan = await developmentPlanRepository.updateDevelopmentPlan(
        validatedData.planID,
        validatedData.updates
      );
      const result = {
        plan: updatedPlan,
        success: true,
        message: "Development plan updated successfully"
      };
      resolve(result);
      bus.publish("DevelopmentPlanUpdatedNotification", {
        planID: updatedPlan.planID,
        employee: updatedPlan.employee
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[DEVPLAN COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[DEVPLAN COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to update development plan"]
        });
      }
    }
  });
}
function deleteDevelopmentPlanCommandHandler(bus) {
  const messageName = "DeleteDevelopmentPlanCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = DeleteDevelopmentPlanCommandSchema.parse(message);
      console.log(`[DEVPLAN COMMAND HANDLER] Deleting development plan: ${validatedData.planID}`);
      const existingPlans = await developmentPlanRepository.find({ planID: validatedData.planID });
      if (!existingPlans || existingPlans.length === 0) {
        resolve({
          success: false,
          errors: [`Development plan with ID ${validatedData.planID} not found`]
        });
        return;
      }
      await developmentPlanRepository.deleteDevelopmentPlan(validatedData.planID);
      const result = {
        success: true,
        message: "Development plan deleted successfully"
      };
      resolve(result);
      bus.publish("DevelopmentPlanDeletedNotification", {
        planID: validatedData.planID
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[DEVPLAN COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[DEVPLAN COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to delete development plan"]
        });
      }
    }
  });
}
function getAllDevelopmentPlansQueryHandler(bus) {
  const messageName = "GetAllDevelopmentPlansQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetAllDevelopmentPlansQuerySchema.parse(message);
      console.log(`[DEVPLAN QUERY HANDLER] Getting all development plans`);
      let plans;
      if (validatedData.employee) {
        plans = await developmentPlanRepository.getDevelopmentPlansByEmployee(validatedData.employee);
      } else {
        plans = await developmentPlanRepository.getAll();
      }
      const result = {
        success: true,
        plans
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[DEVPLAN QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          plans: [],
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[DEVPLAN QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          plans: [],
          errors: [error2 instanceof Error ? error2.message : "Failed to get development plans"]
        });
      }
    }
  });
}
function getDevelopmentPlanByIdQueryHandler(bus) {
  const messageName = "GetDevelopmentPlanByIdQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetDevelopmentPlanByIdQuerySchema.parse(message);
      console.log(`[DEVPLAN QUERY HANDLER] Getting development plan: ${validatedData.planID}`);
      const plans = await developmentPlanRepository.find({ planID: validatedData.planID });
      if (!plans || plans.length === 0) {
        resolve({
          success: false,
          errors: [`Development plan with ID ${validatedData.planID} not found`]
        });
        return;
      }
      const result = {
        success: true,
        plan: plans[0]
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[DEVPLAN QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[DEVPLAN QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to get development plan"]
        });
      }
    }
  });
}
function getDevelopmentPlansByEmployeeQueryHandler(bus) {
  const messageName = "GetDevelopmentPlansByEmployeeQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetDevelopmentPlansByEmployeeQuerySchema.parse(message);
      console.log(`[DEVPLAN QUERY HANDLER] Getting development plans for employee: ${validatedData.employee}`);
      const plans = await developmentPlanRepository.getDevelopmentPlansByEmployee(validatedData.employee);
      const result = {
        success: true,
        plans: plans || [],
        count: (plans || []).length
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[DEVPLAN QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          plans: [],
          count: 0,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[DEVPLAN QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          plans: [],
          count: 0,
          errors: [error2 instanceof Error ? error2.message : "Failed to get development plans for employee"]
        });
      }
    }
  });
}
function getDevelopmentPlansByStatusQueryHandler(bus) {
  const messageName = "GetDevelopmentPlansByStatusQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetDevelopmentPlansByStatusQuerySchema.parse(message);
      console.log(`[DEVPLAN QUERY HANDLER] Getting development plans by status: ${validatedData.plan_status}`);
      const plans = await developmentPlanRepository.find({ plan_status: validatedData.plan_status });
      const result = {
        success: true,
        plans: plans || [],
        count: (plans || []).length
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[DEVPLAN QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          plans: [],
          count: 0,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[DEVPLAN QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          plans: [],
          count: 0,
          errors: [error2 instanceof Error ? error2.message : "Failed to get development plans by status"]
        });
      }
    }
  });
}
const CreateAppraisalPeriodCommandSchema = object({
  period_start: string().min(1, "Period start is required"),
  period_end: string().min(1, "Period end is required"),
  review_start_date: union([date(), string()]),
  review_end_date: union([date(), string()]),
  review_status: string().optional()
}).refine((data) => {
  const startDate = new Date(data.review_start_date);
  const endDate = new Date(data.review_end_date);
  return endDate >= startDate;
}, {
  message: "Review end date must be after or equal to review start date"
});
const UpdateAppraisalPeriodCommandSchema = object({
  periodID: number().min(1, "Period ID is required"),
  updates: object({
    period_start: string().optional(),
    period_end: string().optional(),
    review_start_date: union([date(), string()]).optional(),
    review_end_date: union([date(), string()]).optional(),
    review_status: string().optional()
  })
});
const DeleteAppraisalPeriodCommandSchema = object({
  periodID: number().min(1, "Period ID is required")
});
const GetAllAppraisalPeriodsQuerySchema = object({
  status: string().optional()
});
const GetAppraisalPeriodByIdQuerySchema = object({
  periodID: number().min(1, "Period ID is required")
});
const GetCurrentAppraisalPeriodQuerySchema = object({});
const GetAppraisalPeriodsByStatusQuerySchema = object({
  review_status: string().min(1, "Status is required")
});
function createAppraisalPeriodCommandHandler(bus) {
  const messageName = "CreateAppraisalPeriodCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = CreateAppraisalPeriodCommandSchema.parse(message);
      console.log(`[APPRAISAL COMMAND HANDLER] Creating appraisal period: ${validatedData.period_start} - ${validatedData.period_end}`);
      const startDate = new Date(validatedData.review_start_date);
      const endDate = new Date(validatedData.review_end_date);
      const existingPeriods = await appraisalPeriodRepository.getAll();
      const hasOverlap = existingPeriods.some((period) => {
        const existingStart = new Date(period.review_start_date);
        const existingEnd = new Date(period.review_end_date);
        return startDate <= existingEnd && endDate >= existingStart;
      });
      if (hasOverlap) {
        resolve({
          success: false,
          errors: ["Appraisal period overlaps with an existing period"]
        });
        return;
      }
      const newPeriod = await appraisalPeriodRepository.add({
        periodID: Date.now(),
        period_start: validatedData.period_start,
        period_end: validatedData.period_end,
        review_start_date: startDate,
        review_end_date: endDate,
        review_status: validatedData.review_status || "scheduled"
      });
      const result = {
        period: newPeriod,
        success: true,
        message: "Appraisal period created successfully"
      };
      resolve(result);
      bus.publish("AppraisalPeriodCreatedNotification", {
        periodID: newPeriod.periodID,
        period_start: newPeriod.period_start,
        period_end: newPeriod.period_end
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[APPRAISAL COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[APPRAISAL COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to create appraisal period"]
        });
      }
    }
  });
}
function updateAppraisalPeriodCommandHandler(bus) {
  const messageName = "UpdateAppraisalPeriodCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = UpdateAppraisalPeriodCommandSchema.parse(message);
      console.log(`[APPRAISAL COMMAND HANDLER] Updating appraisal period: ${validatedData.periodID}`);
      const existingPeriods = await appraisalPeriodRepository.find({ periodID: validatedData.periodID });
      if (!existingPeriods || existingPeriods.length === 0) {
        resolve({
          success: false,
          errors: [`Appraisal period with ID ${validatedData.periodID} not found`]
        });
        return;
      }
      const updates = { ...validatedData.updates };
      if (updates.review_start_date && typeof updates.review_start_date === "string") {
        updates.review_start_date = new Date(updates.review_start_date);
      }
      if (updates.review_end_date && typeof updates.review_end_date === "string") {
        updates.review_end_date = new Date(updates.review_end_date);
      }
      const updatedPeriod = await appraisalPeriodRepository.updateAppraisalPeriod(
        validatedData.periodID,
        updates
      );
      const result = {
        period: updatedPeriod,
        success: true,
        message: "Appraisal period updated successfully"
      };
      resolve(result);
      bus.publish("AppraisalPeriodUpdatedNotification", {
        periodID: updatedPeriod.periodID,
        review_status: updatedPeriod.review_status
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[APPRAISAL COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[APPRAISAL COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to update appraisal period"]
        });
      }
    }
  });
}
function deleteAppraisalPeriodCommandHandler(bus) {
  const messageName = "DeleteAppraisalPeriodCommand";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = DeleteAppraisalPeriodCommandSchema.parse(message);
      console.log(`[APPRAISAL COMMAND HANDLER] Deleting appraisal period: ${validatedData.periodID}`);
      const existingPeriods = await appraisalPeriodRepository.find({ periodID: validatedData.periodID });
      if (!existingPeriods || existingPeriods.length === 0) {
        resolve({
          success: false,
          errors: [`Appraisal period with ID ${validatedData.periodID} not found`]
        });
        return;
      }
      const existingPeriod = existingPeriods[0];
      if (existingPeriod.review_status === "active") {
        resolve({
          success: false,
          errors: ["Cannot delete an active appraisal period. Please deactivate it first."]
        });
        return;
      }
      await appraisalPeriodRepository.deleteAppraisalPeriod(validatedData.periodID);
      const result = {
        success: true,
        message: "Appraisal period deleted successfully"
      };
      resolve(result);
      bus.publish("AppraisalPeriodDeletedNotification", {
        periodID: validatedData.periodID
      });
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[APPRAISAL COMMAND HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[APPRAISAL COMMAND HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to delete appraisal period"]
        });
      }
    }
  });
}
function getAllAppraisalPeriodsQueryHandler(bus) {
  const messageName = "GetAllAppraisalPeriodsQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      GetAllAppraisalPeriodsQuerySchema.parse(message);
      console.log(`[APPRAISAL QUERY HANDLER] Retrieving all appraisal periods`);
      const periods = await appraisalPeriodRepository.getAll();
      const result = {
        periods: periods || [],
        success: true,
        count: (periods || []).length
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[APPRAISAL QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          periods: [],
          success: false,
          count: 0,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[APPRAISAL QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          periods: [],
          success: false,
          count: 0,
          errors: [error2 instanceof Error ? error2.message : "Failed to retrieve appraisal periods"]
        });
      }
    }
  });
}
function getAppraisalPeriodByIdQueryHandler(bus) {
  const messageName = "GetAppraisalPeriodByIdQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetAppraisalPeriodByIdQuerySchema.parse(message);
      console.log(`[APPRAISAL QUERY HANDLER] Retrieving appraisal period by ID: ${validatedData.periodID}`);
      const periods = await appraisalPeriodRepository.find({ periodID: validatedData.periodID });
      if (!periods || periods.length === 0) {
        resolve({
          period: null,
          success: false,
          errors: [`Appraisal period with ID ${validatedData.periodID} not found`]
        });
        return;
      }
      const result = {
        period: periods[0],
        success: true
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[APPRAISAL QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          period: null,
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[APPRAISAL QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          period: null,
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to retrieve appraisal period"]
        });
      }
    }
  });
}
function getCurrentAppraisalPeriodQueryHandler(bus) {
  const messageName = "GetCurrentAppraisalPeriodQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      GetCurrentAppraisalPeriodQuerySchema.parse(message);
      console.log(`[APPRAISAL QUERY HANDLER] Retrieving current appraisal period`);
      const periods = await appraisalPeriodRepository.getAll();
      const now = /* @__PURE__ */ new Date();
      let currentPeriod = periods.find((p2) => p2.review_status === "active");
      if (!currentPeriod) {
        currentPeriod = periods.find((p2) => {
          const start = new Date(p2.review_start_date);
          const end = new Date(p2.review_end_date);
          return now >= start && now <= end;
        });
      }
      if (!currentPeriod) {
        resolve({
          period: null,
          success: false,
          errors: ["No current appraisal period found"]
        });
        return;
      }
      const result = {
        period: currentPeriod,
        success: true
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[APPRAISAL QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          period: null,
          success: false,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[APPRAISAL QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          period: null,
          success: false,
          errors: [error2 instanceof Error ? error2.message : "Failed to retrieve current appraisal period"]
        });
      }
    }
  });
}
function getAppraisalPeriodsByStatusQueryHandler(bus) {
  const messageName = "GetAppraisalPeriodsByStatusQuery";
  bus.on(messageName, async (message, resolve) => {
    try {
      const validatedData = GetAppraisalPeriodsByStatusQuerySchema.parse(message);
      console.log(`[APPRAISAL QUERY HANDLER] Retrieving appraisal periods by status: ${validatedData.review_status}`);
      const periods = await appraisalPeriodRepository.find({ review_status: validatedData.review_status });
      const result = {
        periods: periods || [],
        success: true,
        count: (periods || []).length
      };
      resolve(result);
    } catch (error2) {
      if (error2 instanceof ZodError) {
        console.error(`[APPRAISAL QUERY HANDLER] Validation failed for ${messageName}:`, error2.issues);
        resolve({
          periods: [],
          success: false,
          count: 0,
          errors: error2.issues.map((e2) => e2.message)
        });
      } else {
        console.error(`[APPRAISAL QUERY HANDLER] Error processing ${messageName}:`, error2);
        resolve({
          periods: [],
          success: false,
          count: 0,
          errors: [error2 instanceof Error ? error2.message : "Failed to retrieve appraisal periods by status"]
        });
      }
    }
  });
}
class DomainServices extends IDomainServices {
  constructor() {
    super();
    this.eventBus = new EventBus();
    createUserCommandHandler(this.eventBus);
    updateProfileCommandHandler(this.eventBus);
    changePasswordCommandHandler(this.eventBus);
    uploadProfilePictureCommandHandler(this.eventBus);
    deleteUserCommandHandler(this.eventBus);
    loginCommandHandler(this.eventBus);
    getCurrentUserQueryHandler(this.eventBus);
    getUserByIdQueryHandler(this.eventBus);
    getAllUsersQueryHandler(this.eventBus);
    getUsersByTypeQueryHandler(this.eventBus);
    getUsersByEmployeeIdQueryHandler(this.eventBus);
    searchUsersQueryHandler(this.eventBus);
    updateEmployeeProfileCommandHandler(this.eventBus);
    deleteEmployeeCommandHandler(this.eventBus);
    getAllEmployeesQueryHandler(this.eventBus);
    getCurrentEmployeeQueryHandler(this.eventBus);
    getEmployeeProfileQueryHandler(this.eventBus);
    getEmployeesByDepartmentQueryHandler(this.eventBus);
    getEmployeesByManagerQueryHandler(this.eventBus);
    getEmployeesByStatusQueryHandler(this.eventBus);
    searchEmployeesQueryHandler(this.eventBus);
    getEmployeesByJobRoleQueryHandler(this.eventBus);
    getEmployeesByContractTypeQueryHandler(this.eventBus);
    createGoalCommandHandler(this.eventBus);
    updateGoalCommandHandler(this.eventBus);
    deleteGoalCommandHandler(this.eventBus);
    approveGoalCommandHandler(this.eventBus);
    rejectGoalCommandHandler(this.eventBus);
    createGoalProgressCommandHandler(this.eventBus);
    getAllGoalsQueryHandler(this.eventBus);
    getGoalByIdQueryHandler(this.eventBus);
    getGoalsByEmployeeQueryHandler(this.eventBus);
    getGoalProgressQueryHandler(this.eventBus);
    getLatestGoalProgressQueryHandler(this.eventBus);
    countGoalsQueryHandler(this.eventBus);
    createBusinessGoalCommandHandler(this.eventBus);
    updateBusinessGoalCommandHandler(this.eventBus);
    deleteBusinessGoalCommandHandler(this.eventBus);
    getAllBusinessGoalsQueryHandler(this.eventBus);
    createGoalCategoryCommandHandler(this.eventBus);
    updateGoalCategoryCommandHandler(this.eventBus);
    deleteGoalCategoryCommandHandler(this.eventBus);
    getAllGoalCategoriesQueryHandler(this.eventBus);
    getGoalCategoryByIdQueryHandler(this.eventBus);
    createDepartmentCommandHandler(this.eventBus);
    updateDepartmentCommandHandler(this.eventBus);
    deleteDepartmentCommandHandler(this.eventBus);
    getAllDepartmentsQueryHandler(this.eventBus);
    getDepartmentByIdQueryHandler(this.eventBus);
    createDevelopmentPlanCommandHandler(this.eventBus);
    updateDevelopmentPlanCommandHandler(this.eventBus);
    deleteDevelopmentPlanCommandHandler(this.eventBus);
    getAllDevelopmentPlansQueryHandler(this.eventBus);
    getDevelopmentPlanByIdQueryHandler(this.eventBus);
    getDevelopmentPlansByEmployeeQueryHandler(this.eventBus);
    getDevelopmentPlansByStatusQueryHandler(this.eventBus);
    createAppraisalPeriodCommandHandler(this.eventBus);
    updateAppraisalPeriodCommandHandler(this.eventBus);
    deleteAppraisalPeriodCommandHandler(this.eventBus);
    getAllAppraisalPeriodsQueryHandler(this.eventBus);
    getAppraisalPeriodByIdQueryHandler(this.eventBus);
    getCurrentAppraisalPeriodQueryHandler(this.eventBus);
    getAppraisalPeriodsByStatusQueryHandler(this.eventBus);
  }
  // Helper method for loading state management
  async withLoading(dispatch, asyncFn) {
    try {
      if (dispatch) {
        dispatch(setLoading(true));
      }
      return await asyncFn();
    } finally {
      if (dispatch) {
        dispatch(setLoading(false));
      }
    }
  }
  // ===== 2. LOGIN SYSTEM AND USER ACCOUNT MANAGEMENT =====
  // Authentication methods
  async login(credentials) {
    try {
      const command = {
        email: credentials.email,
        password: credentials.password
      };
      const result = await this.eventBus.send("LoginCommand", command);
      if (result.success) {
        localStorage.setItem("auth_token", result.access_token);
        return {
          user: result.user,
          access_token: result.access_token,
          token_type: result.token_type,
          success: true,
          message: result.message
        };
      } else {
        throw new Error(result.error || "Login failed");
      }
    } catch (error2) {
      console.error("Login failed:", error2);
      throw error2;
    }
  }
  async logout() {
    try {
      try {
        localStorage.removeItem("auth_token");
        sessionStorage.removeItem("auth_token");
      } catch (storageError) {
        console.warn("Storage cleanup failed:", storageError);
      }
      try {
        document.cookie = "access_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
        document.cookie = "refresh_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
      } catch (cookieError) {
        console.warn("Cookie cleanup failed:", cookieError);
      }
      return { success: true };
    } catch (error2) {
      console.error("Logout failed:", error2);
      throw error2;
    }
  }
  async refreshToken() {
    throw new Error("Token refresh should be handled by HTTP interceptors");
  }
  // Password management
  async changePassword(passwordData, dispatch) {
    return this.withLoading(dispatch, async () => {
      try {
        const currentUser = await this.getCurrentUser(null);
        const command = {
          userId: String(currentUser.userID || currentUser._id || currentUser.id || "current"),
          currentPassword: passwordData.current_password,
          newPassword: passwordData.new_password
        };
        const result = await this.eventBus.send("ChangePasswordCommand", command);
        if (result.success) {
          Swal.fire({
            icon: "success",
            title: "Success",
            text: "Password changed successfully",
            timer: 2e3,
            showConfirmButton: false
          });
          return result;
        } else {
          throw new Error(result.error || "Failed to change password");
        }
      } catch (error2) {
        this.handleError(error2, "Failed to change password");
      }
    });
  }
  async initiatePasswordRecovery(email2) {
    throw new Error("Password recovery should be handled by HTTP API");
  }
  // Profile picture management
  async uploadProfilePicture(file, dispatch) {
    return this.withLoading(dispatch, async () => {
      try {
        const command = { file };
        const result = await this.eventBus.send("UploadProfilePictureCommand", command);
        if (result.success) {
          Swal.fire({
            icon: "success",
            title: "Success",
            text: "Profile picture uploaded successfully",
            timer: 2e3,
            showConfirmButton: false
          });
          return result;
        } else {
          throw new Error(result.error || "Failed to upload profile picture");
        }
      } catch (error2) {
        this.handleError(error2, "Failed to upload profile picture");
      }
    });
  }
  // User account queries
  async getCurrentUser(dispatch) {
    return this.withLoading(dispatch, async () => {
      var _a2;
      try {
        const query = {};
        const result = await this.eventBus.send("GetCurrentUserQuery", query);
        if (result.success) {
          return result.user;
        } else {
          console.log({ result });
          throw new Error(result.error || "DomainService.js: Command Failed to get current user");
        }
      } catch (error2) {
        if (!((_a2 = error2.message) == null ? void 0 : _a2.includes("not authenticated"))) {
          this.handleError(error2, "DomainService.js: Failed to get current user");
        }
        throw error2;
      }
    });
  }
  async getUser(userId, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const query = { userId };
      const result = await this.eventBus.send("GetUserByIdQuery", query);
      if (result.success) {
        return result.user;
      } else {
        throw new Error(result.error || "Failed to get user");
      }
    } catch (error2) {
      console.error("Error fetching user:", error2);
      throw error2;
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async getAllUsers(dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const query = { page: 1, limit: 100 };
      const result = await this.eventBus.send("GetAllUsersQuery", query);
      if (result.success) {
        return result.users;
      } else {
        throw new Error(result.error || "Failed to get users");
      }
    } catch (error2) {
      console.error("Error fetching users:", error2);
      return [];
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async getUsersByType(userType, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const query = { userType, page: 1, limit: 100 };
      const result = await this.eventBus.send("GetUsersByTypeQuery", query);
      if (result.success) {
        return result.users;
      } else {
        throw new Error(result.error || "Failed to get users by type");
      }
    } catch (error2) {
      console.error("Error fetching users by type:", error2);
      return [];
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async searchUsers(searchQuery, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const query = { query: searchQuery, page: 1, limit: 50 };
      const result = await this.eventBus.send("SearchUsersQuery", query);
      if (result.success) {
        return result.users;
      } else {
        throw new Error(result.error || "Failed to search users");
      }
    } catch (error2) {
      console.error("Error searching users:", error2);
      return [];
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  // User account commands
  async createUser(userData, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const command = {
        email: userData.email,
        password: userData.password,
        name: userData.name || userData.staff_name,
        userType: userData.userType || userData.usertype || "employee",
        employeeId: userData.employeeId || userData.employee_id
      };
      const result = await this.eventBus.send("CreateUserCommand", command);
      if (result.success) {
        Swal.fire({
          icon: "success",
          title: "Success",
          text: "User created successfully",
          timer: 2e3,
          showConfirmButton: false
        });
        return result;
      } else {
        throw new Error(result.error || "Failed to create user");
      }
    } catch (error2) {
      console.error("Error creating user:", error2);
      this.handleError(error2, "Failed to create user");
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async updateUserProfile(profileData, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const currentUser = await this.getCurrentUser(null);
      const command = {
        userId: currentUser.userID || currentUser.id || "current",
        updates: profileData
      };
      const result = await this.eventBus.send("UpdateProfileCommand", command);
      if (result instanceof Error) {
        throw result;
      }
      if (result.success) {
        Swal.fire({
          icon: "success",
          title: "Success",
          text: "Profile updated successfully",
          timer: 2e3,
          showConfirmButton: false
        });
        return result.user;
      } else {
        throw new Error(result.error || "Failed to update profile");
      }
    } catch (error2) {
      console.error("Error updating profile:", error2);
      this.handleError(error2, "Failed to update profile");
      throw error2;
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async deleteUser(userId, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const currentUser = await this.getCurrentUser(null);
      const command = {
        userId,
        deletedBy: String(currentUser._id || currentUser.id || currentUser.email || "system")
      };
      const result = await this.eventBus.send("DeleteUserCommand", command);
      if (result instanceof Error) {
        console.error("[DomainServices.deleteUser] Handler returned Error:", result.message);
        throw result;
      }
      if (!result.success) {
        console.error("[DomainServices.deleteUser] Delete result not successful:", result);
      }
      if (result.success) {
        Swal.fire({
          icon: "success",
          title: "Success",
          text: "User deleted successfully",
          timer: 2e3,
          showConfirmButton: false
        });
        return result;
      } else {
        throw new Error(result.error || "Failed to delete user");
      }
    } catch (error2) {
      console.error("Error deleting user:", error2);
      this.handleError(error2, "Failed to delete user");
      throw error2;
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  // ===== 3. DASHBOARD =====
  // Profile access and self-service
  async getProfile(dispatch) {
    return this.getCurrentUser(dispatch);
  }
  async updateProfile(profileData, dispatch) {
    return this.updateUserProfile(profileData, dispatch);
  }
  // Adapter methods for compatibility with existing components (no dispatch required)
  async getUserProfile() {
    return this.getProfile(null);
  }
  async updateUserProfileCompat(profileData) {
    return this.updateProfile(profileData, null);
  }
  // Self-service password update (different from admin change password)
  async updateSelfServicePassword(passwordData, dispatch) {
    return this.withLoading(dispatch, async () => {
      try {
        const currentUser = await this.getCurrentUser(null);
        const command = {
          currentPassword: passwordData.current_password,
          newPassword: passwordData.new_password,
          confirmPassword: passwordData.confirm_password
        };
        if (command.newPassword !== command.confirmPassword) {
          throw new Error("New password and confirmation do not match");
        }
        const result = await this.eventBus.send("ChangePasswordCommand", {
          userId: String(currentUser.userID || currentUser._id || currentUser.id || "current"),
          currentPassword: command.currentPassword,
          newPassword: command.newPassword
        });
        if (result.success) {
          Swal.fire({
            icon: "success",
            title: "Success",
            text: "Password updated successfully",
            timer: 2e3,
            showConfirmButton: false
          });
          return { message: "Password updated successfully" };
        } else {
          throw new Error(result.error || "Failed to update password");
        }
      } catch (error2) {
        this.handleError(error2, "Failed to update password");
      }
    });
  }
  // ===== 5. EMPLOYEE INFORMATION MANAGER =====
  // Employee profile queries
  async getCurrentEmployee(dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const query = {};
      const result = await this.eventBus.send("GetCurrentEmployeeQuery", query);
      if (result.success) {
        return result.employee;
      } else {
        throw new Error(result.error || "Failed to get current employee");
      }
    } catch (error2) {
      console.error("Error fetching current employee:", error2);
      throw error2;
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async getEmployeeProfile(dispatch) {
    return this.getCurrentEmployee(dispatch);
  }
  async getAllEmployees(dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const query = { page: 1, limit: 100 };
      const result = await this.eventBus.send("GetAllEmployeesQuery", query);
      if (result.success) {
        return result.employees;
      } else {
        throw new Error(result.error || "Failed to get all employees");
      }
    } catch (error2) {
      console.error("Error fetching all employees:", error2);
      return [];
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async getEmployeesByDepartment(deptCode, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const query = { deptCode };
      const result = await this.eventBus.send("GetEmployeesByDepartmentQuery", query);
      if (result.success) {
        return result.employees;
      } else {
        throw new Error(result.error || "Failed to get employees by department");
      }
    } catch (error2) {
      console.error("Error fetching employees by department:", error2);
      return [];
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async getEmployeesByManager(managerId, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const query = { managerId };
      const result = await this.eventBus.send("GetEmployeesByManagerQuery", query);
      if (result.success) {
        return result.employees;
      } else {
        throw new Error(result.error || "Failed to get employees by manager");
      }
    } catch (error2) {
      console.error("Error fetching employees by manager:", error2);
      return [];
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async getEmployeesByStatus(status, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const query = { status };
      const result = await this.eventBus.send("GetEmployeesByStatusQuery", query);
      if (result.success) {
        return result.employees;
      } else {
        throw new Error(result.error || "Failed to get employees by status");
      }
    } catch (error2) {
      console.error("Error fetching employees by status:", error2);
      return [];
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async searchEmployees(searchQuery, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const query = { query: searchQuery };
      const result = await this.eventBus.send("SearchEmployeesQuery", query);
      if (result.success) {
        return result.employees;
      } else {
        throw new Error(result.error || "Failed to search employees");
      }
    } catch (error2) {
      console.error("Error searching employees:", error2);
      return [];
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async getEmployeesByJobRole(jobRole, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const query = { jobRole };
      const result = await this.eventBus.send("GetEmployeesByJobRoleQuery", query);
      if (result.success) {
        return result.employees;
      } else {
        throw new Error(result.error || "Failed to get employees by job role");
      }
    } catch (error2) {
      console.error("Error fetching employees by job role:", error2);
      return [];
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async getEmployeesByContractType(contractType, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const query = { contractType };
      const result = await this.eventBus.send("GetEmployeesByContractTypeQuery", query);
      if (result.success) {
        return result.employees;
      } else {
        throw new Error(result.error || "Failed to get employees by contract type");
      }
    } catch (error2) {
      console.error("Error fetching employees by contract type:", error2);
      return [];
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  // Employee profile commands
  async updateEmployeeProfile(profileData, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const command = profileData;
      const result = await this.eventBus.send("UpdateEmployeeProfileCommand", command);
      if (result.success) {
        Swal.fire({
          icon: "success",
          title: "Success",
          text: "Employee profile updated successfully",
          timer: 2e3,
          showConfirmButton: false
        });
        return result.data;
      } else {
        throw new Error(result.error || "Failed to update employee profile");
      }
    } catch (error2) {
      console.error("Error updating employee profile:", error2);
      this.handleError(error2, "Failed to update employee profile");
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  async deleteEmployee(employeeId, dispatch) {
    try {
      if (dispatch) dispatch(setLoading(true));
      const currentUser = await this.getCurrentUser();
      const command = {
        employeeId,
        deletedBy: currentUser.email || currentUser.userID
      };
      const result = await this.eventBus.send("DeleteEmployeeCommand", command);
      if (result instanceof Error) {
        throw result;
      }
      if (result.success) {
        Swal.fire({
          icon: "success",
          title: "Success",
          text: result.message || "Employee deleted successfully",
          timer: 2e3,
          showConfirmButton: false
        });
      }
      return result;
    } catch (error2) {
      console.error("Error deleting employee:", error2);
      Swal.fire({
        icon: "error",
        title: "Error",
        text: error2.message || "Failed to delete employee"
      });
      throw error2;
    } finally {
      if (dispatch) dispatch(setLoading(false));
    }
  }
  // ===== 4. PERFORMANCE MANAGER =====
  // Performance management methods (placeholders for future implementation)
  async getPerformanceReviews(employeeId, dispatch) {
    console.warn("getPerformanceReviews not implemented yet");
    return [];
  }
  async createPerformanceReview(reviewData, dispatch) {
    console.warn("createPerformanceReview not implemented yet");
    throw new Error("Performance reviews not implemented");
  }
  async updatePerformanceReview(reviewId, reviewData, dispatch) {
    console.warn("updatePerformanceReview not implemented yet");
    throw new Error("Performance reviews not implemented");
  }
  async getGoals(employeeId, dispatch) {
    console.warn("getGoals not implemented yet");
    return [];
  }
  async createGoal(goalData, dispatch) {
    console.warn("createGoal not implemented yet");
    throw new Error("Goals not implemented");
  }
  async updateGoal(goalId, goalData, dispatch) {
    console.warn("updateGoal not implemented yet");
    throw new Error("Goals not implemented");
  }
  // ===== 6. SURVEY MANAGER =====
  // Survey management methods 
  async getSurveys(dispatch) {
    try {
      const { feedbackRepository: feedbackRepository2 } = await __vitePreload(async () => {
        const { feedbackRepository: feedbackRepository3 } = await Promise.resolve().then(() => RepoService$1);
        return { feedbackRepository: feedbackRepository3 };
      }, true ? void 0 : void 0);
      const allFeedback = await feedbackRepository2.getAll();
      const surveys = allFeedback.filter((f2) => f2.feedback_type === "survey");
      return {
        success: true,
        surveys,
        count: surveys.length
      };
    } catch (error2) {
      console.error("getSurveys failed:", error2);
      return {
        success: false,
        surveys: [],
        error: error2.message
      };
    }
  }
  async createSurvey(surveyData, dispatch) {
    try {
      const { feedbackRepository: feedbackRepository2 } = await __vitePreload(async () => {
        const { feedbackRepository: feedbackRepository3 } = await Promise.resolve().then(() => RepoService$1);
        return { feedbackRepository: feedbackRepository3 };
      }, true ? void 0 : void 0);
      const survey = {
        ...surveyData,
        feedback_type: "survey",
        created_date: (/* @__PURE__ */ new Date()).toISOString(),
        status: "active"
      };
      const result = await feedbackRepository2.add(survey);
      return {
        success: true,
        survey_id: result.survey_id || result.id,
        message: "Survey created successfully"
      };
    } catch (error2) {
      console.error("createSurvey failed:", error2);
      throw error2;
    }
  }
  async submitSurveyResponse(responseData, dispatch) {
    try {
      const { feedbackRepository: feedbackRepository2 } = await __vitePreload(async () => {
        const { feedbackRepository: feedbackRepository3 } = await Promise.resolve().then(() => RepoService$1);
        return { feedbackRepository: feedbackRepository3 };
      }, true ? void 0 : void 0);
      if (!responseData.survey_id || !responseData.employee_id || !responseData.responses) {
        throw new Error("Missing required fields: survey_id, employee_id, responses");
      }
      const existingResponses = await feedbackRepository2.find({
        feedback_type: "survey_response",
        survey_id: responseData.survey_id,
        employee_id: responseData.employee_id
      });
      if (existingResponses && existingResponses.length > 0) {
        return {
          success: false,
          message: "Survey already submitted by this employee",
          error: "Survey already submitted by this employee - DUPLICATE_SUBMISSION"
        };
      }
      const mandatoryQuestions = ["Q1", "Q2", "Q3", "Q5"];
      const answeredQuestions = responseData.responses.map((r2) => r2.q_id);
      const missingMandatory = mandatoryQuestions.filter((q) => !answeredQuestions.includes(q));
      if (missingMandatory.length > 0) {
        return {
          success: false,
          message: `Missing mandatory question responses: ${missingMandatory.join(", ")}`,
          error: `Missing mandatory question responses: ${missingMandatory.join(", ")}`
        };
      }
      const surveyResponse = {
        ...responseData,
        feedback_type: "survey_response",
        submission_date: (/* @__PURE__ */ new Date()).toISOString(),
        status: "submitted",
        completion_percentage: 100
      };
      const result = await feedbackRepository2.add(surveyResponse);
      return {
        success: true,
        response_id: result.response_id || result.survey_id || result.id || responseData.survey_id,
        message: "Survey response submitted successfully"
      };
    } catch (error2) {
      console.error("submitSurveyResponse failed:", error2);
      throw error2;
    }
  }
  // ===== 7. REPORT MANAGER =====
  // Generate employee/team performance report
  async generateEmployeeReport(filters, dispatch) {
    try {
      const { performanceReviewRepository: performanceReviewRepository2, performanceMetricRepository: performanceMetricRepository2 } = await __vitePreload(async () => {
        const { performanceReviewRepository: performanceReviewRepository3, performanceMetricRepository: performanceMetricRepository3 } = await Promise.resolve().then(() => RepoService$1);
        return { performanceReviewRepository: performanceReviewRepository3, performanceMetricRepository: performanceMetricRepository3 };
      }, true ? void 0 : void 0);
      const query = {};
      if (filters.manager_id) query.manager_id = filters.manager_id;
      if (filters.period || filters.review_period) query.review_period = filters.period || filters.review_period;
      const reviews = await performanceReviewRepository2.find(query);
      const reviewArray = Array.isArray(reviews) ? reviews : reviews ? [reviews] : [];
      let statistics = null;
      if (filters.include_statistics && reviewArray.length > 0) {
        const totalRating = reviewArray.reduce((sum, r2) => sum + (r2.overall_rating || 0), 0);
        statistics = {
          team_size: reviewArray.length,
          team_average_rating: reviewArray.length > 0 ? totalRating / reviewArray.length : 0,
          total_reviews: reviewArray.length
        };
      }
      let metrics = null;
      if (filters.include_metrics) {
        metrics = await performanceMetricRepository2.find({
          metric_category: { $in: filters.include_metrics }
        });
      }
      return {
        success: true,
        report: {
          generated_date: (/* @__PURE__ */ new Date()).toISOString(),
          period: filters.period || "All",
          team_size: reviewArray.length,
          reviews: reviewArray,
          statistics,
          metrics: metrics || []
        },
        data: reviewArray,
        statistics,
        message: "Team performance report generated successfully"
      };
    } catch (error2) {
      console.error("generateEmployeeReport failed:", error2);
      return {
        success: false,
        error: error2.message,
        report: null,
        data: []
      };
    }
  }
  // Generate organization-wide user performance report
  async generateUserReport(filters, dispatch) {
    try {
      const { performanceReviewRepository: performanceReviewRepository2, departmentRepository: departmentRepository2, employeeRepository: employeeRepository2 } = await __vitePreload(async () => {
        const { performanceReviewRepository: performanceReviewRepository3, departmentRepository: departmentRepository3, employeeRepository: employeeRepository3 } = await Promise.resolve().then(() => RepoService$1);
        return { performanceReviewRepository: performanceReviewRepository3, departmentRepository: departmentRepository3, employeeRepository: employeeRepository3 };
      }, true ? void 0 : void 0);
      const query = {};
      if (filters.period) query.review_period = filters.period;
      const allReviews = await performanceReviewRepository2.find(query);
      const reviewArray = Array.isArray(allReviews) ? allReviews : allReviews ? [allReviews] : [];
      let departmentBreakdown = null;
      if (filters.include_breakdown) {
        const departments = await departmentRepository2.find({});
        departmentBreakdown = {};
        const deptArray = Array.isArray(departments) ? departments : departments ? [departments] : [];
        for (const dept of deptArray) {
          const deptReviews = reviewArray.filter((r2) => r2.department === dept.deptcode || r2.department_code === dept.deptcode);
          departmentBreakdown[dept.deptcode] = {
            count: deptReviews.length,
            average_rating: deptReviews.length > 0 ? deptReviews.reduce((sum, r2) => sum + (r2.overall_rating || 0), 0) / deptReviews.length : 0
          };
        }
      }
      let filteredReviews = reviewArray;
      if (filters.date_range_start || filters.date_range_end) {
        const startDate = filters.date_range_start ? new Date(filters.date_range_start) : null;
        const endDate = filters.date_range_end ? new Date(filters.date_range_end) : null;
        filteredReviews = reviewArray.filter((r2) => {
          const reviewDate = new Date(r2.review_date || r2.created_date || "");
          if (startDate && reviewDate < startDate) return false;
          if (endDate && reviewDate > endDate) return false;
          return true;
        });
      }
      return {
        success: true,
        report: {
          generated_date: (/* @__PURE__ */ new Date()).toISOString(),
          scope: "organization",
          period: filters.period || "All",
          total_employees: filteredReviews.length,
          average_rating: filteredReviews.length > 0 ? filteredReviews.reduce((sum, r2) => sum + (r2.overall_rating || 0), 0) / filteredReviews.length : 0,
          department_breakdown: departmentBreakdown,
          date_range: { start: filters.date_range_start, end: filters.date_range_end }
        },
        data: filteredReviews,
        message: "Organization-wide performance report generated successfully"
      };
    } catch (error2) {
      console.error("generateUserReport failed:", error2);
      return {
        success: false,
        error: error2.message,
        report: null,
        data: []
      };
    }
  }
  // Generate enterprise-level performance analytics
  async generatePerformanceReport(filters, dispatch) {
    var _a2;
    try {
      const { performanceReviewRepository: performanceReviewRepository2, performanceMetricRepository: performanceMetricRepository2, employeeRepository: employeeRepository2 } = await __vitePreload(async () => {
        const { performanceReviewRepository: performanceReviewRepository3, performanceMetricRepository: performanceMetricRepository3, employeeRepository: employeeRepository3 } = await Promise.resolve().then(() => RepoService$1);
        return { performanceReviewRepository: performanceReviewRepository3, performanceMetricRepository: performanceMetricRepository3, employeeRepository: employeeRepository3 };
      }, true ? void 0 : void 0);
      const allReviews = await performanceReviewRepository2.find({});
      const reviewArray = Array.isArray(allReviews) ? allReviews : allReviews ? [allReviews] : [];
      let distribution = null;
      if (filters.include_distribution) {
        distribution = {
          excellent: reviewArray.filter((r2) => (r2.overall_rating || 0) >= 4.5).length,
          good: reviewArray.filter((r2) => (r2.overall_rating || 0) >= 3.5 && (r2.overall_rating || 0) < 4.5).length,
          average: reviewArray.filter((r2) => (r2.overall_rating || 0) >= 2.5 && (r2.overall_rating || 0) < 3.5).length,
          needs_improvement: reviewArray.filter((r2) => (r2.overall_rating || 0) < 2.5).length
        };
      }
      let trends = null;
      if (filters.include_trends) {
        const trendMap = {};
        for (const review of reviewArray) {
          const month = review.review_date ? review.review_date.substring(0, 7) : "Unknown";
          if (!trendMap[month]) {
            trendMap[month] = { total: 0, count: 0, average: 0 };
          }
          trendMap[month].total += review.overall_rating || 0;
          trendMap[month].count += 1;
          trendMap[month].average = trendMap[month].total / trendMap[month].count;
        }
        trends = trendMap;
      }
      let skills_insights = null;
      if (filters.include_skills) {
        const skillMap = {};
        for (const review of reviewArray) {
          if (review.skills_evaluated && Array.isArray(review.skills_evaluated)) {
            for (const skill of review.skills_evaluated) {
              if (!skillMap[skill]) {
                skillMap[skill] = { total: 0, count: 0, average: 0 };
              }
              skillMap[skill].total += ((_a2 = review.skill_scores) == null ? void 0 : _a2[skill]) || 0;
              skillMap[skill].count += 1;
              skillMap[skill].average = skillMap[skill].total / skillMap[skill].count;
            }
          }
        }
        skills_insights = skillMap;
      }
      return {
        success: true,
        report: {
          generated_date: (/* @__PURE__ */ new Date()).toISOString(),
          total_reviews: reviewArray.length,
          total_employees: reviewArray.length,
          enterprise_average_rating: reviewArray.length > 0 ? reviewArray.reduce((sum, r2) => sum + (r2.overall_rating || 0), 0) / reviewArray.length : 0,
          average_performance: reviewArray.length > 0 ? reviewArray.reduce((sum, r2) => sum + (r2.overall_rating || 0), 0) / reviewArray.length : 0,
          distribution,
          trends,
          skills_insights
        },
        analytics: {
          total_employees: reviewArray.length,
          average_performance: reviewArray.length > 0 ? reviewArray.reduce((sum, r2) => sum + (r2.overall_rating || 0), 0) / reviewArray.length : 0
        },
        data: reviewArray,
        message: "Enterprise performance analytics generated successfully"
      };
    } catch (error2) {
      console.error("generatePerformanceReport failed:", error2);
      return {
        success: false,
        error: error2.message,
        report: null,
        data: []
      };
    }
  }
  // ===== 8. AI POWERED FEATURES OR CHATBOT INTERFACE =====
  // AI/Chatbot methods (placeholders for future implementation)
  async sendChatMessage(message, dispatch) {
    console.warn("sendChatMessage not implemented yet");
    throw new Error("AI Chatbot not implemented");
  }
  async getChatHistory(dispatch) {
    console.warn("getChatHistory not implemented yet");
    return [];
  }
  // Helper: Error Handling
  handleError(error2, fallbackMessage = "An error occurred") {
    const message = error2.message || fallbackMessage;
    Swal.fire({
      icon: "error",
      title: "Oops...",
      text: message
    });
    throw error2;
  }
  // Helper: Get authentication token
  getToken() {
    return localStorage.getItem("auth_token") || sessionStorage.getItem("auth_token") || "";
  }
  // Centralized error handler
  createErrorHandler(translations = {}) {
    const defaultTranslations = {
      "network.offline": "No internet connection. Please check your network.",
      "network.timeout": "Request timed out. Please try again.",
      "auth.required": "Please log in to continue.",
      "auth.expired": "Your session has expired. Please log in again.",
      "permission.denied": "You don't have permission to perform this action.",
      "validation.failed": "Please check your input and try again.",
      "server.error": "Server error. Please try again later.",
      "resource.notfound": "The requested resource was not found.",
      "default": "An unexpected error occurred. Please try again."
    };
    const t2 = { ...defaultTranslations, ...translations };
    return (error2, options = {}) => {
      const errorKey = error2.code || error2.type || "default";
      const message = t2[errorKey] || t2.default;
      return Swal.fire({
        icon: "error",
        title: "Error",
        text: message,
        showConfirmButton: true,
        confirmButtonText: options.retry ? "Retry" : "OK"
      });
    };
  }
  // Helper function to determine if retry should be offered
  shouldShowRetry(error2) {
    return false;
  }
  // Show error message
  showError(message, showRetry = false) {
    return Swal.fire({
      icon: "error",
      title: "Error",
      text: message,
      showConfirmButton: true,
      confirmButtonText: showRetry ? "Retry" : "OK"
    });
  }
  // ===== ADDITIONAL METHODS FOR API SERVICES COMPATIBILITY =====
  // Password management - additional methods
  async resetPassword(payload, dispatch) {
    console.warn("resetPassword not implemented in DomainServices (requires backend API)");
    throw new Error("Password reset requires backend API");
  }
  async forgotPassword(data, dispatch) {
    console.warn("forgotPassword not implemented in DomainServices (requires backend API)");
    throw new Error("Forgot password requires backend API");
  }
  // User management - additional methods
  async bulkCreateUsers(users, dispatch) {
    console.warn("bulkCreateUsers not implemented in DomainServices");
    throw new Error("Bulk user creation not implemented");
  }
  // Dashboard - backward-compatible method names
  async getUserProfile(dispatch) {
    console.log("getUserProfile called - delegating to getProfile");
    return this.getProfile(dispatch);
  }
  // Note: updateUserProfile is already defined in User Account Commands section
  // Employee management - additional methods
  async getCurrentEmployeeData(dispatch) {
    return this.getCurrentEmployee(dispatch);
  }
  async getEmployeeById(employeeId, dispatch) {
    console.warn("getEmployeeById not fully implemented");
    return null;
  }
  async getEmployee(employeeId, dispatch) {
    return this.getEmployeeById(employeeId, dispatch);
  }
  async getEmployeesForManager(dispatch) {
    console.warn("getEmployeesForManager not implemented");
    return [];
  }
  async getEmployeeForManager(managerId, employeeId, dispatch) {
    console.warn("getEmployeeForManager not implemented");
    return null;
  }
  async getEmployeesByDepartmentForManager(dispatch) {
    console.warn("getEmployeesByDepartmentForManager not implemented");
    return [];
  }
  async getEmployees(dispatch) {
    return this.getAllEmployees(dispatch);
  }
  // Department Management - CQRS via EventBus
  async getAllDepartments(limit, dispatch) {
    try {
      const query = { limit: limit || 100 };
      const result = await this.eventBus.send("GetAllDepartmentsQuery", query);
      if (result instanceof Error) {
        return { success: false, departments: [], errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getAllDepartments error:", error2);
      return { success: false, departments: [], errors: [error2.message] };
    }
  }
  async createDepartment(payload, dispatch) {
    try {
      const command = {
        deptcode: payload.deptcode,
        deptname: payload.deptname
      };
      const result = await this.eventBus.send("CreateDepartmentCommand", command);
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] createDepartment error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async getDepartment(departmentId, dispatch) {
    try {
      const query = { deptcode: departmentId };
      const result = await this.eventBus.send("GetDepartmentByIdQuery", query);
      if (result instanceof Error) {
        return { success: false, department: null, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getDepartment error:", error2);
      return { success: false, department: null, errors: [error2.message] };
    }
  }
  async updateDepartment(sno, payload, dispatch) {
    try {
      const command = {
        deptcode: sno,
        updates: payload
      };
      const result = await this.eventBus.send("UpdateDepartmentCommand", command);
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] updateDepartment error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async deleteDepartment(departmentId, dispatch) {
    try {
      const command = { deptcode: departmentId };
      const result = await this.eventBus.send("DeleteDepartmentCommand", command);
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] deleteDepartment error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  // Manager Management - stubs (require backend API)
  async getCurrentManager(dispatch) {
    throw new Error("Manager management requires backend API");
  }
  async createManager(managerData, dispatch) {
    throw new Error("Manager management requires backend API");
  }
  async getManager(id, dispatch) {
    throw new Error("Manager management requires backend API");
  }
  async getallmanagers(dispatch) {
    return [];
  }
  async updateManager(id, managerData, dispatch) {
    throw new Error("Manager management requires backend API");
  }
  async deleteManager(id, dispatch) {
    throw new Error("Manager management requires backend API");
  }
  async getManagerUsers(dispatch) {
    return [];
  }
  async getManagersByDepartment(departmentName) {
    return [];
  }
  async getManagerByDepartment(departmentName, dispatch) {
    return null;
  }
  async getDepartmentManager(departmentCode, dispatch) {
    return null;
  }
  // Goals Management - CQRS via EventBus
  async getAllGoals(dispatch) {
    try {
      const result = await this.eventBus.send("GetAllGoalsQuery", {});
      if (result instanceof Error) {
        throw result;
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getAllGoals error:", error2);
      return { success: false, goals: [], errors: [error2.message] };
    }
  }
  async createGoal(goalData, dispatch) {
    try {
      const result = await this.eventBus.send("CreateGoalCommand", goalData);
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] createGoal error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async deleteGoal(goalId, dispatch) {
    try {
      const result = await this.eventBus.send("DeleteGoalCommand", { goalID: goalId });
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] deleteGoal error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async approveGoal(sno, dispatch) {
    try {
      const result = await this.eventBus.send("ApproveGoalCommand", { goalID: sno });
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] approveGoal error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async rejectGoal(sno, dispatch) {
    try {
      const result = await this.eventBus.send("RejectGoalCommand", { goalID: sno });
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] rejectGoal error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  // Goal Progress Tracking - CQRS via EventBus
  async createGoalProgress(goalId, progressData, dispatch) {
    try {
      const result = await this.eventBus.send("CreateGoalProgressCommand", {
        goalID: goalId,
        ...progressData
      });
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] createGoalProgress error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async getGoalProgressHistory(goalId, dispatch) {
    try {
      const result = await this.eventBus.send("GetGoalProgressQuery", { goalID: goalId });
      if (result instanceof Error) {
        return { success: false, history: [], errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getGoalProgressHistory error:", error2);
      return { success: false, history: [], errors: [error2.message] };
    }
  }
  async getLatestGoalProgress(goalId, dispatch) {
    try {
      const result = await this.eventBus.send("GetLatestGoalProgressQuery", { goalID: goalId });
      if (result instanceof Error) {
        return { success: false, progress: null, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getLatestGoalProgress error:", error2);
      return { success: false, progress: null, errors: [error2.message] };
    }
  }
  async updateGoalProgress(progressId, progressData, dispatch) {
    throw new Error("Goal progress update requires backend API");
  }
  async deleteGoalProgress(progressId, dispatch) {
    throw new Error("Goal progress delete requires backend API");
  }
  // Business Goals - CQRS via EventBus
  async getAllBusinessGoals(dispatch) {
    try {
      const result = await this.eventBus.send("GetAllBusinessGoalsQuery", {});
      if (result instanceof Error) {
        return { success: false, businessGoals: [], errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getAllBusinessGoals error:", error2);
      return { success: false, businessGoals: [], errors: [error2.message] };
    }
  }
  async createBusinessGoal(goalData, dispatch) {
    try {
      const result = await this.eventBus.send("CreateBusinessGoalCommand", goalData);
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] createBusinessGoal error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async updateBusinessGoal(sno, goalData, dispatch) {
    try {
      const result = await this.eventBus.send("UpdateBusinessGoalCommand", {
        busgoalID: sno,
        updates: goalData
      });
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] updateBusinessGoal error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async deleteBusinessGoal(sno, dispatch) {
    try {
      const result = await this.eventBus.send("DeleteBusinessGoalCommand", { busgoalID: sno });
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] deleteBusinessGoal error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  // Goal Categories - CQRS via EventBus
  async getAllGoalCategories(dispatch) {
    try {
      const result = await this.eventBus.send("GetAllGoalCategoriesQuery", {});
      if (result instanceof Error) {
        return { success: false, categories: [], errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getAllGoalCategories error:", error2);
      return { success: false, categories: [], errors: [error2.message] };
    }
  }
  async createGoalCategory(categoryData, dispatch) {
    try {
      const result = await this.eventBus.send("CreateGoalCategoryCommand", categoryData);
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] createGoalCategory error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async updateGoalCategory(categoryId, categoryData, dispatch) {
    try {
      const result = await this.eventBus.send("UpdateGoalCategoryCommand", {
        goalCatID: categoryId,
        updates: categoryData
      });
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] updateGoalCategory error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async deleteGoalCategory(categoryId, dispatch) {
    try {
      const result = await this.eventBus.send("DeleteGoalCategoryCommand", { goalCatID: categoryId });
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] deleteGoalCategory error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async getGoalCategory(categoryId, dispatch) {
    try {
      const result = await this.eventBus.send("GetGoalCategoryByIdQuery", { goalCatID: categoryId });
      if (result instanceof Error) {
        return { success: false, category: null, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getGoalCategory error:", error2);
      return { success: false, category: null, errors: [error2.message] };
    }
  }
  // Performance Criteria - stubs
  async createPcriteria(payload, dispatch) {
    throw new Error("Performance criteria require backend API");
  }
  async getPcriteria(sno, dispatch) {
    return null;
  }
  async updatePcriteria(sno, payload, dispatch) {
    throw new Error("Performance criteria require backend API");
  }
  async deletePcriteria(sno, dispatch) {
    throw new Error("Performance criteria require backend API");
  }
  async getAllPcriteria(dispatch) {
    return [];
  }
  // Performance Metrics - stubs
  async getAllPerformanceMetrics(dispatch) {
    return [];
  }
  async createPerformanceMetric(metricData, dispatch) {
    throw new Error("Performance metrics require backend API");
  }
  async updatePerformanceMetric(metricId, metricData, dispatch) {
    throw new Error("Performance metrics require backend API");
  }
  async deletePerformanceMetric(metricId, dispatch) {
    throw new Error("Performance metrics require backend API");
  }
  // Development Plans - CQRS via EventBus
  async getAllDevelopmentPlans(dispatch) {
    try {
      const result = await this.eventBus.send("GetAllDevelopmentPlansQuery", {});
      if (result instanceof Error) {
        return { success: false, plans: [], errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getAllDevelopmentPlans error:", error2);
      return { success: false, plans: [], errors: [error2.message] };
    }
  }
  async createDevelopmentPlan(planData, dispatch) {
    try {
      const command = {
        employee: planData.employee,
        ID: planData.ID,
        competency_area: planData.competency_area,
        plan_description: planData.plan_description,
        skills: planData.skills,
        projected_start_date: planData.projected_start_date,
        projected_target_date: planData.projected_target_date,
        dev_year: planData.dev_year,
        mode: planData.mode
      };
      const result = await this.eventBus.send("CreateDevelopmentPlanCommand", command);
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] createDevelopmentPlan error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async updateDevelopmentPlan(planId, planData, dispatch) {
    try {
      const command = {
        planID: planId,
        updates: planData
      };
      const result = await this.eventBus.send("UpdateDevelopmentPlanCommand", command);
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] updateDevelopmentPlan error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async deleteDevelopmentPlan(planId, dispatch) {
    try {
      const command = { planID: planId };
      const result = await this.eventBus.send("DeleteDevelopmentPlanCommand", command);
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] deleteDevelopmentPlan error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async getDevelopmentPlansByEmployee(employeeId, dispatch) {
    try {
      const query = { employee: employeeId };
      const result = await this.eventBus.send("GetDevelopmentPlansByEmployeeQuery", query);
      if (result instanceof Error) {
        return { success: false, plans: [], errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getDevelopmentPlansByEmployee error:", error2);
      return { success: false, plans: [], errors: [error2.message] };
    }
  }
  async getDevelopmentPlansByStatus(status, dispatch) {
    try {
      const query = { plan_status: status };
      const result = await this.eventBus.send("GetDevelopmentPlansByStatusQuery", query);
      if (result instanceof Error) {
        return { success: false, plans: [], errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getDevelopmentPlansByStatus error:", error2);
      return { success: false, plans: [], errors: [error2.message] };
    }
  }
  // Appraisal Periods - CQRS via EventBus
  async getAllAppraisalPeriods(dispatch) {
    try {
      const result = await this.eventBus.send("GetAllAppraisalPeriodsQuery", {});
      if (result instanceof Error) {
        return { success: false, periods: [], errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getAllAppraisalPeriods error:", error2);
      return { success: false, periods: [], errors: [error2.message] };
    }
  }
  async createAppraisalPeriod(periodData, dispatch) {
    try {
      const command = {
        period_start: periodData.period_start,
        period_end: periodData.period_end,
        review_start_date: periodData.review_start_date,
        review_end_date: periodData.review_end_date,
        review_status: periodData.review_status || "scheduled"
      };
      const result = await this.eventBus.send("CreateAppraisalPeriodCommand", command);
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] createAppraisalPeriod error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async updateAppraisalPeriod(id, periodData, dispatch) {
    try {
      const command = {
        periodID: id,
        updates: periodData
      };
      const result = await this.eventBus.send("UpdateAppraisalPeriodCommand", command);
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] updateAppraisalPeriod error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async deleteAppraisalPeriod(id, dispatch) {
    try {
      const command = { periodID: id };
      const result = await this.eventBus.send("DeleteAppraisalPeriodCommand", command);
      if (result instanceof Error) {
        return { success: false, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] deleteAppraisalPeriod error:", error2);
      return { success: false, errors: [error2.message] };
    }
  }
  async getCurrentAppraisalPeriod(dispatch) {
    try {
      const result = await this.eventBus.send("GetCurrentAppraisalPeriodQuery", {});
      if (result instanceof Error) {
        return { success: false, period: null, errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getCurrentAppraisalPeriod error:", error2);
      return { success: false, period: null, errors: [error2.message] };
    }
  }
  async getAppraisalPeriodsByStatus(status, dispatch) {
    try {
      const query = { review_status: status };
      const result = await this.eventBus.send("GetAppraisalPeriodsByStatusQuery", query);
      if (result instanceof Error) {
        return { success: false, periods: [], errors: [result.message] };
      }
      return result;
    } catch (error2) {
      console.error("[DomainServices] getAppraisalPeriodsByStatus error:", error2);
      return { success: false, periods: [], errors: [error2.message] };
    }
  }
  // 360-Degree Appraisal Configuration - stubs
  async getAppraisalConfigurations(dispatch, skip, limit) {
    return [];
  }
  async getAllAppraisalConfigurations(dispatch) {
    return [];
  }
  async getAppraisalConfiguration(configSno, dispatch) {
    return null;
  }
  async getActiveAppraisalConfigurations(dispatch) {
    return [];
  }
  async createAppraisalConfiguration(configData, dispatch) {
    throw new Error("Appraisal configuration requires backend API");
  }
  async updateAppraisalConfiguration(configId, configData, dispatch) {
    throw new Error("Appraisal configuration requires backend API");
  }
  async deleteAppraisalConfiguration(configId, dispatch) {
    throw new Error("Appraisal configuration requires backend API");
  }
  async getAppraisalConfigs(dispatch) {
    return [];
  }
  // Assessment Criteria - stubs
  async getAssessmentCriteria(configId, dispatch) {
    return [];
  }
  async getCriteriaByType(criteriaType, dispatch) {
    return [];
  }
  async createAssessmentCriteria(criteriaData, dispatch) {
    throw new Error("Assessment criteria require backend API");
  }
  async updateAssessmentCriteria(criteriaId, criteriaData, dispatch) {
    throw new Error("Assessment criteria require backend API");
  }
  async deleteAssessmentCriteria(criteriaId, dispatch) {
    throw new Error("Assessment criteria require backend API");
  }
  async getManagerAssessmentCriteria(configId, dispatch) {
    return [];
  }
  async getAppraisalCriteriaByType(type, dispatch) {
    return [];
  }
  async getPeerCriteria(dispatch) {
    return [];
  }
  // General Assessments - stubs
  async getAssessments(filters, dispatch) {
    return [];
  }
  async getAssessment(assessmentId, dispatch) {
    return null;
  }
  async getAssessmentsByConfig(configSno, employeeId, skip, limit, dispatch) {
    return [];
  }
  async getAssessmentsByEmployee(employeeId, dispatch) {
    return [];
  }
  async createAssessment(assessmentData, dispatch) {
    throw new Error("Assessments require backend API");
  }
  async updateAssessment(assessmentId, assessmentData, dispatch) {
    throw new Error("Assessments require backend API");
  }
  async submitAssessment(assessmentId, dispatch) {
    throw new Error("Assessments require backend API");
  }
  async deleteAssessment(assessmentId, dispatch) {
    throw new Error("Assessments require backend API");
  }
  async getAssessmentSummary(configId, dispatch) {
    return null;
  }
  async getAssessmentTypesForEmployee(employeeId, dispatch) {
    return [];
  }
  // Self-Assessment - stubs
  async getSelfAssessment(assessmentId, dispatch) {
    return null;
  }
  async getSelfAssessments(dispatch) {
    return [];
  }
  async createSelfAssessment(assessmentData, dispatch) {
    throw new Error("Self-assessment requires backend API");
  }
  async updateSelfAssessment(assessmentId, assessmentData, dispatch) {
    throw new Error("Self-assessment requires backend API");
  }
  async submitSelfAssessment(assessmentId, dispatch) {
    throw new Error("Self-assessment requires backend API");
  }
  async deleteSelfAssessment(assessmentId, dispatch) {
    throw new Error("Self-assessment requires backend API");
  }
  async getSelfAssessmentSummary(dispatch) {
    return null;
  }
  // Manager Assessment - stubs
  async createManagerAssessment(assessmentData, dispatch) {
    throw new Error("Manager assessment requires backend API");
  }
  async updateManagerAssessment(sno, assessmentData, dispatch) {
    throw new Error("Manager assessment requires backend API");
  }
  async getManagerAssessment(sno, dispatch) {
    return null;
  }
  async deleteManagerAssessment(sno, dispatch) {
    throw new Error("Manager assessment requires backend API");
  }
  async getManagerAssessments(params, dispatch) {
    return [];
  }
  async submitManagerAssessment(sno, dispatch) {
    throw new Error("Manager assessment requires backend API");
  }
  async getManagerAssessmentSummary(dispatch) {
    return null;
  }
  async saveOrUpdateManagerAssessment(assessmentData, dispatch) {
    throw new Error("Manager assessment requires backend API");
  }
  // Peer Assessment - stubs
  async createPeerAssessment(assessmentData, dispatch) {
    throw new Error("Peer assessment requires backend API");
  }
  async updatePeerAssessment(sno, assessmentData, dispatch) {
    throw new Error("Peer assessment requires backend API");
  }
  async getPeerAssessment(sno, dispatch) {
    return null;
  }
  async deletePeerAssessment(sno, dispatch) {
    throw new Error("Peer assessment requires backend API");
  }
  async getPeerAssessments(params, dispatch) {
    return [];
  }
  async submitPeerAssessment(sno, dispatch) {
    throw new Error("Peer assessment requires backend API");
  }
  async getPeerAssessmentSummary(dispatch) {
    return null;
  }
  // Peer/Subordinate Selection - stubs
  async getSubordinates(dispatch) {
    return [];
  }
  async getPeers(dispatch) {
    return [];
  }
  // Feedback System - stubs
  async getAllFeedbacks(skip, limit, dispatch) {
    return [];
  }
  async getFeedback(feedbackId, dispatch) {
    return null;
  }
  async getEmployeeFeedbacks(employeeId, dispatch) {
    return [];
  }
  async createFeedback(feedbackData, dispatch) {
    throw new Error("Feedback requires backend API");
  }
  async updateFeedback(feedbackId, feedbackData, dispatch) {
    throw new Error("Feedback requires backend API");
  }
  async deleteFeedback(feedbackId, dispatch) {
    throw new Error("Feedback requires backend API");
  }
  async getFeedbackStats(dispatch) {
    return null;
  }
  // Custom API calls
  async customApiCall(endpoint, method, data, dispatch) {
    throw new Error("Custom API calls not supported in DomainServices");
  }
}
const domainServices = new DomainServices();
const isDemoMode = true;
const ServiceFactory = {
  // Get the appropriate service instance
  getService: () => {
    {
      console.log(" Using DomainServices (CQRS mode)");
      return domainServices;
    }
  },
  // Check if currently in demo mode
  isDemoMode: () => isDemoMode,
  // Get current mode description
  getCurrentMode: () => "demo",
  // Get available services for debugging
  getAvailableServices: () => ({
    demo: domainServices,
    production: apiServices,
    current: domainServices
  })
};
const APIServices2 = ServiceFactory.getService();
const AuthContext = reactExports.createContext();
const AuthProvider = ({ children }) => {
  const [user, setUser] = reactExports.useState(null);
  const [userType, setUserType] = reactExports.useState(null);
  const [loading, setLoading2] = reactExports.useState(true);
  const [error2, setError] = reactExports.useState(null);
  reactExports.useEffect(() => {
    const checkAuthStatus = async () => {
      try {
        const token = localStorage.getItem("auth_token") || sessionStorage.getItem("auth_token");
        if (!token) {
          setLoading2(false);
          return;
        }
        try {
          const decodedToken = JSON.parse(atob(token));
          console.log("[AUTH] Token decoded directly (demo mode):", decodedToken);
          setUser(decodedToken);
          setUserType(String(decodedToken.userType || decodedToken.role || "employee").toLowerCase());
          setLoading2(false);
          return;
        } catch (decodeError) {
          console.log("[AUTH] Token decode failed, trying API call:", decodeError.message);
        }
        const response = await APIServices2.getCurrentUser();
        const payload = (response == null ? void 0 : response.data) ?? response;
        if (payload) {
          console.log("=== AUTH DEBUG START ===");
          console.log("[AUTH] User payload received:", payload);
          try {
            console.log("[AUTH] Available fields:", Object.keys(payload));
          } catch (e2) {
          }
          console.log("[AUTH] userType field:", payload == null ? void 0 : payload.userType);
          console.log("[AUTH] role field:", payload == null ? void 0 : payload.role);
          setUser(payload);
          const detectedUserType = payload.userType || payload.role || "employee";
          console.log("[AUTH] User type detected:", detectedUserType);
          console.log("=== AUTH DEBUG END ===");
          setUserType(String(detectedUserType).toLowerCase());
        } else {
          console.log("[AUTH] No valid user", response, "received");
        }
      } catch (err) {
        console.error("Authentication error:", err);
        setError("Failed to authenticate user");
      } finally {
        setLoading2(false);
      }
    };
    checkAuthStatus();
  }, []);
  reactExports.useEffect(() => {
    if (user) {
      const detectedUserType = user.userType || user.role || "employee";
      console.log("[AUTH] Updating user type from user object:", detectedUserType);
      setUserType(String(detectedUserType).toLowerCase());
    }
  }, [user]);
  const login = async (credentials) => {
    var _a2, _b, _c, _d;
    try {
      setLoading2(true);
      const response = await APIServices2.login(credentials);
      const payload = (response == null ? void 0 : response.data) ?? response;
      const access_token = (payload == null ? void 0 : payload.access_token) || (payload == null ? void 0 : payload.token) || (payload == null ? void 0 : payload.accessToken);
      const refresh_token = (payload == null ? void 0 : payload.refresh_token) || (payload == null ? void 0 : payload.refreshToken);
      const user2 = (payload == null ? void 0 : payload.user) || payload;
      if (access_token) {
        localStorage.setItem("auth_token", access_token);
      }
      if (refresh_token) {
        localStorage.setItem("refresh_token", refresh_token);
      }
      setUser(user2);
      setUserType(String((user2 == null ? void 0 : user2.userType) || (user2 == null ? void 0 : user2.role) || "employee").toLowerCase());
      return { success: true };
    } catch (err) {
      setError(((_b = (_a2 = err.response) == null ? void 0 : _a2.data) == null ? void 0 : _b.detail) || "Login failed");
      return { success: false, error: ((_d = (_c = err.response) == null ? void 0 : _c.data) == null ? void 0 : _d.detail) || "Login failed" };
    } finally {
      setLoading2(false);
    }
  };
  const logout = () => {
    localStorage.removeItem("auth_token");
    sessionStorage.removeItem("auth_token");
    setUser(null);
    setUserType(null);
  };
  const authContextValue = {
    user,
    userType,
    loading,
    error: error2,
    login,
    logout,
    isAuthenticated: !!user,
    // Expose setUser function for testing purposes
    setUser
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AuthContext.Provider, { value: authContextValue, children });
};
const useAuth = () => {
  const context = reactExports.useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
const MENUITEMS = [
  {
    Items: [
      {
        title: "Dashboards",
        icon: "home",
        type: "sub",
        selected: false,
        active: false,
        roles: ["admin", "manager", "employee"],
        children: [
          {
            path: `dashboard/dashboard01`,
            type: "link",
            active: false,
            selected: false,
            title: "Employee Dashboard",
            roles: ["employee"]
          },
          {
            path: `dashboard/dashboard02`,
            type: "link",
            active: false,
            selected: false,
            title: "Manager Dashboard",
            roles: ["manager"]
          },
          {
            path: `dashboard/dashboard03`,
            type: "link",
            active: false,
            selected: false,
            title: "Admin Dashboard",
            roles: ["admin"]
          },
          {
            path: `dashboard/dashboard04`,
            type: "link",
            active: false,
            selected: false,
            title: "Dashboard 04",
            roles: ["admin"]
          },
          {
            path: `dashboard/dashboard05`,
            type: "link",
            active: false,
            selected: false,
            title: "Dashboard 05",
            roles: ["admin"]
          }
        ]
      }
    ]
  },
  {
    Items: [
      {
        title: "Performance Manager",
        icon: "box",
        type: "sub",
        selected: false,
        active: false,
        roles: ["admin", "manager"],
        children: [
          {
            path: `business/goal`,
            type: "link",
            active: false,
            selected: false,
            title: "Business Goal",
            roles: ["admin", "manager"]
          },
          {
            path: `appraisal/period`,
            type: "link",
            active: false,
            selected: false,
            title: "Setup Appraisal Period",
            roles: ["admin", "manager"]
          },
          {
            path: `develoyment/plan`,
            type: "link",
            active: false,
            selected: false,
            title: "Develoyment Plan",
            roles: ["admin", "manager"]
          },
          {
            path: `feed/details`,
            type: "link",
            active: false,
            selected: false,
            title: "Feed Back List",
            roles: ["admin", "manager"]
          },
          {
            path: `feed/back`,
            type: "link",
            active: false,
            selected: false,
            title: "Create Feed Back",
            roles: ["admin", "manager"]
          },
          {
            path: `goal/approval`,
            type: "link",
            active: false,
            selected: false,
            title: "Goal Approval",
            roles: ["admin", "manager"]
          },
          {
            path: `goal/tracking`,
            type: "link",
            active: false,
            selected: false,
            title: "Goal Tracking",
            roles: ["admin", "manager", "employee"]
          }
        ]
      }
    ]
  },
  {
    Items: [
      {
        title: "360-Degree Appraisal",
        icon: "box",
        type: "sub",
        selected: false,
        active: false,
        roles: ["admin", "manager", "employee"],
        children: [
          {
            path: `appraisal-configurations`,
            type: "link",
            active: false,
            selected: false,
            title: "Appraisal Configurations",
            roles: ["admin", "manager"]
          },
          {
            path: `peer-assessment`,
            type: "link",
            active: false,
            selected: false,
            title: "Peer Assessment",
            roles: ["employee"]
          },
          {
            path: `performance-assessment/`,
            type: "link",
            active: false,
            selected: false,
            title: "Performance Assessment",
            roles: ["admin", "manager"]
          },
          {
            path: `assessment/:configId/self/current`,
            type: "link",
            active: false,
            selected: false,
            title: "Self Assessment",
            roles: ["admin", "manager", "employee"]
          }
        ]
      }
    ]
  },
  {
    Items: [
      {
        title: "Employee Info",
        icon: "edit",
        type: "sub",
        selected: false,
        active: false,
        roles: ["admin", "manager", "employee"],
        children: [
          {
            path: `employee/list`,
            type: "link",
            active: false,
            selected: false,
            title: "Employee Details",
            roles: ["admin", "manager"]
          },
          {
            path: `employee/create`,
            type: "link",
            active: false,
            selected: false,
            title: "Create New Employee",
            roles: ["admin"]
          },
          {
            path: `employee/profile`,
            type: "link",
            active: false,
            selected: false,
            title: "Employee Profile",
            roles: ["admin", "manager", "employee"]
          },
          {
            path: `Goal/Configuration`,
            type: "link",
            active: false,
            selected: false,
            title: "Create Goal",
            roles: ["admin", "manager", "employee"]
          }
        ]
      }
    ]
  },
  {
    Items: [
      {
        title: "Survey Manager",
        icon: "pie-chart",
        type: "sub",
        selected: false,
        active: false,
        roles: ["admin", "manager"],
        children: [
          {
            path: `charts/chartjs`,
            type: "link",
            active: false,
            selected: false,
            title: "Survey List",
            roles: ["admin", "manager"]
          },
          {
            path: `charts/chartjs`,
            type: "link",
            active: false,
            selected: false,
            title: "Survey Participation",
            roles: ["admin", "manager"]
          },
          {
            path: `charts/chartjs`,
            type: "link",
            active: false,
            selected: false,
            title: "Survey Creation",
            roles: ["admin"]
          }
        ]
      }
    ]
  },
  {
    Items: [
      {
        title: "Report Manager",
        icon: "layout",
        type: "sub",
        selected: false,
        active: false,
        roles: ["admin", "manager"],
        children: [
          {
            path: `tables/defaulttable`,
            type: "link",
            active: false,
            selected: false,
            title: "Report Generation",
            roles: ["admin", "manager"]
          },
          {
            path: `tables/defaulttable`,
            type: "link",
            active: false,
            selected: false,
            title: "Report Viewer",
            roles: ["admin", "manager"]
          }
        ]
      }
    ]
  },
  {
    Items: [
      {
        title: "Tools",
        icon: "tool",
        type: "sub",
        selected: false,
        active: false,
        roles: ["admin"],
        children: [
          {
            path: `Tools/Settings`,
            type: "link",
            active: false,
            selected: false,
            title: "Settings",
            roles: ["admin"]
          },
          {
            path: `Setup/Manager`,
            type: "link",
            active: false,
            selected: false,
            title: "Setup Manager",
            roles: ["admin"]
          },
          {
            path: `create/bulkusers`,
            type: "link",
            active: false,
            selected: false,
            title: "Create Bulk Users",
            roles: ["admin"]
          }
        ]
      }
    ]
  }
];
const getMenuItemsByRole = (userType) => {
  if (!userType) return [];
  const isRoleAllowed = (item, role) => {
    return item.roles && item.roles.includes(role);
  };
  return MENUITEMS.map((category) => {
    const filteredItems = category.Items.filter((item) => isRoleAllowed(item, userType)).map((item) => {
      if (item.children) {
        const filteredChildren = item.children.filter((child) => isRoleAllowed(child, userType)).map((child) => {
          if (child.children) {
            return {
              ...child,
              children: child.children.filter((subChild) => isRoleAllowed(subChild, userType))
            };
          }
          return child;
        }).filter(
          (child) => (
            // If child has children, include only if it has at least one accessible child
            !child.children || child.children.length > 0
          )
        );
        return {
          ...item,
          children: filteredChildren
        };
      }
      return item;
    });
    return {
      ...category,
      Items: filteredItems
    };
  }).filter((category) => category.Items.length > 0);
};
const useUserMenu = () => {
  const { userType } = useAuth();
  const menuItems = reactExports.useMemo(() => {
    if (!userType) {
      console.log("[MENU] No userType available - user not authenticated");
      return [];
    }
    const currentUserType = userType.toLowerCase();
    console.log("[MENU] Filtering menu for userType:", userType);
    console.log("[MENU] Current userType (normalized):", currentUserType);
    const filtered = getMenuItemsByRole(currentUserType);
    console.log("[MENU] Filtered menu items:", filtered.length);
    console.log("[MENU] Filtered menu structure:", filtered.map((category) => {
      var _a2, _b;
      return {
        categoryItems: ((_a2 = category.Items) == null ? void 0 : _a2.length) || 0,
        items: ((_b = category.Items) == null ? void 0 : _b.map((item) => ({
          title: item.title,
          roles: item.roles,
          hasChildren: !!item.children
        }))) || []
      };
    }));
    return filtered;
  }, [userType]);
  return {
    menuItems,
    userType,
    isMenuLoaded: !!userType
  };
};
const MenuContext = reactExports.createContext({
  menuItems: [],
  userType: null,
  isMenuLoaded: false
});
const MenuProvider = ({ children }) => {
  const { menuItems, userType, isMenuLoaded } = useUserMenu();
  const contextValue = {
    menuItems: menuItems || [],
    userType: userType || null,
    isMenuLoaded: isMenuLoaded || false
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuContext.Provider, { value: contextValue, children });
};
const useMenu = () => {
  const context = reactExports.useContext(MenuContext);
  if (context === void 0) {
    throw new Error("useMenu must be used within a MenuProvider");
  }
  return context;
};
const ProtectedRoute = ({ allowedRoles }) => {
  const { userType, isAuthenticated, loading } = useAuth();
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Loading..." });
  }
  if (!isAuthenticated) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/Login", replace: true });
  }
  if (!allowedRoles.includes(userType)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/dashboard/dashboard01", replace: true });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {});
};
const RoleSwitcher = () => {
  const { userType, user, setUser } = useAuth();
  const [selectedRole, setSelectedRole] = reactExports.useState(userType || "employee");
  const handleRoleChange = (e2) => {
    const newRole = e2.target.value;
    setSelectedRole(newRole);
    if (user) {
      const updatedUser = { ...user, userType: newRole };
      setUser(updatedUser);
      localStorage.setItem("user", JSON.stringify(updatedUser));
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
    padding: "10px",
    margin: "10px",
    border: "1px solid #ccc",
    borderRadius: "5px",
    background: "#f5f5f5"
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Role Switcher (For Testing Only)" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
      "Current Role: ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: userType || "Not Set" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "role-select", children: "Switch Role: " }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "select",
        {
          id: "role-select",
          value: selectedRole,
          onChange: handleRoleChange,
          style: { padding: "5px" },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "admin", children: "Admin" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "manager", children: "Manager" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "employee", children: "Employee" })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: "10px", fontSize: "0.8rem", color: "#666" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Note:" }),
      " This component is for testing purposes only and should be removed in production."
    ] })
  ] });
};
var classnames$1 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var hasRequiredClassnames;
function requireClassnames() {
  if (hasRequiredClassnames) return classnames$1.exports;
  hasRequiredClassnames = 1;
  (function(module) {
    (function() {
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else {
        window.classNames = classNames2;
      }
    })();
  })(classnames$1);
  return classnames$1.exports;
}
var classnamesExports = requireClassnames();
const classnames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
function ownKeys$6(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
      _defineProperty$b(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _typeof$7(obj) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$7(obj);
}
function getScrollbarWidth() {
  var scrollDiv = document.createElement("div");
  scrollDiv.style.position = "absolute";
  scrollDiv.style.top = "-9999px";
  scrollDiv.style.width = "50px";
  scrollDiv.style.height = "50px";
  scrollDiv.style.overflow = "scroll";
  document.body.appendChild(scrollDiv);
  var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
}
function setScrollbarWidth(padding) {
  document.body.style.paddingRight = padding > 0 ? "".concat(padding, "px") : null;
}
function isBodyOverflowing() {
  return document.body.clientWidth < window.innerWidth;
}
function getOriginalBodyPadding() {
  var style = window.getComputedStyle(document.body, null);
  return parseInt(style && style.getPropertyValue("padding-right") || 0, 10);
}
function conditionallyUpdateScrollbar() {
  var scrollbarWidth = getScrollbarWidth();
  var fixedContent = document.querySelectorAll(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top")[0];
  var bodyPadding = fixedContent ? parseInt(fixedContent.style.paddingRight || 0, 10) : 0;
  if (isBodyOverflowing()) {
    setScrollbarWidth(bodyPadding + scrollbarWidth);
  }
}
var globalCssModule;
function mapToCssModules() {
  var className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var cssModule = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : globalCssModule;
  if (!cssModule) return className;
  return className.split(" ").map(function(c2) {
    return cssModule[c2] || c2;
  }).join(" ");
}
function omit(obj, omitKeys) {
  var result = {};
  Object.keys(obj).forEach(function(key) {
    if (omitKeys.indexOf(key) === -1) {
      result[key] = obj[key];
    }
  });
  return result;
}
function pick(obj, keys) {
  var pickKeys = Array.isArray(keys) ? keys : [keys];
  var length = pickKeys.length;
  var key;
  var result = {};
  while (length > 0) {
    length -= 1;
    key = pickKeys[length];
    result[key] = obj[key];
  }
  return result;
}
var warned = {};
function warnOnce(message) {
  if (!warned[message]) {
    if (typeof console !== "undefined") {
      console.error(message);
    }
    warned[message] = true;
  }
}
function deprecated(propType, explanation) {
  return function validate(props, propName, componentName) {
    if (props[propName] !== null && typeof props[propName] !== "undefined") {
      warnOnce('"'.concat(propName, '" property of "').concat(componentName, '" has been deprecated.\n').concat(explanation));
    }
    for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest[_key - 3] = arguments[_key];
    }
    return propType.apply(void 0, [props, propName, componentName].concat(rest));
  };
}
var Element$1 = (typeof window === "undefined" ? "undefined" : _typeof$7(window)) === "object" && window.Element || function() {
};
function DOMElement(props, propName, componentName) {
  if (!(props[propName] instanceof Element$1)) {
    return new Error("Invalid prop `" + propName + "` supplied to `" + componentName + "`. Expected prop to be an instance of Element. Validation failed.");
  }
}
var targetPropType = PropTypes.oneOfType([PropTypes.string, PropTypes.func, DOMElement, PropTypes.shape({
  current: PropTypes.any
})]);
var tagPropType = PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.shape({
  $$typeof: PropTypes.symbol,
  render: PropTypes.func
}), PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.shape({
  $$typeof: PropTypes.symbol,
  render: PropTypes.func
})]))]);
var TransitionTimeouts = {
  Fade: 150,
  // $transition-fade
  Collapse: 350,
  // $transition-collapse
  Modal: 300,
  // $modal-transition
  Carousel: 600
};
var TransitionPropTypeKeys = ["in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited"];
var TransitionStatuses = {
  ENTERING: "entering",
  ENTERED: "entered",
  EXITING: "exiting",
  EXITED: "exited"
};
var keyCodes = {
  esc: 27,
  space: 32,
  enter: 13,
  tab: 9,
  up: 38,
  down: 40,
  home: 36,
  end: 35,
  n: 78,
  p: 80
};
var PopperPlacements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function isReactRefObj(target) {
  if (target && _typeof$7(target) === "object") {
    return "current" in target;
  }
  return false;
}
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}
function isObject(value) {
  var type = _typeof$7(value);
  return value != null && (type === "object" || type === "function");
}
function toNumber(value) {
  var type = _typeof$7(value);
  var NAN = 0 / 0;
  if (type === "number") {
    return value;
  }
  if (type === "symbol" || type === "object" && getTag(value) === "[object Symbol]") {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf === "function" ? value.valueOf() : value;
    value = isObject(other) ? "".concat(other) : other;
  }
  if (type !== "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(/^\s+|\s+$/g, "");
  var isBinary = /^0b[01]+$/i.test(value);
  return isBinary || /^0o[0-7]+$/i.test(value) ? parseInt(value.slice(2), isBinary ? 2 : 8) : /^[-+]0x[0-9a-f]+$/i.test(value) ? NAN : +value;
}
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = getTag(value);
  return tag === "[object Function]" || tag === "[object AsyncFunction]" || tag === "[object GeneratorFunction]" || tag === "[object Proxy]";
}
function findDOMElements(target) {
  if (isReactRefObj(target)) {
    return target.current;
  }
  if (isFunction(target)) {
    return target();
  }
  if (typeof target === "string" && canUseDOM) {
    var selection = document.querySelectorAll(target);
    if (!selection.length) {
      selection = document.querySelectorAll("#".concat(target));
    }
    if (!selection.length) {
      throw new Error("The target '".concat(target, "' could not be identified in the dom, tip: check spelling"));
    }
    return selection;
  }
  return target;
}
function isArrayOrNodeList(els) {
  if (els === null) {
    return false;
  }
  return Array.isArray(els) || canUseDOM && typeof els.length === "number";
}
function getTarget(target, allElements) {
  var els = findDOMElements(target);
  if (allElements) {
    if (isArrayOrNodeList(els)) {
      return els;
    }
    if (els === null) {
      return [];
    }
    return [els];
  }
  if (isArrayOrNodeList(els)) {
    return els[0];
  }
  return els;
}
var focusableElements = ["a[href]", "area[href]", "input:not([disabled]):not([type=hidden])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "object", "embed", "[tabindex]:not(.modal):not(.offcanvas)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'];
function addDefaultProps(defaultProps2, props) {
  if (!defaultProps2 || !props) return props;
  var result = _objectSpread$6({}, props);
  Object.keys(defaultProps2).forEach(function(key) {
    if (result[key] === void 0) {
      result[key] = defaultProps2[key];
    }
    if (Object.keys(defaultProps2[key] || {}).length > 0 && _typeof$7(defaultProps2[key]) === "object") {
      addDefaultProps(defaultProps2[key], result);
    }
  });
  return result;
}
var _excluded$r = ["className", "cssModule", "noGutters", "tag", "widths"];
function _extends$s() {
  _extends$s = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$s.apply(this, arguments);
}
function _objectWithoutProperties$r(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$r(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$r(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var rowColWidths = ["xs", "sm", "md", "lg", "xl", "xxl"];
var rowColsPropType = PropTypes.oneOfType([PropTypes.number, PropTypes.string]);
var propTypes$t = {
  tag: tagPropType,
  noGutters: deprecated(PropTypes.bool, "Please use Bootstrap 5 gutter utility classes. https://getbootstrap.com/docs/5.0/layout/gutters/"),
  className: PropTypes.string,
  cssModule: PropTypes.object,
  xs: rowColsPropType,
  sm: rowColsPropType,
  md: rowColsPropType,
  lg: rowColsPropType,
  xl: rowColsPropType,
  xxl: rowColsPropType,
  widths: PropTypes.array
};
function Row(props) {
  var className = props.className, cssModule = props.cssModule, noGutters = props.noGutters, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, _props$widths = props.widths, widths = _props$widths === void 0 ? rowColWidths : _props$widths, attributes = _objectWithoutProperties$r(props, _excluded$r);
  var colClasses = [];
  widths.forEach(function(colWidth, i2) {
    var colSize = props[colWidth];
    delete attributes[colWidth];
    if (!colSize) {
      return;
    }
    var isXs = !i2;
    colClasses.push(isXs ? "row-cols-".concat(colSize) : "row-cols-".concat(colWidth, "-").concat(colSize));
  });
  var classes = mapToCssModules(classnames(className, noGutters ? "gx-0" : null, "row", colClasses), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$s({}, attributes, {
    className: classes
  }));
}
Row.propTypes = propTypes$t;
var _excluded$q = ["className", "cssModule", "widths", "tag"];
function _extends$r() {
  _extends$r = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$r.apply(this, arguments);
}
function _objectWithoutProperties$q(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$q(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$q(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _defineProperty$a(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var colWidths$1 = ["xs", "sm", "md", "lg", "xl", "xxl"];
var stringOrNumberProp$1 = PropTypes.oneOfType([PropTypes.number, PropTypes.string]);
var columnProps$1 = PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.string, PropTypes.shape({
  size: PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.string]),
  order: stringOrNumberProp$1,
  offset: stringOrNumberProp$1
})]);
var propTypes$s = {
  tag: tagPropType,
  xs: columnProps$1,
  sm: columnProps$1,
  md: columnProps$1,
  lg: columnProps$1,
  xl: columnProps$1,
  xxl: columnProps$1,
  className: PropTypes.string,
  cssModule: PropTypes.object,
  widths: PropTypes.array
};
var getColumnSizeClass$1 = function getColumnSizeClass(isXs, colWidth, colSize) {
  if (colSize === true || colSize === "") {
    return isXs ? "col" : "col-".concat(colWidth);
  }
  if (colSize === "auto") {
    return isXs ? "col-auto" : "col-".concat(colWidth, "-auto");
  }
  return isXs ? "col-".concat(colSize) : "col-".concat(colWidth, "-").concat(colSize);
};
var getColumnClasses = function getColumnClasses2(attributes, cssModule) {
  var widths = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : colWidths$1;
  var modifiedAttributes = attributes;
  var colClasses = [];
  widths.forEach(function(colWidth, i2) {
    var columnProp = modifiedAttributes[colWidth];
    delete modifiedAttributes[colWidth];
    if (!columnProp && columnProp !== "") {
      return;
    }
    var isXs = !i2;
    if (isObject(columnProp)) {
      var _classNames;
      var colSizeInterfix = isXs ? "-" : "-".concat(colWidth, "-");
      var colClass = getColumnSizeClass$1(isXs, colWidth, columnProp.size);
      colClasses.push(mapToCssModules(classnames((_classNames = {}, _defineProperty$a(_classNames, colClass, columnProp.size || columnProp.size === ""), _defineProperty$a(_classNames, "order".concat(colSizeInterfix).concat(columnProp.order), columnProp.order || columnProp.order === 0), _defineProperty$a(_classNames, "offset".concat(colSizeInterfix).concat(columnProp.offset), columnProp.offset || columnProp.offset === 0), _classNames)), cssModule));
    } else {
      var _colClass = getColumnSizeClass$1(isXs, colWidth, columnProp);
      colClasses.push(_colClass);
    }
  });
  return {
    colClasses,
    modifiedAttributes
  };
};
function Col(props) {
  var className = props.className, cssModule = props.cssModule, _props$widths = props.widths, widths = _props$widths === void 0 ? colWidths$1 : _props$widths, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, attributes = _objectWithoutProperties$q(props, _excluded$q);
  var _getColumnClasses = getColumnClasses(attributes, cssModule, widths), modifiedAttributes = _getColumnClasses.modifiedAttributes, colClasses = _getColumnClasses.colClasses;
  if (!colClasses.length) {
    colClasses.push("col");
  }
  var classes = mapToCssModules(classnames(className, colClasses), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$r({}, modifiedAttributes, {
    className: classes
  }));
}
Col.propTypes = propTypes$s;
var _excluded$p = ["className", "listClassName", "cssModule", "children", "tag", "listTag", "aria-label"];
function _extends$q() {
  _extends$q = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$q.apply(this, arguments);
}
function _objectWithoutProperties$p(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$p(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$p(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$r = {
  /** Aria label */
  "aria-label": PropTypes.string,
  /** Pass children so this component can wrap them */
  children: PropTypes.node,
  /** Add custom class */
  className: PropTypes.string,
  /** Change existing className with a new className */
  cssModule: PropTypes.object,
  /** Add custom class to list tag */
  listClassName: PropTypes.string,
  /** Set a custom element for list tag */
  listTag: tagPropType,
  /** Set a custom element for this component */
  tag: tagPropType
};
function Breadcrumb$1(props) {
  var className = props.className, listClassName = props.listClassName, cssModule = props.cssModule, children = props.children, _props$tag = props.tag, Tag = _props$tag === void 0 ? "nav" : _props$tag, _props$listTag = props.listTag, ListTag = _props$listTag === void 0 ? "ol" : _props$listTag, _props$ariaLabel = props["aria-label"], label = _props$ariaLabel === void 0 ? "breadcrumb" : _props$ariaLabel, attributes = _objectWithoutProperties$p(props, _excluded$p);
  var classes = mapToCssModules(classnames(className), cssModule);
  var listClasses = mapToCssModules(classnames("breadcrumb", listClassName), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$q({}, attributes, {
    className: classes,
    "aria-label": label
  }), /* @__PURE__ */ React$1.createElement(ListTag, {
    className: listClasses
  }, children));
}
Breadcrumb$1.propTypes = propTypes$r;
var _excluded$o = ["className", "cssModule", "active", "tag"];
function _extends$p() {
  _extends$p = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$p.apply(this, arguments);
}
function _objectWithoutProperties$o(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$o(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$o(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$q = {
  /** Adds a visual "active" state to a Breadcrumb Item */
  active: PropTypes.bool,
  /** Add custom class to the element */
  className: PropTypes.string,
  /** Change existing className with a new className */
  cssModule: PropTypes.object,
  /** Set a custom element for this component */
  tag: tagPropType
};
function BreadcrumbItem(props) {
  var className = props.className, cssModule = props.cssModule, active = props.active, _props$tag = props.tag, Tag = _props$tag === void 0 ? "li" : _props$tag, attributes = _objectWithoutProperties$o(props, _excluded$o);
  var classes = mapToCssModules(classnames(className, active ? "active" : false, "breadcrumb-item"), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$p({}, attributes, {
    className: classes,
    "aria-current": active ? "page" : void 0
  }));
}
BreadcrumbItem.propTypes = propTypes$q;
var _excluded$n = ["className", "cssModule", "variant", "innerRef"];
function _extends$o() {
  _extends$o = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$o.apply(this, arguments);
}
function ownKeys$5(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
      _defineProperty$9(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$n(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$n(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$n(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$p = {
  /** Disable the button if needed */
  active: PropTypes.bool,
  /** Aria label */
  "aria-label": PropTypes.string,
  /** Function to be triggered on click */
  onClick: PropTypes.func,
  /** Change the variant to white */
  variant: PropTypes.oneOf(["white"]),
  className: PropTypes.string,
  cssModule: PropTypes.object,
  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func])
};
function CloseButton(props) {
  var className = props.className;
  props.cssModule;
  var variant = props.variant, innerRef = props.innerRef, attributes = _objectWithoutProperties$n(props, _excluded$n);
  var classes = mapToCssModules(classnames(className, "btn-close", variant && "btn-close-".concat(variant)));
  return /* @__PURE__ */ React$1.createElement("button", _extends$o({
    ref: innerRef,
    type: "button",
    className: classes
  }, _objectSpread$5({
    "aria-label": "close"
  }, attributes)));
}
CloseButton.propTypes = propTypes$p;
var _excluded$m = ["active", "aria-label", "block", "className", "close", "cssModule", "color", "outline", "size", "tag", "innerRef"];
function _extends$n() {
  _extends$n = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$n.apply(this, arguments);
}
function _objectWithoutProperties$m(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$m(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$m(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$o = {
  /** Manually set the visual state of the button to active */
  active: PropTypes.bool,
  /** Aria label */
  "aria-label": PropTypes.string,
  block: PropTypes.bool,
  /** Pass children so this component can wrap them */
  children: PropTypes.node,
  /** Add custom class */
  className: PropTypes.string,
  /** Change existing className with a new className */
  cssModule: PropTypes.object,
  /** Use the button as a close button */
  close: PropTypes.bool,
  /** Change color of Button to one of the available colors */
  color: PropTypes.string,
  /** Disables the button */
  disabled: PropTypes.bool,
  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func, PropTypes.string]),
  /** Function to be triggered on click */
  onClick: PropTypes.func,
  /** Adds outline to the button */
  outline: PropTypes.bool,
  /** Make the button bigger or smaller */
  size: PropTypes.string,
  /** Set a custom element for this component */
  tag: tagPropType
};
function Button$1(props) {
  var onClick = reactExports.useCallback(function(e2) {
    if (props.disabled) {
      e2.preventDefault();
      return;
    }
    if (props.onClick) {
      return props.onClick(e2);
    }
  }, [props.onClick, props.disabled]);
  var active = props.active, ariaLabel = props["aria-label"], block = props.block, className = props.className, close2 = props.close, cssModule = props.cssModule, _props$color = props.color, color = _props$color === void 0 ? "secondary" : _props$color, outline = props.outline, size = props.size, _props$tag = props.tag, Tag = _props$tag === void 0 ? "button" : _props$tag, innerRef = props.innerRef, attributes = _objectWithoutProperties$m(props, _excluded$m);
  if (close2) {
    return /* @__PURE__ */ React$1.createElement(CloseButton, attributes);
  }
  var btnOutlineColor = "btn".concat(outline ? "-outline" : "", "-").concat(color);
  var classes = mapToCssModules(classnames(className, "btn", btnOutlineColor, size ? "btn-".concat(size) : false, block ? "d-block w-100" : false, {
    active,
    disabled: props.disabled
  }), cssModule);
  if (attributes.href && Tag === "button") {
    Tag = "a";
  }
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$n({
    type: Tag === "button" && attributes.onClick ? "button" : void 0
  }, attributes, {
    className: classes,
    ref: innerRef,
    onClick,
    "aria-label": ariaLabel
  }));
}
Button$1.propTypes = propTypes$o;
var ManagerReferenceNodeContext = reactExports.createContext();
var ManagerReferenceNodeSetterContext = reactExports.createContext();
function Manager(_ref) {
  var children = _ref.children;
  var _React$useState = reactExports.useState(null), referenceNode = _React$useState[0], setReferenceNode = _React$useState[1];
  var hasUnmounted = reactExports.useRef(false);
  reactExports.useEffect(function() {
    return function() {
      hasUnmounted.current = true;
    };
  }, []);
  var handleSetReferenceNode = reactExports.useCallback(function(node) {
    if (!hasUnmounted.current) {
      setReferenceNode(node);
    }
  }, []);
  return /* @__PURE__ */ reactExports.createElement(ManagerReferenceNodeContext.Provider, {
    value: referenceNode
  }, /* @__PURE__ */ reactExports.createElement(ManagerReferenceNodeSetterContext.Provider, {
    value: handleSetReferenceNode
  }, children));
}
var unwrapArray = function unwrapArray2(arg) {
  return Array.isArray(arg) ? arg[0] : arg;
};
var safeInvoke = function safeInvoke2(fn) {
  if (typeof fn === "function") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return fn.apply(void 0, args);
  }
};
var setRef = function setRef2(ref, node) {
  if (typeof ref === "function") {
    return safeInvoke(ref, node);
  } else if (ref != null) {
    ref.current = node;
  }
};
var fromEntries = function fromEntries2(entries) {
  return entries.reduce(function(acc, _ref) {
    var key = _ref[0], value = _ref[1];
    acc[key] = value;
    return acc;
  }, {});
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? reactExports.useLayoutEffect : reactExports.useEffect;
var reactFastCompare;
var hasRequiredReactFastCompare;
function requireReactFastCompare() {
  if (hasRequiredReactFastCompare) return reactFastCompare;
  hasRequiredReactFastCompare = 1;
  var hasElementType = typeof Element !== "undefined";
  var hasMap = typeof Map === "function";
  var hasSet = typeof Set === "function";
  var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
  function equal(a2, b2) {
    if (a2 === b2) return true;
    if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
      if (a2.constructor !== b2.constructor) return false;
      var length, i2, keys;
      if (Array.isArray(a2)) {
        length = a2.length;
        if (length != b2.length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!equal(a2[i2], b2[i2])) return false;
        return true;
      }
      var it;
      if (hasMap && a2 instanceof Map && b2 instanceof Map) {
        if (a2.size !== b2.size) return false;
        it = a2.entries();
        while (!(i2 = it.next()).done)
          if (!b2.has(i2.value[0])) return false;
        it = a2.entries();
        while (!(i2 = it.next()).done)
          if (!equal(i2.value[1], b2.get(i2.value[0]))) return false;
        return true;
      }
      if (hasSet && a2 instanceof Set && b2 instanceof Set) {
        if (a2.size !== b2.size) return false;
        it = a2.entries();
        while (!(i2 = it.next()).done)
          if (!b2.has(i2.value[0])) return false;
        return true;
      }
      if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
        length = a2.length;
        if (length != b2.length) return false;
        for (i2 = length; i2-- !== 0; )
          if (a2[i2] !== b2[i2]) return false;
        return true;
      }
      if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
      if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b2.valueOf === "function") return a2.valueOf() === b2.valueOf();
      if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b2.toString === "function") return a2.toString() === b2.toString();
      keys = Object.keys(a2);
      length = keys.length;
      if (length !== Object.keys(b2).length) return false;
      for (i2 = length; i2-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) return false;
      if (hasElementType && a2 instanceof Element) return false;
      for (i2 = length; i2-- !== 0; ) {
        if ((keys[i2] === "_owner" || keys[i2] === "__v" || keys[i2] === "__o") && a2.$$typeof) {
          continue;
        }
        if (!equal(a2[keys[i2]], b2[keys[i2]])) return false;
      }
      return true;
    }
    return a2 !== a2 && b2 !== b2;
  }
  reactFastCompare = function isEqual2(a2, b2) {
    try {
      return equal(a2, b2);
    } catch (error2) {
      if ((error2.message || "").match(/stack|recursion/i)) {
        console.warn("react-fast-compare cannot handle circular refs");
        return false;
      }
      throw error2;
    }
  };
  return reactFastCompare;
}
var reactFastCompareExports = requireReactFastCompare();
const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompareExports);
var EMPTY_MODIFIERS$1 = [];
var usePopper = function usePopper2(referenceElement, popperElement, options) {
  if (options === void 0) {
    options = {};
  }
  var prevOptions = reactExports.useRef(null);
  var optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS$1
  };
  var _React$useState = reactExports.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), state = _React$useState[0], setState = _React$useState[1];
  var updateStateModifier = reactExports.useMemo(function() {
    return {
      name: "updateState",
      enabled: true,
      phase: "write",
      fn: function fn(_ref) {
        var state2 = _ref.state;
        var elements = Object.keys(state2.elements);
        reactDomExports.flushSync(function() {
          setState({
            styles: fromEntries(elements.map(function(element) {
              return [element, state2.styles[element] || {}];
            })),
            attributes: fromEntries(elements.map(function(element) {
              return [element, state2.attributes[element]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []);
  var popperOptions = reactExports.useMemo(function() {
    var newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
        name: "applyStyles",
        enabled: false
      }])
    };
    if (isEqual(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
  var popperInstanceRef = reactExports.useRef();
  useIsomorphicLayoutEffect(function() {
    if (popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(function() {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    var createPopper$1 = options.createPopper || createPopper;
    var popperInstance = createPopper$1(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return function() {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};
var NOOP = function NOOP2() {
  return void 0;
};
var NOOP_PROMISE = function NOOP_PROMISE2() {
  return Promise.resolve(null);
};
var EMPTY_MODIFIERS = [];
function Popper(_ref) {
  var _ref$placement = _ref.placement, placement = _ref$placement === void 0 ? "bottom" : _ref$placement, _ref$strategy = _ref.strategy, strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy, _ref$modifiers = _ref.modifiers, modifiers = _ref$modifiers === void 0 ? EMPTY_MODIFIERS : _ref$modifiers, referenceElement = _ref.referenceElement, onFirstUpdate = _ref.onFirstUpdate, innerRef = _ref.innerRef, children = _ref.children;
  var referenceNode = reactExports.useContext(ManagerReferenceNodeContext);
  var _React$useState = reactExports.useState(null), popperElement = _React$useState[0], setPopperElement = _React$useState[1];
  var _React$useState2 = reactExports.useState(null), arrowElement = _React$useState2[0], setArrowElement = _React$useState2[1];
  reactExports.useEffect(function() {
    setRef(innerRef, popperElement);
  }, [innerRef, popperElement]);
  var options = reactExports.useMemo(function() {
    return {
      placement,
      strategy,
      onFirstUpdate,
      modifiers: [].concat(modifiers, [{
        name: "arrow",
        enabled: arrowElement != null,
        options: {
          element: arrowElement
        }
      }])
    };
  }, [placement, strategy, onFirstUpdate, modifiers, arrowElement]);
  var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options), state = _usePopper.state, styles = _usePopper.styles, forceUpdate = _usePopper.forceUpdate, update2 = _usePopper.update;
  var childrenProps = reactExports.useMemo(function() {
    return {
      ref: setPopperElement,
      style: styles.popper,
      placement: state ? state.placement : placement,
      hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
      isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
      arrowProps: {
        style: styles.arrow,
        ref: setArrowElement
      },
      forceUpdate: forceUpdate || NOOP,
      update: update2 || NOOP_PROMISE
    };
  }, [setPopperElement, setArrowElement, placement, state, styles, update2, forceUpdate]);
  return unwrapArray(children)(childrenProps);
}
var warning_1;
var hasRequiredWarning;
function requireWarning() {
  if (hasRequiredWarning) return warning_1;
  hasRequiredWarning = 1;
  var warning2 = function() {
  };
  warning_1 = warning2;
  return warning_1;
}
var warningExports = requireWarning();
const warning = /* @__PURE__ */ getDefaultExportFromCjs(warningExports);
function Reference(_ref) {
  var children = _ref.children, innerRef = _ref.innerRef;
  var setReferenceNode = reactExports.useContext(ManagerReferenceNodeSetterContext);
  var refHandler = reactExports.useCallback(function(node) {
    setRef(innerRef, node);
    safeInvoke(setReferenceNode, node);
  }, [innerRef, setReferenceNode]);
  reactExports.useEffect(function() {
    return function() {
      return setRef(innerRef, null);
    };
  }, []);
  reactExports.useEffect(function() {
    warning(Boolean(setReferenceNode), "`Reference` should not be used outside of a `Manager` component.");
  }, [setReferenceNode]);
  return unwrapArray(children)({
    ref: refHandler
  });
}
var DropdownContext = /* @__PURE__ */ React$1.createContext({});
var InputGroupContext = /* @__PURE__ */ React$1.createContext({});
function _typeof$6(obj) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$6(obj);
}
var _excluded$l = ["className", "cssModule", "direction", "isOpen", "group", "size", "nav", "setActiveFromChild", "active", "tag", "menuRole"];
function _extends$m() {
  _extends$m = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$m.apply(this, arguments);
}
function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$l(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$l(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$l(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o2, p2) {
  _setPrototypeOf$6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$6(o2, p2);
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$6(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$6(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$6(this, result);
  };
}
function _possibleConstructorReturn$6(self2, call) {
  if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$6(self2);
}
function _assertThisInitialized$6(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$6(o2) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$6(o2);
}
var propTypes$n = {
  a11y: PropTypes.bool,
  disabled: PropTypes.bool,
  direction: PropTypes.oneOf(["up", "down", "start", "end", "left", "right"]),
  group: PropTypes.bool,
  isOpen: PropTypes.bool,
  nav: PropTypes.bool,
  active: PropTypes.bool,
  size: PropTypes.string,
  tag: tagPropType,
  toggle: PropTypes.func,
  children: PropTypes.node,
  className: PropTypes.string,
  cssModule: PropTypes.object,
  dropup: PropTypes.bool,
  inNavbar: PropTypes.bool,
  setActiveFromChild: PropTypes.bool,
  menuRole: PropTypes.oneOf(["listbox", "menu"])
};
var defaultProps$3 = {
  a11y: true,
  isOpen: false,
  direction: "down",
  nav: false,
  active: false,
  inNavbar: false,
  setActiveFromChild: false
};
var preventDefaultKeys = [keyCodes.space, keyCodes.enter, keyCodes.up, keyCodes.down, keyCodes.end, keyCodes.home];
var Dropdown$1 = /* @__PURE__ */ (function(_React$Component) {
  _inherits$6(Dropdown2, _React$Component);
  var _super = _createSuper$6(Dropdown2);
  function Dropdown2(props) {
    var _this;
    _classCallCheck$6(this, Dropdown2);
    _this = _super.call(this, props);
    _this.addEvents = _this.addEvents.bind(_assertThisInitialized$6(_this));
    _this.handleDocumentClick = _this.handleDocumentClick.bind(_assertThisInitialized$6(_this));
    _this.handleKeyDown = _this.handleKeyDown.bind(_assertThisInitialized$6(_this));
    _this.removeEvents = _this.removeEvents.bind(_assertThisInitialized$6(_this));
    _this.toggle = _this.toggle.bind(_assertThisInitialized$6(_this));
    _this.handleMenuRef = _this.handleMenuRef.bind(_assertThisInitialized$6(_this));
    _this.handleToggleRef = _this.handleToggleRef.bind(_assertThisInitialized$6(_this));
    _this.containerRef = /* @__PURE__ */ React$1.createRef();
    _this.menuRef = /* @__PURE__ */ React$1.createRef();
    _this.toggleRef = /* @__PURE__ */ React$1.createRef();
    return _this;
  }
  _createClass$6(Dropdown2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.handleProps();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.isOpen !== prevProps.isOpen) {
        this.handleProps();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeEvents();
    }
  }, {
    key: "handleMenuRef",
    value: function handleMenuRef(menuRef) {
      this.menuRef.current = menuRef;
    }
  }, {
    key: "handleToggleRef",
    value: function handleToggleRef(toggleRef) {
      this.toggleRef.current = toggleRef;
    }
  }, {
    key: "handleDocumentClick",
    value: function handleDocumentClick(e2) {
      if (e2 && (e2.which === 3 || e2.type === "keyup" && e2.which !== keyCodes.tab)) return;
      var container = this.getContainer();
      var menu = this.getMenu();
      var toggle2 = this.getToggle();
      if (!toggle2) {
        return;
      }
      var targetIsToggle = toggle2.contains(e2.target);
      var clickIsInMenu = menu && menu.contains(e2.target) && menu !== e2.target;
      var clickIsInInput = false;
      if (container) {
        clickIsInInput = container.classList.contains("input-group") && container.classList.contains("dropdown") && e2.target.tagName === "INPUT";
      }
      if ((targetIsToggle && !clickIsInInput || clickIsInMenu) && (e2.type !== "keyup" || e2.which === keyCodes.tab)) {
        return;
      }
      this.toggle(e2);
    }
  }, {
    key: "handleKeyDown",
    value: function handleKeyDown(e2) {
      var _this2 = this;
      var isTargetMenuItem = e2.target.getAttribute("role") === "menuitem" || e2.target.getAttribute("role") === "option";
      var isTargetMenuCtrl = this.getMenuCtrl() === e2.target;
      var isTab = keyCodes.tab === e2.which;
      if (/input|textarea/i.test(e2.target.tagName) || isTab && !this.props.a11y || isTab && !(isTargetMenuItem || isTargetMenuCtrl)) {
        return;
      }
      if (preventDefaultKeys.indexOf(e2.which) !== -1 || e2.which >= 48 && e2.which <= 90) {
        e2.preventDefault();
      }
      if (this.props.disabled) return;
      if (isTargetMenuCtrl) {
        if ([keyCodes.space, keyCodes.enter, keyCodes.up, keyCodes.down].indexOf(e2.which) > -1) {
          if (!this.props.isOpen) {
            this.toggle(e2);
          }
          setTimeout(function() {
            var _this2$getMenuItems$;
            return (_this2$getMenuItems$ = _this2.getMenuItems()[0]) === null || _this2$getMenuItems$ === void 0 ? void 0 : _this2$getMenuItems$.focus();
          });
        } else if (this.props.isOpen && isTab) {
          var _this$getMenuItems$;
          e2.preventDefault();
          (_this$getMenuItems$ = this.getMenuItems()[0]) === null || _this$getMenuItems$ === void 0 ? void 0 : _this$getMenuItems$.focus();
        } else if (this.props.isOpen && e2.which === keyCodes.esc) {
          this.toggle(e2);
        }
      }
      if (this.props.isOpen && isTargetMenuItem) {
        if ([keyCodes.tab, keyCodes.esc].indexOf(e2.which) > -1) {
          this.toggle(e2);
          this.getMenuCtrl().focus();
        } else if ([keyCodes.space, keyCodes.enter].indexOf(e2.which) > -1) {
          e2.target.click();
          this.getMenuCtrl().focus();
        } else if ([keyCodes.down, keyCodes.up].indexOf(e2.which) > -1 || [keyCodes.n, keyCodes.p].indexOf(e2.which) > -1 && e2.ctrlKey) {
          var $menuitems = this.getMenuItems();
          var index2 = $menuitems.indexOf(e2.target);
          if (keyCodes.up === e2.which || keyCodes.p === e2.which && e2.ctrlKey) {
            index2 = index2 !== 0 ? index2 - 1 : $menuitems.length - 1;
          } else if (keyCodes.down === e2.which || keyCodes.n === e2.which && e2.ctrlKey) {
            index2 = index2 === $menuitems.length - 1 ? 0 : index2 + 1;
          }
          $menuitems[index2].focus();
        } else if (keyCodes.end === e2.which) {
          var _$menuitems = this.getMenuItems();
          _$menuitems[_$menuitems.length - 1].focus();
        } else if (keyCodes.home === e2.which) {
          var _$menuitems2 = this.getMenuItems();
          _$menuitems2[0].focus();
        } else if (e2.which >= 48 && e2.which <= 90) {
          var _$menuitems3 = this.getMenuItems();
          var charPressed = String.fromCharCode(e2.which).toLowerCase();
          for (var i2 = 0; i2 < _$menuitems3.length; i2 += 1) {
            var firstLetter = _$menuitems3[i2].textContent && _$menuitems3[i2].textContent[0].toLowerCase();
            if (firstLetter === charPressed) {
              _$menuitems3[i2].focus();
              break;
            }
          }
        }
      }
    }
  }, {
    key: "handleProps",
    value: function handleProps() {
      if (this.props.isOpen) {
        this.addEvents();
      } else {
        this.removeEvents();
      }
    }
  }, {
    key: "getContextValue",
    value: function getContextValue() {
      return {
        toggle: this.toggle,
        isOpen: this.props.isOpen,
        direction: this.props.direction === "down" && this.props.dropup ? "up" : this.props.direction,
        inNavbar: this.props.inNavbar,
        disabled: this.props.disabled,
        // Callback that should be called by DropdownMenu to provide a ref to
        // a HTML tag that's used for the DropdownMenu
        onMenuRef: this.handleMenuRef,
        onToggleRef: this.handleToggleRef,
        menuRole: this.props.menuRole
      };
    }
  }, {
    key: "getContainer",
    value: function getContainer2() {
      return this.containerRef.current;
    }
  }, {
    key: "getMenu",
    value: function getMenu() {
      return this.menuRef.current;
    }
  }, {
    key: "getToggle",
    value: function getToggle() {
      return this.toggleRef.current;
    }
  }, {
    key: "getMenuCtrl",
    value: function getMenuCtrl() {
      if (this._$menuCtrl) return this._$menuCtrl;
      this._$menuCtrl = this.getToggle();
      return this._$menuCtrl;
    }
  }, {
    key: "getItemType",
    value: function getItemType() {
      if (this.props.menuRole === "listbox") {
        return "option";
      }
      return "menuitem";
    }
  }, {
    key: "getMenuItems",
    value: function getMenuItems() {
      var menuContainer = this.getMenu() || this.getContainer();
      return [].slice.call(menuContainer.querySelectorAll('[role="'.concat(this.getItemType(), '"]')));
    }
  }, {
    key: "addEvents",
    value: function addEvents() {
      var _this3 = this;
      ["click", "touchstart", "keyup"].forEach(function(event) {
        return document.addEventListener(event, _this3.handleDocumentClick, true);
      });
    }
  }, {
    key: "removeEvents",
    value: function removeEvents() {
      var _this4 = this;
      ["click", "touchstart", "keyup"].forEach(function(event) {
        return document.removeEventListener(event, _this4.handleDocumentClick, true);
      });
    }
  }, {
    key: "toggle",
    value: function toggle2(e2) {
      if (this.props.disabled) {
        return e2 && e2.preventDefault();
      }
      return this.props.toggle(e2);
    }
  }, {
    key: "render",
    value: function render2() {
      var _classNames, _this5 = this;
      var _omit = omit(this.props, ["toggle", "disabled", "inNavbar", "a11y"]), className = _omit.className, cssModule = _omit.cssModule, direction = _omit.direction, isOpen = _omit.isOpen, group = _omit.group, size = _omit.size, nav = _omit.nav, setActiveFromChild = _omit.setActiveFromChild, active = _omit.active, tag = _omit.tag;
      _omit.menuRole;
      var attrs = _objectWithoutProperties$l(_omit, _excluded$l);
      var Tag = tag || (nav ? "li" : "div");
      var subItemIsActive = false;
      if (setActiveFromChild) {
        React$1.Children.map(this.props.children[1].props.children, function(dropdownItem) {
          if (dropdownItem && dropdownItem.props.active) subItemIsActive = true;
        });
      }
      var classes = mapToCssModules(classnames(className, nav && active ? "active" : false, setActiveFromChild && subItemIsActive ? "active" : false, (_classNames = {
        "btn-group": group
      }, _defineProperty$8(_classNames, "btn-group-".concat(size), !!size), _defineProperty$8(_classNames, "dropdown", !group), _defineProperty$8(_classNames, "dropup", direction === "up"), _defineProperty$8(_classNames, "dropstart", direction === "start" || direction === "left"), _defineProperty$8(_classNames, "dropend", direction === "end" || direction === "right"), _defineProperty$8(_classNames, "show", isOpen), _defineProperty$8(_classNames, "nav-item", nav), _classNames)), cssModule);
      if (this.context.insideInputGroup) {
        return /* @__PURE__ */ React$1.createElement(DropdownContext.Provider, {
          value: this.getContextValue()
        }, /* @__PURE__ */ React$1.createElement(Manager, null, React$1.Children.map(this.props.children, function(child) {
          return /* @__PURE__ */ React$1.cloneElement(child, {
            onKeyDown: _this5.handleKeyDown
          });
        })));
      }
      return /* @__PURE__ */ React$1.createElement(DropdownContext.Provider, {
        value: this.getContextValue()
      }, /* @__PURE__ */ React$1.createElement(Manager, null, /* @__PURE__ */ React$1.createElement(Tag, _extends$m({}, attrs, _defineProperty$8({}, typeof Tag === "string" ? "ref" : "innerRef", this.containerRef), {
        onKeyDown: this.handleKeyDown,
        className: classes
      }))));
    }
  }]);
  return Dropdown2;
})(React$1.Component);
Dropdown$1.propTypes = propTypes$n;
Dropdown$1.defaultProps = defaultProps$3;
Dropdown$1.contextType = InputGroupContext;
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$5(obj);
}
var _excluded$k = ["className", "cssModule", "dark", "end", "right", "tag", "flip", "modifiers", "persist", "strategy", "container", "updateOnSelect"];
function _extends$l() {
  _extends$l = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$l.apply(this, arguments);
}
function ownKeys$4(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
      _defineProperty$7(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _objectWithoutProperties$k(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$k(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$k(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o2, p2) {
  _setPrototypeOf$5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$5(o2, p2);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
function _possibleConstructorReturn$5(self2, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$5(self2);
}
function _assertThisInitialized$5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$5(o2) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$5(o2);
}
var propTypes$m = {
  tag: tagPropType,
  children: PropTypes.node.isRequired,
  dark: PropTypes.bool,
  end: PropTypes.bool,
  /** Flips the menu to the opposite side if there is not enough space to fit */
  flip: PropTypes.bool,
  modifiers: PropTypes.array,
  className: PropTypes.string,
  cssModule: PropTypes.object,
  style: PropTypes.object,
  persist: PropTypes.bool,
  strategy: PropTypes.string,
  container: targetPropType,
  /** Update popper layout when a click event comes up. This leverages event bubbling. */
  updateOnSelect: PropTypes.bool,
  right: deprecated(PropTypes.bool, 'Please use "end" instead.')
};
var directionPositionMap = {
  up: "top",
  left: "left",
  right: "right",
  start: "left",
  end: "right",
  down: "bottom"
};
var DropdownMenu = /* @__PURE__ */ (function(_React$Component) {
  _inherits$5(DropdownMenu2, _React$Component);
  var _super = _createSuper$5(DropdownMenu2);
  function DropdownMenu2() {
    _classCallCheck$5(this, DropdownMenu2);
    return _super.apply(this, arguments);
  }
  _createClass$5(DropdownMenu2, [{
    key: "getRole",
    value: function getRole() {
      if (this.context.menuRole === "listbox") {
        return "listbox";
      }
      return "menu";
    }
  }, {
    key: "render",
    value: function render2() {
      var _this = this;
      var _this$props = this.props, className = _this$props.className, cssModule = _this$props.cssModule, dark = _this$props.dark, end = _this$props.end, right = _this$props.right, _this$props$tag = _this$props.tag, tag = _this$props$tag === void 0 ? "div" : _this$props$tag, _this$props$flip = _this$props.flip, flip = _this$props$flip === void 0 ? true : _this$props$flip, _this$props$modifiers = _this$props.modifiers, modifiers = _this$props$modifiers === void 0 ? [] : _this$props$modifiers, persist = _this$props.persist, strategy = _this$props.strategy, container = _this$props.container, updateOnSelect = _this$props.updateOnSelect, attrs = _objectWithoutProperties$k(_this$props, _excluded$k);
      var classes = mapToCssModules(classnames(className, "dropdown-menu", {
        "dropdown-menu-dark": dark,
        "dropdown-menu-end": end || right,
        show: this.context.isOpen
      }), cssModule);
      var Tag = tag;
      if (persist || this.context.isOpen && !this.context.inNavbar) {
        var position1 = directionPositionMap[this.context.direction] || "bottom";
        var position2 = end || right ? "end" : "start";
        var poperPlacement = "".concat(position1, "-").concat(position2);
        var poperModifiers = [].concat(_toConsumableArray(modifiers), [{
          name: "flip",
          enabled: !!flip
        }]);
        var persistStyles = {};
        if (persist) {
          persistStyles.display = "block";
          persistStyles.visibility = this.context.isOpen ? "visible" : "hidden";
        }
        var popper = /* @__PURE__ */ React$1.createElement(Popper, {
          placement: poperPlacement,
          modifiers: poperModifiers,
          strategy
        }, function(_ref) {
          var ref = _ref.ref, style = _ref.style, placement = _ref.placement, update2 = _ref.update;
          var combinedStyle = _objectSpread$4(_objectSpread$4(_objectSpread$4({}, _this.props.style), persistStyles), style);
          var handleRef = function handleRef2(tagRef) {
            ref(tagRef);
            var onMenuRef2 = _this.context.onMenuRef;
            if (onMenuRef2) onMenuRef2(tagRef);
          };
          return /* @__PURE__ */ React$1.createElement(Tag, _extends$l({
            tabIndex: "-1",
            role: _this.getRole(),
            ref: handleRef
          }, attrs, {
            style: combinedStyle,
            "aria-hidden": !_this.context.isOpen,
            className: classes,
            "data-popper-placement": placement,
            onClick: function onClick() {
              return updateOnSelect && update2();
            }
          }));
        });
        if (container) {
          return /* @__PURE__ */ ReactDOM$1.createPortal(popper, getTarget(container));
        }
        return popper;
      }
      var onMenuRef = this.context.onMenuRef;
      return /* @__PURE__ */ React$1.createElement(Tag, _extends$l({
        tabIndex: "-1",
        role: this.getRole()
      }, attrs, {
        ref: onMenuRef,
        "aria-hidden": !this.context.isOpen,
        className: classes,
        "data-popper-placement": attrs.placement,
        "data-bs-popper": "static"
      }));
    }
  }]);
  return DropdownMenu2;
})(React$1.Component);
DropdownMenu.propTypes = propTypes$m;
DropdownMenu.contextType = DropdownContext;
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$4(obj);
}
var _excluded$j = ["className", "color", "cssModule", "caret", "split", "nav", "tag", "innerRef"];
function _extends$k() {
  _extends$k = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$k.apply(this, arguments);
}
function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$j(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$j(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$j(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o2, p2) {
  _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$4(o2, p2);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self2, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$4(self2);
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$4(o2) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$4(o2);
}
var propTypes$l = {
  caret: PropTypes.bool,
  color: PropTypes.string,
  children: PropTypes.node,
  className: PropTypes.string,
  cssModule: PropTypes.object,
  disabled: PropTypes.bool,
  onClick: PropTypes.func,
  "aria-haspopup": PropTypes.bool,
  split: PropTypes.bool,
  tag: tagPropType,
  nav: PropTypes.bool,
  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func])
};
var defaultProps$2 = {
  color: "secondary",
  "aria-haspopup": true
};
var DropdownToggle = /* @__PURE__ */ (function(_React$Component) {
  _inherits$4(DropdownToggle2, _React$Component);
  var _super = _createSuper$4(DropdownToggle2);
  function DropdownToggle2(props) {
    var _this;
    _classCallCheck$4(this, DropdownToggle2);
    _this = _super.call(this, props);
    _this.onClick = _this.onClick.bind(_assertThisInitialized$4(_this));
    return _this;
  }
  _createClass$4(DropdownToggle2, [{
    key: "onClick",
    value: function onClick(e2) {
      if (this.props.disabled || this.context.disabled) {
        e2.preventDefault();
        return;
      }
      if (this.props.nav && !this.props.tag) {
        e2.preventDefault();
      }
      if (this.props.onClick) {
        this.props.onClick(e2);
      }
      this.context.toggle(e2);
    }
  }, {
    key: "getRole",
    value: function getRole() {
      return this.context.menuRole || this.props["aria-haspopup"];
    }
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      var _this$props = this.props, className = _this$props.className, color = _this$props.color, cssModule = _this$props.cssModule, caret = _this$props.caret, split = _this$props.split, nav = _this$props.nav, tag = _this$props.tag, innerRef = _this$props.innerRef, props = _objectWithoutProperties$j(_this$props, _excluded$j);
      var ariaLabel = props["aria-label"] || "Toggle Dropdown";
      var classes = mapToCssModules(classnames(className, {
        "dropdown-toggle": caret || split,
        "dropdown-toggle-split": split,
        "nav-link": nav
      }), cssModule);
      var children = typeof props.children !== "undefined" ? props.children : /* @__PURE__ */ React$1.createElement("span", {
        className: "visually-hidden"
      }, ariaLabel);
      var Tag;
      if (nav && !tag) {
        Tag = "a";
        props.href = "#";
      } else if (!tag) {
        Tag = Button$1;
        props.color = color;
        props.cssModule = cssModule;
      } else {
        Tag = tag;
      }
      var returnFunction = function returnFunction2(_ref) {
        var ref = _ref.ref;
        var handleRef = function handleRef2(tagRef) {
          ref(tagRef);
          var onToggleRef = _this2.context.onToggleRef;
          if (onToggleRef) onToggleRef(tagRef);
        };
        return /* @__PURE__ */ React$1.createElement(Tag, _extends$k({}, props, _defineProperty$6({}, typeof Tag === "string" ? "ref" : "innerRef", handleRef), {
          className: classes,
          onClick: _this2.onClick,
          "aria-expanded": _this2.context.isOpen,
          "aria-haspopup": _this2.getRole(),
          children
        }));
      };
      if (this.context.inNavbar) {
        return /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, returnFunction({
          ref: this.context.onToggleRef
        }));
      }
      return /* @__PURE__ */ React$1.createElement(Reference, {
        innerRef
      }, returnFunction);
    }
  }]);
  return DropdownToggle2;
})(React$1.Component);
DropdownToggle.propTypes = propTypes$l;
DropdownToggle.defaultProps = defaultProps$2;
DropdownToggle.contextType = DropdownContext;
var _excluded$i = ["tag", "baseClass", "baseClassActive", "className", "cssModule", "children", "innerRef"];
function _extends$j() {
  _extends$j = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$j.apply(this, arguments);
}
function _objectWithoutProperties$i(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$i(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$i(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function ownKeys$3(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty$5(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var propTypes$k = _objectSpread$3(_objectSpread$3({}, Transition.propTypes), {}, {
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),
  tag: tagPropType,
  baseClass: PropTypes.string,
  baseClassActive: PropTypes.string,
  className: PropTypes.string,
  cssModule: PropTypes.object,
  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func])
});
var defaultProps$1 = _objectSpread$3(_objectSpread$3({}, Transition.defaultProps), {}, {
  timeout: TransitionTimeouts.Fade,
  appear: true,
  enter: true,
  exit: true,
  "in": true
});
function Fade(props) {
  var ref = reactExports.useRef(null);
  var _addDefaultProps = addDefaultProps(defaultProps$1, props), _addDefaultProps$tag = _addDefaultProps.tag, Tag = _addDefaultProps$tag === void 0 ? "div" : _addDefaultProps$tag, _addDefaultProps$base = _addDefaultProps.baseClass, baseClass = _addDefaultProps$base === void 0 ? "fade" : _addDefaultProps$base, _addDefaultProps$base2 = _addDefaultProps.baseClassActive, baseClassActive = _addDefaultProps$base2 === void 0 ? "show" : _addDefaultProps$base2, className = _addDefaultProps.className, cssModule = _addDefaultProps.cssModule, children = _addDefaultProps.children, _addDefaultProps$inne = _addDefaultProps.innerRef, innerRef = _addDefaultProps$inne === void 0 ? ref : _addDefaultProps$inne, otherProps = _objectWithoutProperties$i(_addDefaultProps, _excluded$i);
  var transitionProps = pick(_objectSpread$3({
    defaultProps: defaultProps$1
  }, otherProps), TransitionPropTypeKeys);
  var childProps = omit(otherProps, TransitionPropTypeKeys);
  return /* @__PURE__ */ React$1.createElement(Transition, _extends$j({
    nodeRef: innerRef
  }, transitionProps), function(status) {
    var isActive = status === "entered";
    var classes = mapToCssModules(classnames(className, baseClass, isActive && baseClassActive), cssModule);
    return /* @__PURE__ */ React$1.createElement(Tag, _extends$j({
      className: classes
    }, childProps, {
      ref: innerRef
    }), children);
  });
}
Fade.propTypes = propTypes$k;
var _excluded$h = ["className", "cssModule", "color", "innerRef", "pill", "tag"];
function _extends$i() {
  _extends$i = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$i.apply(this, arguments);
}
function _objectWithoutProperties$h(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$h(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$h(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$j = {
  /** Pass children so this component can wrap the child elements */
  children: PropTypes.node,
  /** Add custom class */
  className: PropTypes.string,
  /** Change background color of Badge */
  color: PropTypes.string,
  /** Change existing className with a new className */
  cssModule: PropTypes.object,
  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func, PropTypes.string]),
  /** Add rounded corners to the Badge */
  pill: PropTypes.bool,
  /** Set a custom element for this component */
  tag: tagPropType
};
function Badge(props) {
  var className = props.className, cssModule = props.cssModule, _props$color = props.color, color = _props$color === void 0 ? "secondary" : _props$color, innerRef = props.innerRef, _props$pill = props.pill, pill = _props$pill === void 0 ? false : _props$pill, _props$tag = props.tag, Tag = _props$tag === void 0 ? "span" : _props$tag, attributes = _objectWithoutProperties$h(props, _excluded$h);
  var classes = mapToCssModules(classnames(className, "badge", "bg-" + color, pill ? "rounded-pill" : false), cssModule);
  if (attributes.href && Tag === "span") {
    Tag = "a";
  }
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$i({}, attributes, {
    className: classes,
    ref: innerRef
  }));
}
Badge.propTypes = propTypes$j;
var _excluded$g = ["className", "cssModule", "color", "body", "inverse", "outline", "tag", "innerRef"];
function _extends$h() {
  _extends$h = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$h.apply(this, arguments);
}
function _objectWithoutProperties$g(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$g(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$g(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$i = {
  /** Toggles card padding using `.card-body` */
  body: PropTypes.bool,
  /** Add custom class */
  className: PropTypes.string,
  /** Change background color of component */
  color: PropTypes.string,
  /** Change underlying component's CSS base class name */
  cssModule: PropTypes.object,
  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func]),
  /** Inverts the color */
  inverse: PropTypes.bool,
  /** Changes the card to have only outline */
  outline: PropTypes.bool,
  /** Set a custom element for this component */
  tag: tagPropType
};
function Card(props) {
  var className = props.className, cssModule = props.cssModule, color = props.color, body = props.body, inverse = props.inverse, outline = props.outline, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, innerRef = props.innerRef, attributes = _objectWithoutProperties$g(props, _excluded$g);
  var classes = mapToCssModules(classnames(className, "card", inverse ? "text-white" : false, body ? "card-body" : false, color ? "".concat(outline ? "border" : "bg", "-").concat(color) : false), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$h({}, attributes, {
    className: classes,
    ref: innerRef
  }));
}
Card.propTypes = propTypes$i;
var _excluded$f = ["className", "cssModule", "innerRef", "tag"];
function _extends$g() {
  _extends$g = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$g.apply(this, arguments);
}
function _objectWithoutProperties$f(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$f(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$f(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$h = {
  /** Add custom class */
  className: PropTypes.string,
  /** Change underlying component's CSS base class name */
  cssModule: PropTypes.object,
  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func]),
  /** Set a custom element for this component */
  tag: tagPropType
};
function CardBody(props) {
  var className = props.className, cssModule = props.cssModule, innerRef = props.innerRef, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, attributes = _objectWithoutProperties$f(props, _excluded$f);
  var classes = mapToCssModules(classnames(className, "card-body"), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$g({}, attributes, {
    className: classes,
    ref: innerRef
  }));
}
CardBody.propTypes = propTypes$h;
var _excluded$e = ["className", "cssModule", "tag"];
function _extends$f() {
  _extends$f = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$f.apply(this, arguments);
}
function _objectWithoutProperties$e(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$e(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$e(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$g = {
  /** Add custom class */
  className: PropTypes.string,
  /** Change underlying component's CSS base class name */
  cssModule: PropTypes.object,
  /** Set a custom element for this component */
  tag: tagPropType
};
function CardHeader(props) {
  var className = props.className, cssModule = props.cssModule, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, attributes = _objectWithoutProperties$e(props, _excluded$e);
  var classes = mapToCssModules(classnames(className, "card-header"), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$f({}, attributes, {
    className: classes
  }));
}
CardHeader.propTypes = propTypes$g;
var _excluded$d = ["children", "className", "barClassName", "cssModule", "value", "min", "max", "animated", "striped", "color", "bar", "multi", "tag", "style", "barStyle", "barAriaValueText", "barAriaLabelledBy"];
function _extends$e() {
  _extends$e = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$e.apply(this, arguments);
}
function ownKeys$2(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$d(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$d(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$d(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$f = {
  /** Enable animation to bar */
  animated: PropTypes.bool,
  bar: PropTypes.bool,
  barAriaLabelledBy: PropTypes.string,
  barAriaValueText: PropTypes.string,
  barClassName: PropTypes.string,
  barStyle: PropTypes.object,
  children: PropTypes.node,
  /** Add custom class */
  className: PropTypes.string,
  /** Change underlying component's CSS base class name */
  cssModule: PropTypes.object,
  /** Add custom color to the placeholder */
  color: PropTypes.string,
  /** Maximum value of progress */
  max: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  /** Minimum value of progress, defaults to zero */
  min: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  multi: PropTypes.bool,
  /** Add stripes to progress bar */
  striped: PropTypes.bool,
  style: PropTypes.object,
  /** Set a custom element for this component */
  tag: tagPropType,
  /** Current value of progress */
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
};
function Progress$1(props) {
  var children = props.children, className = props.className, barClassName = props.barClassName, cssModule = props.cssModule, _props$value = props.value, value = _props$value === void 0 ? 0 : _props$value, _props$min = props.min, min = _props$min === void 0 ? 0 : _props$min, _props$max = props.max, max = _props$max === void 0 ? 100 : _props$max, animated = props.animated, striped = props.striped, color = props.color, bar = props.bar, multi = props.multi, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, _props$style = props.style, style = _props$style === void 0 ? {} : _props$style, _props$barStyle = props.barStyle, barStyle = _props$barStyle === void 0 ? {} : _props$barStyle, barAriaValueText = props.barAriaValueText, barAriaLabelledBy = props.barAriaLabelledBy, attributes = _objectWithoutProperties$d(props, _excluded$d);
  var percent = toNumber(value) / toNumber(max) * 100;
  var progressClasses = mapToCssModules(classnames(className, "progress"), cssModule);
  var progressBarClasses = mapToCssModules(classnames("progress-bar", bar ? className || barClassName : barClassName, animated ? "progress-bar-animated" : null, color ? "bg-".concat(color) : null, striped || animated ? "progress-bar-striped" : null), cssModule);
  var progressBarProps = {
    className: progressBarClasses,
    style: _objectSpread$2(_objectSpread$2(_objectSpread$2({}, bar ? style : {}), barStyle), {}, {
      width: "".concat(percent, "%")
    }),
    role: "progressbar",
    "aria-valuenow": value,
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuetext": barAriaValueText,
    "aria-labelledby": barAriaLabelledBy,
    children
  };
  if (bar) {
    return /* @__PURE__ */ React$1.createElement(Tag, _extends$e({}, attributes, progressBarProps));
  }
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$e({}, attributes, {
    style,
    className: progressClasses
  }), multi ? children : /* @__PURE__ */ React$1.createElement("div", progressBarProps));
}
Progress$1.propTypes = propTypes$f;
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$3(obj);
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o2, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$3(o2, p2);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self2, call) {
  if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$3(o2) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$3(o2);
}
var propTypes$e = {
  children: PropTypes.node.isRequired,
  node: PropTypes.any
};
var Portal = /* @__PURE__ */ (function(_React$Component) {
  _inherits$3(Portal2, _React$Component);
  var _super = _createSuper$3(Portal2);
  function Portal2() {
    _classCallCheck$3(this, Portal2);
    return _super.apply(this, arguments);
  }
  _createClass$3(Portal2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.defaultNode) {
        document.body.removeChild(this.defaultNode);
      }
      this.defaultNode = null;
    }
  }, {
    key: "render",
    value: function render2() {
      if (!canUseDOM) {
        return null;
      }
      if (!this.props.node && !this.defaultNode) {
        this.defaultNode = document.createElement("div");
        document.body.appendChild(this.defaultNode);
      }
      return /* @__PURE__ */ ReactDOM$1.createPortal(this.props.children, this.props.node || this.defaultNode);
    }
  }]);
  return Portal2;
})(React$1.Component);
Portal.propTypes = propTypes$e;
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
function ownKeys$1(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _extends$d() {
  _extends$d = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$d.apply(this, arguments);
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o2, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$2(o2, p2);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$2(o2) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$2(o2);
}
function noop() {
}
var FadePropTypes = PropTypes.shape(Fade.propTypes);
var propTypes$d = {
  /** */
  autoFocus: PropTypes.bool,
  /** Add backdrop to modal */
  backdrop: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(["static"])]),
  /** add custom classname to backdrop */
  backdropClassName: PropTypes.string,
  backdropTransition: FadePropTypes,
  /** Vertically center the modal */
  centered: PropTypes.bool,
  /** Add children for the modal to wrap */
  children: PropTypes.node,
  /** Add custom className for modal content */
  contentClassName: PropTypes.string,
  className: PropTypes.string,
  container: targetPropType,
  cssModule: PropTypes.object,
  external: PropTypes.node,
  /** Enable/Disable animation */
  fade: PropTypes.bool,
  /** Make the modal fullscreen */
  fullscreen: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(["sm", "md", "lg", "xl"])]),
  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func]),
  /** The status of the modal, either open or close */
  isOpen: PropTypes.bool,
  /** Allow modal to be closed with escape key. */
  keyboard: PropTypes.bool,
  /** Identifies the element (or elements) that labels the current element. */
  labelledBy: PropTypes.string,
  modalClassName: PropTypes.string,
  modalTransition: FadePropTypes,
  /** Function to be triggered on close */
  onClosed: PropTypes.func,
  /** Function to be triggered on enter */
  onEnter: PropTypes.func,
  /** Function to be triggered on exit */
  onExit: PropTypes.func,
  /** Function to be triggered on open */
  onOpened: PropTypes.func,
  /** Returns focus to the element that triggered opening of the modal */
  returnFocusAfterClose: PropTypes.bool,
  /** Accessibility role */
  role: PropTypes.string,
  /** Make the modal scrollable */
  scrollable: PropTypes.bool,
  /** Two optional sizes `lg` and `sm` */
  size: PropTypes.string,
  /** Function to toggle modal visibility */
  toggle: PropTypes.func,
  trapFocus: PropTypes.bool,
  /** Unmounts the modal when modal is closed */
  unmountOnClose: PropTypes.bool,
  wrapClassName: PropTypes.string,
  zIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
};
var propsToOmit = Object.keys(propTypes$d);
var defaultProps = {
  isOpen: false,
  autoFocus: true,
  centered: false,
  scrollable: false,
  role: "dialog",
  backdrop: true,
  keyboard: true,
  zIndex: 1050,
  fade: true,
  onOpened: noop,
  onClosed: noop,
  modalTransition: {
    timeout: TransitionTimeouts.Modal
  },
  backdropTransition: {
    mountOnEnter: true,
    timeout: TransitionTimeouts.Fade
    // uses standard fade transition
  },
  unmountOnClose: true,
  returnFocusAfterClose: true,
  container: "body",
  trapFocus: false
};
var Modal$1 = /* @__PURE__ */ (function(_React$Component) {
  _inherits$2(Modal2, _React$Component);
  var _super = _createSuper$2(Modal2);
  function Modal2(props) {
    var _this;
    _classCallCheck$2(this, Modal2);
    _this = _super.call(this, props);
    _this._element = null;
    _this._originalBodyPadding = null;
    _this.getFocusableChildren = _this.getFocusableChildren.bind(_assertThisInitialized$2(_this));
    _this.handleBackdropClick = _this.handleBackdropClick.bind(_assertThisInitialized$2(_this));
    _this.handleBackdropMouseDown = _this.handleBackdropMouseDown.bind(_assertThisInitialized$2(_this));
    _this.handleEscape = _this.handleEscape.bind(_assertThisInitialized$2(_this));
    _this.handleStaticBackdropAnimation = _this.handleStaticBackdropAnimation.bind(_assertThisInitialized$2(_this));
    _this.handleTab = _this.handleTab.bind(_assertThisInitialized$2(_this));
    _this.onOpened = _this.onOpened.bind(_assertThisInitialized$2(_this));
    _this.onClosed = _this.onClosed.bind(_assertThisInitialized$2(_this));
    _this.manageFocusAfterClose = _this.manageFocusAfterClose.bind(_assertThisInitialized$2(_this));
    _this.clearBackdropAnimationTimeout = _this.clearBackdropAnimationTimeout.bind(_assertThisInitialized$2(_this));
    _this.trapFocus = _this.trapFocus.bind(_assertThisInitialized$2(_this));
    _this.state = {
      isOpen: false,
      showStaticBackdropAnimation: false
    };
    return _this;
  }
  _createClass$2(Modal2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props = this.props, isOpen = _this$props.isOpen, autoFocus = _this$props.autoFocus, onEnter = _this$props.onEnter;
      if (isOpen) {
        this.init();
        this.setState({
          isOpen: true
        });
        if (autoFocus) {
          this.setFocus();
        }
      }
      if (onEnter) {
        onEnter();
      }
      document.addEventListener("focus", this.trapFocus, true);
      this._isMounted = true;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.isOpen && !prevProps.isOpen) {
        this.init();
        this.setState({
          isOpen: true
        });
        return;
      }
      if (this.props.autoFocus && this.state.isOpen && !prevState.isOpen) {
        this.setFocus();
      }
      if (this._element && prevProps.zIndex !== this.props.zIndex) {
        this._element.style.zIndex = this.props.zIndex;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clearBackdropAnimationTimeout();
      if (this.props.onExit) {
        this.props.onExit();
      }
      if (this._element) {
        this.destroy();
        if (this.props.isOpen || this.state.isOpen) {
          this.close();
        }
      }
      document.removeEventListener("focus", this.trapFocus, true);
      this._isMounted = false;
    }
    // not mouseUp because scrollbar fires it, shouldn't close when user scrolls
  }, {
    key: "handleBackdropClick",
    value: function handleBackdropClick(e2) {
      if (e2.target === this._mouseDownElement) {
        e2.stopPropagation();
        var backdrop = this._dialog ? this._dialog.parentNode : null;
        if (backdrop && e2.target === backdrop && this.props.backdrop === "static") {
          this.handleStaticBackdropAnimation();
        }
        if (!this.props.isOpen || this.props.backdrop !== true) return;
        if (backdrop && e2.target === backdrop && this.props.toggle) {
          this.props.toggle(e2);
        }
      }
    }
  }, {
    key: "handleTab",
    value: function handleTab2(e2) {
      if (e2.which !== 9) return;
      if (this.modalIndex < Modal2.openCount - 1) return;
      var focusableChildren = this.getFocusableChildren();
      var totalFocusable = focusableChildren.length;
      if (totalFocusable === 0) return;
      var currentFocus = this.getFocusedChild();
      var focusedIndex = 0;
      for (var i2 = 0; i2 < totalFocusable; i2 += 1) {
        if (focusableChildren[i2] === currentFocus) {
          focusedIndex = i2;
          break;
        }
      }
      if (e2.shiftKey && focusedIndex === 0) {
        e2.preventDefault();
        focusableChildren[totalFocusable - 1].focus();
      } else if (!e2.shiftKey && focusedIndex === totalFocusable - 1) {
        e2.preventDefault();
        focusableChildren[0].focus();
      }
    }
  }, {
    key: "handleBackdropMouseDown",
    value: function handleBackdropMouseDown(e2) {
      this._mouseDownElement = e2.target;
    }
  }, {
    key: "handleEscape",
    value: function handleEscape(e2) {
      if (this.props.isOpen && e2.keyCode === keyCodes.esc && this.props.toggle) {
        if (this.props.keyboard) {
          e2.preventDefault();
          e2.stopPropagation();
          this.props.toggle(e2);
        } else if (this.props.backdrop === "static") {
          e2.preventDefault();
          e2.stopPropagation();
          this.handleStaticBackdropAnimation();
        }
      }
    }
  }, {
    key: "handleStaticBackdropAnimation",
    value: function handleStaticBackdropAnimation() {
      var _this2 = this;
      this.clearBackdropAnimationTimeout();
      this.setState({
        showStaticBackdropAnimation: true
      });
      this._backdropAnimationTimeout = setTimeout(function() {
        _this2.setState({
          showStaticBackdropAnimation: false
        });
      }, 100);
    }
  }, {
    key: "onOpened",
    value: function onOpened(node, isAppearing) {
      this.props.onOpened();
      (this.props.modalTransition.onEntered || noop)(node, isAppearing);
    }
  }, {
    key: "onClosed",
    value: function onClosed(node) {
      var unmountOnClose = this.props.unmountOnClose;
      this.props.onClosed();
      (this.props.modalTransition.onExited || noop)(node);
      if (unmountOnClose) {
        this.destroy();
      }
      this.close();
      if (this._isMounted) {
        this.setState({
          isOpen: false
        });
      }
    }
  }, {
    key: "setFocus",
    value: function setFocus2() {
      if (this._dialog && this._dialog.parentNode && typeof this._dialog.parentNode.focus === "function") {
        this._dialog.parentNode.focus();
      }
    }
  }, {
    key: "getFocusableChildren",
    value: function getFocusableChildren() {
      return this._element.querySelectorAll(focusableElements.join(", "));
    }
  }, {
    key: "getFocusedChild",
    value: function getFocusedChild() {
      var currentFocus;
      var focusableChildren = this.getFocusableChildren();
      try {
        currentFocus = document.activeElement;
      } catch (err) {
        currentFocus = focusableChildren[0];
      }
      return currentFocus;
    }
  }, {
    key: "trapFocus",
    value: function trapFocus(ev) {
      if (!this.props.trapFocus) {
        return;
      }
      if (!this._element) {
        return;
      }
      if (this._dialog && this._dialog.parentNode === ev.target) {
        return;
      }
      if (this.modalIndex < Modal2.openCount - 1) {
        return;
      }
      var children = this.getFocusableChildren();
      for (var i2 = 0; i2 < children.length; i2 += 1) {
        if (children[i2] === ev.target) return;
      }
      if (children.length > 0) {
        ev.preventDefault();
        ev.stopPropagation();
        children[0].focus();
      }
    }
  }, {
    key: "init",
    value: function init2() {
      try {
        this._triggeringElement = document.activeElement;
      } catch (err) {
        this._triggeringElement = null;
      }
      if (!this._element) {
        this._element = document.createElement("div");
        this._element.setAttribute("tabindex", "-1");
        this._element.style.position = "relative";
        this._element.style.zIndex = this.props.zIndex;
        this._mountContainer = getTarget(this.props.container);
        this._mountContainer.appendChild(this._element);
      }
      this._originalBodyPadding = getOriginalBodyPadding();
      if (Modal2.openCount < 1) {
        Modal2.originalBodyOverflow = window.getComputedStyle(document.body).overflow;
      }
      conditionallyUpdateScrollbar();
      if (Modal2.openCount === 0) {
        document.body.className = classnames(document.body.className, mapToCssModules("modal-open", this.props.cssModule));
        document.body.style.overflow = "hidden";
      }
      this.modalIndex = Modal2.openCount;
      Modal2.openCount += 1;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this._element) {
        this._mountContainer.removeChild(this._element);
        this._element = null;
      }
      this.manageFocusAfterClose();
    }
  }, {
    key: "manageFocusAfterClose",
    value: function manageFocusAfterClose() {
      if (this._triggeringElement) {
        var returnFocusAfterClose = this.props.returnFocusAfterClose;
        if (this._triggeringElement.focus && returnFocusAfterClose) this._triggeringElement.focus();
        this._triggeringElement = null;
      }
    }
  }, {
    key: "close",
    value: function close2() {
      if (Modal2.openCount <= 1) {
        var modalOpenClassName = mapToCssModules("modal-open", this.props.cssModule);
        var modalOpenClassNameRegex = new RegExp("(^| )".concat(modalOpenClassName, "( |$)"));
        document.body.className = document.body.className.replace(modalOpenClassNameRegex, " ").trim();
        document.body.style.overflow = Modal2.originalBodyOverflow;
      }
      this.manageFocusAfterClose();
      Modal2.openCount = Math.max(0, Modal2.openCount - 1);
      setScrollbarWidth(this._originalBodyPadding);
    }
  }, {
    key: "clearBackdropAnimationTimeout",
    value: function clearBackdropAnimationTimeout() {
      if (this._backdropAnimationTimeout) {
        clearTimeout(this._backdropAnimationTimeout);
        this._backdropAnimationTimeout = void 0;
      }
    }
  }, {
    key: "renderModalDialog",
    value: function renderModalDialog() {
      var _classNames, _this3 = this;
      var attributes = omit(this.props, propsToOmit);
      var dialogBaseClass = "modal-dialog";
      return /* @__PURE__ */ React$1.createElement("div", _extends$d({}, attributes, {
        className: mapToCssModules(classnames(dialogBaseClass, this.props.className, (_classNames = {}, _defineProperty$3(_classNames, "modal-".concat(this.props.size), this.props.size), _defineProperty$3(_classNames, "".concat(dialogBaseClass, "-centered"), this.props.centered), _defineProperty$3(_classNames, "".concat(dialogBaseClass, "-scrollable"), this.props.scrollable), _defineProperty$3(_classNames, "modal-fullscreen", this.props.fullscreen === true), _defineProperty$3(_classNames, "modal-fullscreen-".concat(this.props.fullscreen, "-down"), typeof this.props.fullscreen === "string"), _classNames)), this.props.cssModule),
        role: "document",
        ref: function ref(c2) {
          _this3._dialog = c2;
        }
      }), /* @__PURE__ */ React$1.createElement("div", {
        className: mapToCssModules(classnames("modal-content", this.props.contentClassName), this.props.cssModule)
      }, this.props.children));
    }
  }, {
    key: "render",
    value: function render2() {
      var unmountOnClose = this.props.unmountOnClose;
      if (!!this._element && (this.state.isOpen || !unmountOnClose)) {
        var isModalHidden = !!this._element && !this.state.isOpen && !unmountOnClose;
        this._element.style.display = isModalHidden ? "none" : "block";
        var _this$props2 = this.props, wrapClassName = _this$props2.wrapClassName, modalClassName = _this$props2.modalClassName, backdropClassName = _this$props2.backdropClassName, cssModule = _this$props2.cssModule, isOpen = _this$props2.isOpen, backdrop = _this$props2.backdrop, role = _this$props2.role, labelledBy = _this$props2.labelledBy, external = _this$props2.external, innerRef = _this$props2.innerRef;
        var modalAttributes = {
          onClick: this.handleBackdropClick,
          onMouseDown: this.handleBackdropMouseDown,
          onKeyUp: this.handleEscape,
          onKeyDown: this.handleTab,
          style: {
            display: "block"
          },
          "aria-labelledby": labelledBy,
          "aria-modal": true,
          role,
          tabIndex: "-1"
        };
        var hasTransition = this.props.fade;
        var modalTransition = _objectSpread$1(_objectSpread$1(_objectSpread$1({}, Fade.defaultProps), this.props.modalTransition), {}, {
          baseClass: hasTransition ? this.props.modalTransition.baseClass : "",
          timeout: hasTransition ? this.props.modalTransition.timeout : 0
        });
        var backdropTransition = _objectSpread$1(_objectSpread$1(_objectSpread$1({}, Fade.defaultProps), this.props.backdropTransition), {}, {
          baseClass: hasTransition ? this.props.backdropTransition.baseClass : "",
          timeout: hasTransition ? this.props.backdropTransition.timeout : 0
        });
        var Backdrop = backdrop && (hasTransition ? /* @__PURE__ */ React$1.createElement(Fade, _extends$d({}, backdropTransition, {
          "in": isOpen && !!backdrop,
          cssModule,
          className: mapToCssModules(classnames("modal-backdrop", backdropClassName), cssModule)
        })) : /* @__PURE__ */ React$1.createElement("div", {
          className: mapToCssModules(classnames("modal-backdrop", "show", backdropClassName), cssModule)
        }));
        return /* @__PURE__ */ React$1.createElement(Portal, {
          node: this._element
        }, /* @__PURE__ */ React$1.createElement("div", {
          className: mapToCssModules(wrapClassName)
        }, /* @__PURE__ */ React$1.createElement(Fade, _extends$d({}, modalAttributes, modalTransition, {
          "in": isOpen,
          onEntered: this.onOpened,
          onExited: this.onClosed,
          cssModule,
          className: mapToCssModules(classnames("modal", modalClassName, this.state.showStaticBackdropAnimation && "modal-static"), cssModule),
          innerRef
        }), external, this.renderModalDialog()), Backdrop));
      }
      return null;
    }
  }]);
  return Modal2;
})(React$1.Component);
Modal$1.propTypes = propTypes$d;
Modal$1.defaultProps = defaultProps;
Modal$1.openCount = 0;
Modal$1.originalBodyOverflow = null;
var _excluded$c = ["className", "cssModule", "children", "toggle", "tag", "wrapTag", "closeAriaLabel", "close"];
function _extends$c() {
  _extends$c = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$c.apply(this, arguments);
}
function _objectWithoutProperties$c(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$c(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$c(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$c = {
  children: PropTypes.node,
  /** Add custom class */
  className: PropTypes.string,
  /** Custom close button */
  close: PropTypes.object,
  closeAriaLabel: PropTypes.string,
  /** Change underlying component's CSS base class name */
  cssModule: PropTypes.object,
  /** Set a custom element for this component */
  tag: tagPropType,
  /** Function to be triggered when close button is clicked */
  toggle: PropTypes.func,
  wrapTag: tagPropType
};
function ModalHeader(props) {
  var closeButton;
  var className = props.className, cssModule = props.cssModule, children = props.children, toggle2 = props.toggle, _props$tag = props.tag, Tag = _props$tag === void 0 ? "h5" : _props$tag, _props$wrapTag = props.wrapTag, WrapTag = _props$wrapTag === void 0 ? "div" : _props$wrapTag, _props$closeAriaLabel = props.closeAriaLabel, closeAriaLabel = _props$closeAriaLabel === void 0 ? "Close" : _props$closeAriaLabel, close2 = props.close, attributes = _objectWithoutProperties$c(props, _excluded$c);
  var classes = mapToCssModules(classnames(className, "modal-header"), cssModule);
  if (!close2 && toggle2) {
    closeButton = /* @__PURE__ */ React$1.createElement("button", {
      type: "button",
      onClick: toggle2,
      className: mapToCssModules("btn-close", cssModule),
      "aria-label": closeAriaLabel
    });
  }
  return /* @__PURE__ */ React$1.createElement(WrapTag, _extends$c({}, attributes, {
    className: classes
  }), /* @__PURE__ */ React$1.createElement(Tag, {
    className: mapToCssModules("modal-title", cssModule)
  }, children), close2 || closeButton);
}
ModalHeader.propTypes = propTypes$c;
var _excluded$b = ["className", "cssModule", "tag"];
function _extends$b() {
  _extends$b = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$b.apply(this, arguments);
}
function _objectWithoutProperties$b(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$b(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$b(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$b = {
  /** Add custom class */
  className: PropTypes.string,
  /** Change underlying component's CSS base class name */
  cssModule: PropTypes.object,
  /** Set a custom element for this component */
  tag: tagPropType
};
function ModalBody(props) {
  var className = props.className, cssModule = props.cssModule, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, attributes = _objectWithoutProperties$b(props, _excluded$b);
  var classes = mapToCssModules(classnames(className, "modal-body"), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$b({}, attributes, {
    className: classes
  }));
}
ModalBody.propTypes = propTypes$b;
var _excluded$a = ["className", "cssModule", "tag"];
function _extends$a() {
  _extends$a = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$a.apply(this, arguments);
}
function _objectWithoutProperties$a(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$a(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$a(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$a = {
  /** Add custom class */
  className: PropTypes.string,
  /** Change underlying component's CSS base class name */
  cssModule: PropTypes.object,
  /** Set a custom element for this component */
  tag: tagPropType
};
function ModalFooter(props) {
  var className = props.className, cssModule = props.cssModule, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, attributes = _objectWithoutProperties$a(props, _excluded$a);
  var classes = mapToCssModules(classnames(className, "modal-footer"), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$a({}, attributes, {
    className: classes
  }));
}
ModalFooter.propTypes = propTypes$a;
var _excluded$9 = ["className", "cssModule", "size", "bordered", "borderless", "striped", "dark", "hover", "responsive", "tag", "responsiveTag", "innerRef"];
function _extends$9() {
  _extends$9 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$9.apply(this, arguments);
}
function _objectWithoutProperties$9(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$9(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$9(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$9 = {
  /** Adds border to all sides of table */
  bordered: PropTypes.bool,
  /** Removes all borders */
  borderless: PropTypes.bool,
  /** Adds custom class name to component */
  className: PropTypes.string,
  /**  */
  cssModule: PropTypes.object,
  /** Makes the table dark */
  dark: PropTypes.bool,
  /** Enables a hover state on the rows within `<tbody>` */
  hover: PropTypes.bool,
  innerRef: PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.object]),
  /** Responsive tables allow tables to be scrolled horizontally with ease */
  responsive: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
  responsiveTag: tagPropType,
  /** Make tables more compact by cutting cell padding in half when setting size as sm. */
  size: PropTypes.string,
  /** Adds zebra-striping to any table row within the `<tbody>` */
  striped: PropTypes.bool,
  /** Add custom tag to the component */
  tag: tagPropType
};
function Table(props) {
  var className = props.className, cssModule = props.cssModule, size = props.size, bordered = props.bordered, borderless = props.borderless, striped = props.striped, dark = props.dark, hover = props.hover, responsive = props.responsive, _props$tag = props.tag, Tag = _props$tag === void 0 ? "table" : _props$tag, _props$responsiveTag = props.responsiveTag, ResponsiveTag = _props$responsiveTag === void 0 ? "div" : _props$responsiveTag, innerRef = props.innerRef, attributes = _objectWithoutProperties$9(props, _excluded$9);
  var classes = mapToCssModules(classnames(className, "table", size ? "table-" + size : false, bordered ? "table-bordered" : false, borderless ? "table-borderless" : false, striped ? "table-striped" : false, dark ? "table-dark" : false, hover ? "table-hover" : false), cssModule);
  var table = /* @__PURE__ */ React$1.createElement(Tag, _extends$9({}, attributes, {
    ref: innerRef,
    className: classes
  }));
  if (responsive) {
    var responsiveClassName = mapToCssModules(responsive === true ? "table-responsive" : "table-responsive-".concat(responsive), cssModule);
    return /* @__PURE__ */ React$1.createElement(ResponsiveTag, {
      className: responsiveClassName
    }, table);
  }
  return table;
}
Table.propTypes = propTypes$9;
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
var _excluded$8 = ["className", "cssModule", "tag", "innerRef"];
function _extends$8() {
  _extends$8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
function _objectWithoutProperties$8(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$8(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$8(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o2, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$1(o2, p2);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1(o2) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$1(o2);
}
var propTypes$8 = {
  children: PropTypes.node,
  tag: tagPropType,
  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func, PropTypes.string]),
  className: PropTypes.string,
  cssModule: PropTypes.object
};
var Form = /* @__PURE__ */ (function(_Component) {
  _inherits$1(Form2, _Component);
  var _super = _createSuper$1(Form2);
  function Form2(props) {
    var _this;
    _classCallCheck$1(this, Form2);
    _this = _super.call(this, props);
    _this.getRef = _this.getRef.bind(_assertThisInitialized$1(_this));
    _this.submit = _this.submit.bind(_assertThisInitialized$1(_this));
    return _this;
  }
  _createClass$1(Form2, [{
    key: "getRef",
    value: function getRef(ref) {
      if (this.props.innerRef) {
        this.props.innerRef(ref);
      }
      this.ref = ref;
    }
  }, {
    key: "submit",
    value: function submit() {
      if (this.ref) {
        this.ref.submit();
      }
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$props = this.props, className = _this$props.className, cssModule = _this$props.cssModule, _this$props$tag = _this$props.tag, Tag = _this$props$tag === void 0 ? "form" : _this$props$tag, innerRef = _this$props.innerRef, attributes = _objectWithoutProperties$8(_this$props, _excluded$8);
      var classes = mapToCssModules(className, cssModule);
      return /* @__PURE__ */ React$1.createElement(Tag, _extends$8({}, attributes, {
        ref: innerRef,
        className: classes
      }));
    }
  }]);
  return Form2;
})(reactExports.Component);
Form.propTypes = propTypes$8;
var _excluded$7 = ["className", "cssModule", "row", "disabled", "check", "inline", "floating", "noMargin", "tag", "switch"];
function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
function _objectWithoutProperties$7(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$7(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$7(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$7 = {
  children: PropTypes.node,
  row: PropTypes.bool,
  check: PropTypes.bool,
  "switch": PropTypes.bool,
  inline: PropTypes.bool,
  floating: PropTypes.bool,
  noMargin: PropTypes.bool,
  disabled: PropTypes.bool,
  tag: tagPropType,
  className: PropTypes.string,
  cssModule: PropTypes.object
};
function FormGroup(props) {
  var className = props.className, cssModule = props.cssModule, row = props.row, disabled = props.disabled, check = props.check, inline = props.inline, floating = props.floating, noMargin = props.noMargin, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, switchProp = props["switch"], attributes = _objectWithoutProperties$7(props, _excluded$7);
  var formCheck = check || switchProp;
  var classes = mapToCssModules(classnames(className, row ? "row" : false, formCheck ? "form-check" : false, switchProp ? "form-switch" : false, formCheck || noMargin ? false : "mb-3", formCheck && inline ? "form-check-inline" : false, formCheck && disabled ? "disabled" : false, floating && "form-floating"), cssModule);
  if (Tag === "fieldset") {
    attributes.disabled = disabled;
  }
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$7({}, attributes, {
    className: classes
  }));
}
FormGroup.propTypes = propTypes$7;
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var _excluded$6 = ["className", "cssModule", "type", "bsSize", "valid", "invalid", "tag", "addon", "plaintext", "innerRef"];
function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
function _objectWithoutProperties$6(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$6(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$6(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
var propTypes$6 = {
  children: PropTypes.node,
  type: PropTypes.string,
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  bsSize: PropTypes.string,
  valid: PropTypes.bool,
  invalid: PropTypes.bool,
  tag: tagPropType,
  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func, PropTypes.string]),
  plaintext: PropTypes.bool,
  addon: PropTypes.bool,
  className: PropTypes.string,
  cssModule: PropTypes.object
};
var Input = /* @__PURE__ */ (function(_React$Component) {
  _inherits(Input2, _React$Component);
  var _super = _createSuper(Input2);
  function Input2(props) {
    var _this;
    _classCallCheck(this, Input2);
    _this = _super.call(this, props);
    _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));
    _this.focus = _this.focus.bind(_assertThisInitialized(_this));
    return _this;
  }
  _createClass(Input2, [{
    key: "getRef",
    value: function getRef(ref) {
      if (this.props.innerRef) {
        this.props.innerRef(ref);
      }
      this.ref = ref;
    }
  }, {
    key: "focus",
    value: function focus() {
      if (this.ref) {
        this.ref.focus();
      }
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$props = this.props, className = _this$props.className, cssModule = _this$props.cssModule, _this$props$type = _this$props.type, type = _this$props$type === void 0 ? "text" : _this$props$type, bsSize = _this$props.bsSize, valid = _this$props.valid, invalid = _this$props.invalid, tag = _this$props.tag, addon = _this$props.addon, plaintext = _this$props.plaintext, innerRef = _this$props.innerRef, attributes = _objectWithoutProperties$6(_this$props, _excluded$6);
      var checkInput = ["switch", "radio", "checkbox"].indexOf(type) > -1;
      var isNotaNumber = /\D/g;
      var textareaInput = type === "textarea";
      var selectInput = type === "select";
      var rangeInput = type === "range";
      var Tag = tag || (selectInput || textareaInput ? type : "input");
      var formControlClass = "form-control";
      if (plaintext) {
        formControlClass = "".concat(formControlClass, "-plaintext");
        Tag = tag || "input";
      } else if (rangeInput) {
        formControlClass = "form-range";
      } else if (selectInput) {
        formControlClass = "form-select";
      } else if (checkInput) {
        if (addon) {
          formControlClass = null;
        } else {
          formControlClass = "form-check-input";
        }
      }
      if (attributes.size && isNotaNumber.test(attributes.size)) {
        warnOnce(`Please use the prop "bsSize" instead of the "size" to bootstrap's input sizing.`);
        bsSize = attributes.size;
        delete attributes.size;
      }
      var classes = mapToCssModules(classnames(className, invalid && "is-invalid", valid && "is-valid", bsSize ? selectInput ? "form-select-".concat(bsSize) : "form-control-".concat(bsSize) : false, formControlClass), cssModule);
      if (Tag === "input" || tag && typeof tag === "function") {
        attributes.type = type === "switch" ? "checkbox" : type;
      }
      if (attributes.children && !(plaintext || type === "select" || typeof Tag !== "string" || Tag === "select")) {
        warnOnce('Input with a type of "'.concat(type, '" cannot have children. Please use "value"/"defaultValue" instead.'));
        delete attributes.children;
      }
      return /* @__PURE__ */ React$1.createElement(Tag, _extends$6({}, attributes, {
        ref: innerRef,
        className: classes,
        "aria-invalid": invalid
      }));
    }
  }]);
  return Input2;
})(React$1.Component);
Input.propTypes = propTypes$6;
var _excluded$5 = ["className", "cssModule", "hidden", "widths", "tag", "check", "size", "for"];
function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$5(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$5(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var colWidths = ["xs", "sm", "md", "lg", "xl", "xxl"];
var stringOrNumberProp = PropTypes.oneOfType([PropTypes.number, PropTypes.string]);
var columnProps = PropTypes.oneOfType([PropTypes.bool, PropTypes.string, PropTypes.number, PropTypes.shape({
  size: stringOrNumberProp,
  order: stringOrNumberProp,
  offset: stringOrNumberProp
})]);
var propTypes$5 = {
  children: PropTypes.node,
  hidden: PropTypes.bool,
  check: PropTypes.bool,
  size: PropTypes.string,
  "for": PropTypes.string,
  tag: tagPropType,
  className: PropTypes.string,
  cssModule: PropTypes.object,
  xs: columnProps,
  sm: columnProps,
  md: columnProps,
  lg: columnProps,
  xl: columnProps,
  xxl: columnProps,
  widths: PropTypes.array
};
var getColumnSizeClass2 = function getColumnSizeClass3(isXs, colWidth, colSize) {
  if (colSize === true || colSize === "") {
    return isXs ? "col" : "col-".concat(colWidth);
  }
  if (colSize === "auto") {
    return isXs ? "col-auto" : "col-".concat(colWidth, "-auto");
  }
  return isXs ? "col-".concat(colSize) : "col-".concat(colWidth, "-").concat(colSize);
};
function Label(props) {
  var className = props.className, cssModule = props.cssModule, hidden = props.hidden, _props$widths = props.widths, widths = _props$widths === void 0 ? colWidths : _props$widths, _props$tag = props.tag, Tag = _props$tag === void 0 ? "label" : _props$tag, check = props.check, size = props.size, htmlFor = props["for"], attributes = _objectWithoutProperties$5(props, _excluded$5);
  var colClasses = [];
  widths.forEach(function(colWidth, i2) {
    var columnProp = props[colWidth];
    delete attributes[colWidth];
    if (!columnProp && columnProp !== "") {
      return;
    }
    var isXs = !i2;
    var colClass;
    if (isObject(columnProp)) {
      var _classNames;
      var colSizeInterfix = isXs ? "-" : "-".concat(colWidth, "-");
      colClass = getColumnSizeClass2(isXs, colWidth, columnProp.size);
      colClasses.push(mapToCssModules(classnames((_classNames = {}, _defineProperty$2(_classNames, colClass, columnProp.size || columnProp.size === ""), _defineProperty$2(_classNames, "order".concat(colSizeInterfix).concat(columnProp.order), columnProp.order || columnProp.order === 0), _defineProperty$2(_classNames, "offset".concat(colSizeInterfix).concat(columnProp.offset), columnProp.offset || columnProp.offset === 0), _classNames))), cssModule);
    } else {
      colClass = getColumnSizeClass2(isXs, colWidth, columnProp);
      colClasses.push(colClass);
    }
  });
  var colFormLabel = size || colClasses.length;
  var formLabel = !(check || colFormLabel);
  var classes = mapToCssModules(classnames(className, hidden ? "visually-hidden" : false, check ? "form-check-label" : false, size ? "col-form-label-".concat(size) : false, colClasses, colFormLabel ? "col-form-label" : false, formLabel ? "form-label" : false), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$5({
    htmlFor
  }, attributes, {
    className: classes
  }));
}
Label.propTypes = propTypes$5;
var _excluded$4 = ["className", "listClassName", "cssModule", "size", "tag", "listTag", "aria-label"];
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$4(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$4(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$4 = {
  children: PropTypes.node,
  /** Add custom class */
  className: PropTypes.string,
  /** Add custom class for list */
  listClassName: PropTypes.string,
  /** Change underlying component's CSS base class name */
  cssModule: PropTypes.object,
  /** Make the Pagination bigger or smaller  */
  size: PropTypes.string,
  /** Set a custom element for this component */
  tag: tagPropType,
  /** Set a custom element for list component */
  listTag: tagPropType,
  "aria-label": PropTypes.string
};
function Pagination$1(props) {
  var className = props.className, listClassName = props.listClassName, cssModule = props.cssModule, size = props.size, _props$tag = props.tag, Tag = _props$tag === void 0 ? "nav" : _props$tag, _props$listTag = props.listTag, ListTag = _props$listTag === void 0 ? "ul" : _props$listTag, _props$ariaLabel = props["aria-label"], label = _props$ariaLabel === void 0 ? "pagination" : _props$ariaLabel, attributes = _objectWithoutProperties$4(props, _excluded$4);
  var classes = mapToCssModules(classnames(className), cssModule);
  var listClasses = mapToCssModules(classnames(listClassName, "pagination", _defineProperty$1({}, "pagination-".concat(size), !!size)), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, {
    className: classes,
    "aria-label": label
  }, /* @__PURE__ */ React$1.createElement(ListTag, _extends$4({}, attributes, {
    className: listClasses
  })));
}
Pagination$1.propTypes = propTypes$4;
var _excluded$3 = ["active", "className", "cssModule", "disabled", "tag"];
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function _objectWithoutProperties$3(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$3(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$3 = {
  /** Set item as active */
  active: PropTypes.bool,
  children: PropTypes.node,
  /** Add custom class */
  className: PropTypes.string,
  /** Change underlying component's CSS base class name */
  cssModule: PropTypes.object,
  /** Set item as disabled */
  disabled: PropTypes.bool,
  /** Set a custom element for this component */
  tag: tagPropType
};
function PaginationItem(props) {
  var active = props.active, className = props.className, cssModule = props.cssModule, disabled = props.disabled, _props$tag = props.tag, Tag = _props$tag === void 0 ? "li" : _props$tag, attributes = _objectWithoutProperties$3(props, _excluded$3);
  var classes = mapToCssModules(classnames(className, "page-item", {
    active,
    disabled
  }), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$3({}, attributes, {
    className: classes
  }));
}
PaginationItem.propTypes = propTypes$3;
var _excluded$2 = ["className", "cssModule", "next", "previous", "first", "last", "tag"];
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$2 = {
  "aria-label": PropTypes.string,
  children: PropTypes.node,
  /** Add custom class */
  className: PropTypes.string,
  /** Change underlying component's CSS base class name */
  cssModule: PropTypes.object,
  /** Add to next button to add default aria label and icon */
  next: PropTypes.bool,
  /** Add to previous button to add default aria label and icon */
  previous: PropTypes.bool,
  /** Add to first button to add default aria label and icon */
  first: PropTypes.bool,
  /** Add to last button to add default aria label and icon */
  last: PropTypes.bool,
  /** Set a custom element for this component */
  tag: tagPropType
};
function PaginationLink(props) {
  var className = props.className, cssModule = props.cssModule, next = props.next, previous = props.previous, first = props.first, last = props.last, _props$tag = props.tag, Tag = _props$tag === void 0 ? "a" : _props$tag, attributes = _objectWithoutProperties$2(props, _excluded$2);
  var classes = mapToCssModules(classnames(className, "page-link"), cssModule);
  var defaultAriaLabel;
  if (previous) {
    defaultAriaLabel = "Previous";
  } else if (next) {
    defaultAriaLabel = "Next";
  } else if (first) {
    defaultAriaLabel = "First";
  } else if (last) {
    defaultAriaLabel = "Last";
  }
  var ariaLabel = props["aria-label"] || defaultAriaLabel;
  var defaultCaret;
  if (previous) {
    defaultCaret = "";
  } else if (next) {
    defaultCaret = "";
  } else if (first) {
    defaultCaret = "";
  } else if (last) {
    defaultCaret = "";
  }
  var children = props.children;
  if (children && Array.isArray(children) && children.length === 0) {
    children = null;
  }
  if (!attributes.href && Tag === "a") {
    Tag = "button";
  }
  if (previous || next || first || last) {
    children = [/* @__PURE__ */ React$1.createElement("span", {
      "aria-hidden": "true",
      key: "caret"
    }, children || defaultCaret), /* @__PURE__ */ React$1.createElement("span", {
      className: "visually-hidden",
      key: "ariaLabel"
    }, ariaLabel)];
  }
  return /* @__PURE__ */ React$1.createElement(Tag, _extends$2({}, attributes, {
    className: classes,
    "aria-label": ariaLabel
  }), children);
}
PaginationLink.propTypes = propTypes$2;
var _excluded$1 = ["className", "closeClassName", "closeAriaLabel", "cssModule", "tag", "color", "isOpen", "toggle", "children", "transition", "fade", "innerRef"];
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function ownKeys(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes$1 = {
  /** Pass children so this component can wrap the child elements */
  children: PropTypes.node,
  /** Add custom class */
  className: PropTypes.string,
  /** Add custom class for close button */
  closeClassName: PropTypes.string,
  /** Aria label for close button */
  closeAriaLabel: PropTypes.string,
  /** Change color of alert */
  color: PropTypes.string,
  /** Change existing className with a new className */
  cssModule: PropTypes.object,
  /** Toggle fade animation */
  fade: PropTypes.bool,
  innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func]),
  /** Control visibility state of Alert */
  isOpen: PropTypes.bool,
  /** Set a custom element for this component */
  tag: tagPropType,
  /** Function to toggle visibility */
  toggle: PropTypes.func,
  /** Props to be passed to `Fade` to modify transition */
  transition: PropTypes.shape(Fade.propTypes)
};
function Alert(props) {
  var className = props.className, closeClassName = props.closeClassName, _props$closeAriaLabel = props.closeAriaLabel, closeAriaLabel = _props$closeAriaLabel === void 0 ? "Close" : _props$closeAriaLabel, cssModule = props.cssModule, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, _props$color = props.color, color = _props$color === void 0 ? "success" : _props$color, _props$isOpen = props.isOpen, isOpen = _props$isOpen === void 0 ? true : _props$isOpen, toggle2 = props.toggle, children = props.children, _props$transition = props.transition, transition = _props$transition === void 0 ? _objectSpread(_objectSpread({}, Fade.defaultProps), {}, {
    unmountOnExit: true
  }) : _props$transition, _props$fade = props.fade, fade = _props$fade === void 0 ? true : _props$fade, innerRef = props.innerRef, attributes = _objectWithoutProperties$1(props, _excluded$1);
  var classes = mapToCssModules(classnames(className, "alert", "alert-".concat(color), {
    "alert-dismissible": toggle2
  }), cssModule);
  var closeClasses = mapToCssModules(classnames("btn-close", closeClassName), cssModule);
  var alertTransition = _objectSpread(_objectSpread(_objectSpread({}, Fade.defaultProps), transition), {}, {
    baseClass: fade ? transition.baseClass : "",
    timeout: fade ? transition.timeout : 0
  });
  return /* @__PURE__ */ React$1.createElement(Fade, _extends$1({}, attributes, alertTransition, {
    tag: Tag,
    className: classes,
    "in": isOpen,
    role: "alert",
    innerRef
  }), toggle2 ? /* @__PURE__ */ React$1.createElement("button", {
    type: "button",
    className: closeClasses,
    "aria-label": closeAriaLabel,
    onClick: toggle2
  }) : null, children);
}
Alert.propTypes = propTypes$1;
var _excluded = ["className", "cssModule", "type", "size", "color", "children", "tag"];
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes = {
  /** Set a custom element for this component */
  tag: tagPropType,
  /** Change animation of spinner */
  type: PropTypes.oneOf(["border", "grow"]),
  /** Change size of spinner */
  size: PropTypes.oneOf(["sm"]),
  /** Change color of spinner */
  color: PropTypes.oneOf(["primary", "secondary", "success", "danger", "warning", "info", "light", "dark"]),
  /** Add custom class */
  className: PropTypes.string,
  /** Change existing className with a new className */
  cssModule: PropTypes.object,
  /** Pass children so this component can wrap the child elements */
  children: PropTypes.string
};
function Spinner(props) {
  var className = props.className, cssModule = props.cssModule, _props$type = props.type, type = _props$type === void 0 ? "border" : _props$type, size = props.size, color = props.color, _props$children = props.children, children = _props$children === void 0 ? "Loading..." : _props$children, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, attributes = _objectWithoutProperties(props, _excluded);
  var classes = mapToCssModules(classnames(className, size ? "spinner-".concat(type, "-").concat(size) : false, "spinner-".concat(type), color ? "text-".concat(color) : false), cssModule);
  return /* @__PURE__ */ React$1.createElement(Tag, _extends({
    role: "status"
  }, attributes, {
    className: classes
  }), children && /* @__PURE__ */ React$1.createElement("span", {
    className: mapToCssModules("visually-hidden", cssModule)
  }, children));
}
Spinner.propTypes = propTypes;
const getConfigurationStatus = (startDate, endDate) => {
  const now = /* @__PURE__ */ new Date();
  const start = new Date(startDate);
  const end = new Date(endDate);
  if (now < start) {
    return "Upcoming";
  }
  if (now >= start && now <= end) {
    return "Active";
  }
  return "Completed";
};
const AppraisalConfiguration = () => {
  const [configForm, setConfigForm] = reactExports.useState({
    title: "",
    description: "",
    startDate: "",
    endDate: "",
    appraisalType: "360",
    includeSelfAssessment: true,
    includeManagerAssessment: true,
    includePeerAssessment: true,
    includeSubordinateAssessment: true,
    selectedDepartments: [],
    selectedEmployees: []
  });
  const [loading, setLoading2] = reactExports.useState(false);
  const [departments, setDepartments] = reactExports.useState([]);
  const [employees, setEmployees] = reactExports.useState([]);
  const [configurations, setConfigurations] = reactExports.useState([]);
  const [selectedEmployeeIds, setSelectedEmployeeIds] = reactExports.useState([]);
  const [selectedDeptCodes, setSelectedDeptCodes] = reactExports.useState([]);
  const [isEditMode, setIsEditMode] = reactExports.useState(false);
  const [currentConfigId, setCurrentConfigId] = reactExports.useState(null);
  const [showEmployeeModal, setShowEmployeeModal] = reactExports.useState(false);
  const [filteredEmployees, setFilteredEmployees] = reactExports.useState([]);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const itemsPerPage = 10;
  const [totalItems, setTotalItems] = reactExports.useState(0);
  reactExports.useEffect(() => {
    fetchDepartments();
    fetchEmployees();
    fetchConfigurations(currentPage);
  }, []);
  reactExports.useEffect(() => {
    if (employees.length > 0 && searchTerm) {
      const filtered = employees.filter(
        (emp) => emp.staff_name.toLowerCase().includes(searchTerm.toLowerCase()) || emp.job_role.toLowerCase().includes(searchTerm.toLowerCase())
      );
      setFilteredEmployees(filtered);
    } else {
      setFilteredEmployees(employees);
    }
  }, [searchTerm, employees]);
  const fetchDepartments = async () => {
    try {
      setLoading2(true);
      const depts = await APIService.getAllDepartments();
      setDepartments(depts);
    } catch (error2) {
      console.error("Error fetching departments:", error2);
      Swal.fire("Error", "Failed to fetch departments", "error");
    } finally {
      setLoading2(false);
    }
  };
  const fetchEmployees = async () => {
    try {
      setLoading2(true);
      const emps = await APIService.getAllEmployees();
      setEmployees(emps);
      setFilteredEmployees(emps);
    } catch (error2) {
      console.error("Error fetching employees:", error2);
      Swal.fire("Error", "Failed to fetch employees", "error");
    } finally {
      setLoading2(false);
    }
  };
  const fetchConfigurations = async (page = 1) => {
    try {
      setLoading2(true);
      const skip = (page - 1) * itemsPerPage;
      const limit = itemsPerPage;
      const configs = await APIService.getAppraisalConfigurations(null, skip, limit);
      console.log("API Response for configurations:", configs);
      if (Array.isArray(configs)) {
        setConfigurations(configs);
        console.log("Set configurations array:", configs.length, "items");
        if (page === 1) {
          if (configs.length < limit) {
            setTotalItems(configs.length);
          } else {
            setTotalItems(Math.max(limit * 2, totalItems));
          }
        }
      } else if (configs && configs.configurations && Array.isArray(configs.configurations)) {
        setConfigurations(configs.configurations);
        console.log("Set configurations from nested property:", configs.configurations.length, "items");
        setTotalItems(configs.total || configs.configurations.length);
      } else if (configs && typeof configs === "object") {
        setConfigurations([configs]);
        console.log("Set configuration from single object");
        setTotalItems(1);
      } else {
        console.warn("Unexpected API response format:", configs);
        setConfigurations([]);
        setTotalItems(0);
      }
    } catch (error2) {
      console.error("Error fetching configurations:", error2);
      Swal.fire("Error", "Failed to fetch configurations", "error");
    } finally {
      setLoading2(false);
    }
  };
  const handlePageChange = (pageNumber) => {
    setCurrentPage(pageNumber);
    fetchConfigurations(pageNumber);
  };
  const totalPages = Math.ceil(totalItems / itemsPerPage);
  const handleInputChange = (e2) => {
    const { name, value, type, checked } = e2.target;
    setConfigForm((prev) => ({
      ...prev,
      [name]: type === "checkbox" ? checked : value
    }));
  };
  const handleDepartmentChange = (e2) => {
    const selectedDept = e2.target.value;
    setSelectedDeptCodes(selectedDept ? [selectedDept] : []);
    setConfigForm((prev) => ({
      ...prev,
      selectedDepartments: selectedDept ? [selectedDept] : []
    }));
  };
  const toggleEmployeeModal = () => {
    setShowEmployeeModal(!showEmployeeModal);
    setSearchTerm("");
  };
  const handleEmployeeSelection = (empId) => {
    if (selectedEmployeeIds.includes(empId)) {
      setSelectedEmployeeIds((prev) => prev.filter((id) => id !== empId));
    } else {
      setSelectedEmployeeIds((prev) => [...prev, empId]);
    }
  };
  const saveSelectedEmployees = () => {
    const selectedEmps = employees.filter((emp) => selectedEmployeeIds.includes(emp.employeeID));
    setConfigForm((prev) => ({
      ...prev,
      selectedEmployees: selectedEmps
    }));
    toggleEmployeeModal();
  };
  const handleSubmit = async (e2) => {
    e2.preventDefault();
    if (!validateForm()) {
      return;
    }
    try {
      setLoading2(true);
      const formData = {
        // Required base fields
        title: configForm.title,
        description: configForm.description || "",
        start_date: configForm.startDate,
        end_date: configForm.endDate,
        include_self_assessment: configForm.includeSelfAssessment,
        include_manager_assessment: configForm.includeManagerAssessment,
        include_peer_assessment: configForm.includePeerAssessment,
        include_subordinate_assessment: configForm.includeSubordinateAssessment,
        // Lists for departments and employees
        departments: selectedDeptCodes,
        employees: selectedEmployeeIds
      };
      console.log("Sending to API:", formData);
      let result;
      if (isEditMode) {
        result = await APIService.updateAppraisalConfiguration(currentConfigId, formData);
        Swal.fire("Success", "Configuration updated successfully", "success");
      } else {
        result = await APIService.createAppraisalConfiguration(formData);
        Swal.fire("Success", "Configuration created successfully", "success");
      }
      resetForm();
      fetchConfigurations();
    } catch (error2) {
      console.error("Error saving configuration:", error2);
      let errorMessage = "Failed to save configuration";
      if (error2.response && error2.response.data) {
        if (error2.response.data.detail) {
          if (Array.isArray(error2.response.data.detail)) {
            errorMessage += ": " + error2.response.data.detail.map(
              (err) => `${err.loc.join(".")} - ${err.msg}`
            ).join(", ");
          } else {
            errorMessage += ": " + error2.response.data.detail;
          }
        }
      }
      Swal.fire("Error", errorMessage, "error");
    } finally {
      setLoading2(false);
    }
  };
  const validateForm = () => {
    if (!configForm.title.trim()) {
      Swal.fire("Error", "Title is required", "error");
      return false;
    }
    if (!configForm.startDate || !configForm.endDate) {
      Swal.fire("Error", "Start and end dates are required", "error");
      return false;
    }
    if (new Date(configForm.startDate) >= new Date(configForm.endDate)) {
      Swal.fire("Error", "End date must be after start date", "error");
      return false;
    }
    if (selectedDeptCodes.length === 0 && selectedEmployeeIds.length === 0) {
      Swal.fire("Error", "Please select at least one department or employee", "error");
      return false;
    }
    return true;
  };
  const resetForm = () => {
    setConfigForm({
      title: "",
      description: "",
      startDate: "",
      endDate: "",
      appraisalType: "360",
      includeSelfAssessment: true,
      includeManagerAssessment: true,
      includePeerAssessment: true,
      includeSubordinateAssessment: true,
      selectedDepartments: [],
      selectedEmployees: []
    });
    setSelectedDeptCodes([]);
    setSelectedEmployeeIds([]);
    setIsEditMode(false);
    setCurrentConfigId(null);
  };
  const handleEditConfig = (event, config2) => {
    event.preventDefault();
    setLoading2(true);
    window.scrollTo({ top: 0, behavior: "smooth" });
    setIsEditMode(true);
    setCurrentConfigId(config2.sno);
    setConfigForm({
      title: config2.title,
      description: config2.description || "",
      startDate: config2.start_date,
      endDate: config2.end_date,
      appraisalType: config2.appraisal_type || "360",
      includeSelfAssessment: config2.include_self_assessment !== false,
      includeManagerAssessment: config2.include_manager_assessment !== false,
      includePeerAssessment: config2.include_peer_assessment !== false,
      includeSubordinateAssessment: config2.include_subordinate_assessment !== false,
      selectedDepartments: config2.departments || [],
      selectedEmployees: config2.employees || []
    });
    setSelectedDeptCodes(config2.departments || []);
    setSelectedEmployeeIds(config2.employees || []);
    setLoading2(false);
    Swal.fire({
      title: "Edit Mode",
      text: `Now editing "${config2.title}" configuration`,
      icon: "info",
      toast: true,
      position: "top-end",
      showConfirmButton: false,
      timer: 3e3
    });
  };
  const handleDeleteConfig = (config2) => {
    const configTitle = config2.title || "this configuration";
    Swal.fire({
      title: "Are you sure?",
      text: `Do you want to delete "${configTitle}"? This action cannot be undone.`,
      icon: "warning",
      showCancelButton: true,
      confirmButtonColor: "#d33",
      cancelButtonColor: "#3085d6",
      confirmButtonText: "Yes, delete it!"
    }).then(async (result) => {
      if (result.isConfirmed) {
        setLoading2(true);
        try {
          await APIService.deleteAppraisalConfiguration(config2.sno);
          Swal.fire({
            title: "Deleted!",
            text: `${configTitle} has been deleted successfully.`,
            icon: "success",
            timer: 2e3,
            showConfirmButton: false
          });
          await fetchConfigurations();
          if (isEditMode && currentConfigId === config2.sno) {
            resetForm();
          }
        } catch (error2) {
          console.error("Error deleting configuration:", error2);
          Swal.fire("Error", "Failed to delete configuration. Please try again.", "error");
        } finally {
          setLoading2(false);
        }
      }
    });
  };
  const handleCancelEdit = () => {
    setIsEditMode(false);
    setCurrentConfigId(null);
    resetForm();
    Swal.fire({
      title: "Edit Cancelled",
      text: "Changes have been discarded",
      icon: "info",
      toast: true,
      position: "top-end",
      showConfirmButton: false,
      timer: 2e3
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container-fluid mt-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4", children: "Configure 360-degree Appraisal" }),
    loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center my-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { color: "primary" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: isEditMode ? "Edit Configuration" : "New Configuration" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardBody, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { onSubmit: handleSubmit, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { for: "title", children: "Title" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                type: "text",
                id: "title",
                name: "title",
                value: configForm.title,
                onChange: handleInputChange,
                placeholder: "Enter appraisal title",
                required: true
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { for: "description", children: "Description" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                type: "textarea",
                id: "description",
                name: "description",
                value: configForm.description,
                onChange: handleInputChange,
                placeholder: "Enter description",
                rows: "3"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { for: "startDate", children: "Start Date" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  type: "date",
                  id: "startDate",
                  name: "startDate",
                  value: configForm.startDate,
                  onChange: handleInputChange,
                  required: true
                }
              )
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { for: "endDate", children: "End Date" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  type: "date",
                  id: "endDate",
                  name: "endDate",
                  value: configForm.endDate,
                  onChange: handleInputChange,
                  required: true
                }
              )
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { tag: "fieldset", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("legend", { className: "col-form-label", children: "Assessment Types" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormGroup, { check: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { check: true, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  type: "checkbox",
                  name: "includeSelfAssessment",
                  checked: configForm.includeSelfAssessment,
                  onChange: handleInputChange
                }
              ),
              " ",
              "Self Assessment"
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormGroup, { check: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { check: true, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  type: "checkbox",
                  name: "includeManagerAssessment",
                  checked: configForm.includeManagerAssessment,
                  onChange: handleInputChange
                }
              ),
              " ",
              "Manager Assessment"
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormGroup, { check: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { check: true, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  type: "checkbox",
                  name: "includePeerAssessment",
                  checked: configForm.includePeerAssessment,
                  onChange: handleInputChange
                }
              ),
              " ",
              "Peer Assessment"
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormGroup, { check: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { check: true, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  type: "checkbox",
                  name: "includeSubordinateAssessment",
                  checked: configForm.includeSubordinateAssessment,
                  onChange: handleInputChange
                }
              ),
              " ",
              "Subordinate Assessment"
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { for: "departmentSelect", children: "Select Department" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Input,
              {
                type: "select",
                id: "departmentSelect",
                name: "selectedDepartment",
                value: selectedDeptCodes.length > 0 ? selectedDeptCodes[0] : "",
                onChange: handleDepartmentChange,
                className: "form-control",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Select a department..." }),
                  departments.map((dept) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: dept.deptcode, children: dept.deptname }, dept.deptcode))
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: "Selected Employees" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between align-items-center mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                selectedEmployeeIds.length,
                " employee(s) selected"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  color: "secondary",
                  size: "sm",
                  onClick: toggleEmployeeModal,
                  children: "Select Employees"
                }
              )
            ] }),
            selectedEmployeeIds.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "selected-employees", style: { maxHeight: "150px", overflowY: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "list-group", children: employees.filter((emp) => selectedEmployeeIds.includes(emp.employeeID)).map((emp) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "list-group-item d-flex justify-content-between align-items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: emp.staff_name }),
                " - ",
                emp.job_role
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  size: "sm",
                  color: "danger",
                  onClick: () => handleEmployeeSelection(emp.employeeID),
                  children: "Remove"
                }
              )
            ] }, emp.employeeID)) }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between mt-4", children: [
            isEditMode && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { type: "button", color: "secondary", onClick: handleCancelEdit, children: "Cancel Edit" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { type: "submit", color: "primary", disabled: loading, children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "sm" }) : isEditMode ? "Update Configuration" : "Save Configuration" })
          ] })
        ] }) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Existing Configurations" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardBody, { children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { color: "primary" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2", children: "Loading configurations..." })
        ] }) : configurations.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { color: "info", children: "No configurations found. Create your first configuration." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "table-responsive", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { striped: true, bordered: true, hover: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Title" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Period" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Status" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Actions" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: configurations.map((config2) => {
              const status = getConfigurationStatus(config2.start_date, config2.end_date);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: config2.title }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                  new Date(config2.start_date).toLocaleDateString(),
                  " - ",
                  new Date(config2.end_date).toLocaleDateString()
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    className: `badge ${{
                      Active: "bg-success",
                      Upcoming: "bg-info",
                      Completed: "bg-secondary"
                    }[status]}`,
                    children: status
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex gap-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button$1,
                    {
                      color: "info",
                      size: "sm",
                      title: "View details",
                      onClick: () => {
                        Swal.fire({
                          title: config2.title,
                          html: `
                                        <div class="text-start">
                                          <p><strong>Description:</strong> ${config2.description || "N/A"}</p>
                                          <p><strong>Period:</strong> ${new Date(config2.start_date).toLocaleDateString()} - ${new Date(config2.end_date).toLocaleDateString()}</p>
                                          <p><strong>Type:</strong> ${config2.appraisalType || "360"}</p>
                                          <p><strong>Includes:</strong> 
                                            ${config2.include_self_assessment ? "Self Assessment, " : ""}
                                            ${config2.include_manager_assessment ? "Manager Assessment, " : ""}
                                            ${config2.include_peer_assessment ? "Peer Assessment, " : ""}
                                            ${config2.include_subordinate_assessment ? "Subordinate Assessment" : ""}
                                          </p>
                                        </div>
                                      `,
                          icon: "info",
                          confirmButtonText: "Close"
                        });
                      },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "bi bi-eye" })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button$1,
                    {
                      color: "warning",
                      size: "sm",
                      title: "Edit configuration",
                      onClick: (e2) => handleEditConfig(e2, config2),
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "bi bi-pencil" })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button$1,
                    {
                      color: "danger",
                      size: "sm",
                      title: "Delete configuration",
                      onClick: () => handleDeleteConfig(config2),
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "bi bi-trash" })
                    }
                  )
                ] }) })
              ] }, config2.sno);
            }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Pagination$1, { className: "pagination justify-content-end mt-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationItem, { disabled: currentPage === 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationLink, { onClick: () => handlePageChange(currentPage - 1), children: "Previous" }) }),
            [...Array(totalPages)].map((_2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationItem, { active: currentPage === index2 + 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationLink, { onClick: () => handlePageChange(index2 + 1), children: index2 + 1 }) }, index2)),
            /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationItem, { disabled: currentPage === totalPages, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationLink, { onClick: () => handlePageChange(currentPage + 1), children: "Next" }) })
          ] })
        ] }) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Modal$1, { isOpen: showEmployeeModal, toggle: toggleEmployeeModal, size: "lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ModalHeader, { toggle: toggleEmployeeModal, children: "Select Employees" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalBody, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            type: "text",
            placeholder: "Search employees...",
            value: searchTerm,
            onChange: (e2) => setSearchTerm(e2.target.value),
            className: "mb-3"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { maxHeight: "400px", overflowY: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { striped: true, bordered: true, hover: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { style: { width: "50px" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Name" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Job Role" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Department" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Role" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
            filteredEmployees.map((emp) => {
              const dept = departments.find((d2) => d2.deptcode === emp.deptcode);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    type: "checkbox",
                    checked: selectedEmployeeIds.includes(emp.employeeID),
                    onChange: () => handleEmployeeSelection(emp.employeeID)
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: emp.staff_name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: emp.job_role }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: dept ? dept.deptname : emp.deptcode }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: emp.userType })
              ] }, emp.employeeID);
            }),
            filteredEmployees.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("td", { colSpan: "5", className: "text-center", children: "No employees found" }) })
          ] })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalFooter, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "secondary", onClick: toggleEmployeeModal, children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "primary", onClick: saveSelectedEmployees, children: "Save Selection" })
      ] })
    ] })
  ] });
};
var define_process_env_default = {};
const PerformanceAssessment = () => {
  const dispatch = useDispatch();
  const { configId } = useParams();
  const navigate = useNavigate();
  const [loading, setLoading2] = reactExports.useState(true);
  const [appraisalConfig, setAppraisalConfig] = reactExports.useState(null);
  const [assessments, setAssessments] = reactExports.useState([]);
  const [criteria, setCriteria] = reactExports.useState([]);
  const [activeTab, setActiveTab] = reactExports.useState("new");
  const [employeeNames, setEmployeeNames] = reactExports.useState({});
  const [employees, setEmployees] = reactExports.useState([]);
  const [selectedEmployeeId, setSelectedEmployeeId] = reactExports.useState(null);
  const [showEmployeeModal, setShowEmployeeModal] = reactExports.useState(false);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [filteredEmployees, setFilteredEmployees] = reactExports.useState([]);
  const [assessmentType, setAssessmentType] = reactExports.useState("self");
  const [assessmentForm, setAssessmentForm] = reactExports.useState({
    employeeId: "",
    assessmentType: "self",
    comments: {},
    generalComment: "",
    ratings: {},
    criteriaMap: {}
    // Store mapping between criteria names and IDs
  });
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const [itemsPerPage] = reactExports.useState(10);
  const [totalItems, setTotalItems] = reactExports.useState(0);
  const [selectedCriteriaIds, setSelectedCriteriaIds] = reactExports.useState([]);
  const [employeeCache, setEmployeeCache] = reactExports.useState({});
  const [showViewModal, setShowViewModal] = reactExports.useState(false);
  const [selectedAssessment, setSelectedAssessment] = reactExports.useState(null);
  const [viewAssessmentLoading, setViewAssessmentLoading] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (employees.length > 0) {
      if (!searchTerm.trim()) {
        setFilteredEmployees(employees);
      } else {
        const filtered = employees.filter((employee) => {
          const staffName = (employee.staff_name || "").toLowerCase();
          const name = (employee.name || "").toLowerCase();
          const firstName = (employee.firstName || "").toLowerCase();
          const lastName = (employee.lastName || "").toLowerCase();
          const jobRole = (employee.job_role || employee.position || employee.designation || "").toLowerCase();
          const searchLower = searchTerm.toLowerCase();
          return staffName.includes(searchLower) || name.includes(searchLower) || firstName.includes(searchLower) || lastName.includes(searchLower) || jobRole.includes(searchLower) || `${firstName} ${lastName}`.includes(searchLower);
        });
        setFilteredEmployees(filtered);
      }
    }
  }, [searchTerm, employees]);
  reactExports.useEffect(() => {
    if (!window.bootstrap && typeof document !== "undefined") {
      const script = document.createElement("script");
      script.src = "https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js";
      script.integrity = "sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4";
      script.crossOrigin = "anonymous";
      document.body.appendChild(script);
      return () => {
        if (script.parentNode) {
          script.parentNode.removeChild(script);
        }
      };
    }
  }, []);
  reactExports.useEffect(() => {
    const fetchAllEmployeeDetails = async () => {
      if (assessments && assessments.length > 0) {
        console.log("Fetching employee details for all assessments");
        const uniqueEmployeeIds = /* @__PURE__ */ new Set();
        assessments.forEach((assessment) => {
          const employeeId = assessment.employee_id;
          if (employeeId && !employeeNames[employeeId]) {
            uniqueEmployeeIds.add(employeeId);
          }
        });
        console.log("Unique employee IDs to fetch:", Array.from(uniqueEmployeeIds));
        for (const employeeId of uniqueEmployeeIds) {
          await fetchEmployeeDetails(employeeId);
        }
      }
    };
    fetchAllEmployeeDetails();
  }, [assessments, employeeNames]);
  reactExports.useEffect(() => {
    if (configId && configId !== ":configId" && configId !== "undefined") {
      console.log("Config ID or assessment type changed, fetching criteria...");
      fetchCriteria(assessmentType).then((fetchedCriteria) => {
        console.log("Criteria fetched successfully:", (fetchedCriteria == null ? void 0 : fetchedCriteria.length) || "none");
        if (selectedCriteriaIds.length === 0 && criteria.length > 0) {
          const initialSelected = criteria.slice(0, 1).map((c2) => c2.id || c2._id || c2.sno || `criterion_${criteria.indexOf(c2) + 1}`).filter(Boolean);
          console.log("Setting initial selected criteria IDs:", initialSelected);
          setSelectedCriteriaIds(initialSelected);
        }
      }).catch((error2) => {
        console.error("Error fetching criteria:", error2);
        if (criteria.length === 0) {
          console.log("Using default criteria as fallback");
          setCriteria(defaultCriteria);
          const initialSelected = defaultCriteria.slice(0, 1).map((c2) => c2.id);
          setSelectedCriteriaIds(initialSelected);
        }
      });
    }
  }, [assessmentType, configId]);
  reactExports.useEffect(() => {
    const fetchEmployeeNames = async () => {
      if (!assessments.length) return;
      const employeeIds = [...new Set(assessments.map((assessment) => assessment.employee_id).filter((id) => id && !employeeNames[id]))];
      if (!employeeIds.length) return;
      console.log(`Fetching names for ${employeeIds.length} employees...`);
      const newEmployeeNames = { ...employeeNames };
      const fetchEmployeeDirectly = async (employeeId) => {
        var _a2, _b, _c;
        try {
          console.log(`Direct fetch for employee ID: ${employeeId}`);
          const token = localStorage.getItem("auth_token") || sessionStorage.getItem("auth_token") || "";
          console.log("Using auth token:", token ? "Token exists" : "No token found");
          const apiUrl = `${define_process_env_default.REACT_APP_API_URL || ""}/api/employee/${employeeId}`;
          console.log("Calling API endpoint:", apiUrl);
          const response = await axios.get(apiUrl, {
            headers: {
              Authorization: `Bearer ${token}`
            }
          });
          console.log(" API Response Status:", response.status);
          console.log(" Direct employee data full response:", response);
          console.log(" Direct employee data fields:", response.data ? Object.keys(response.data) : "No data");
          console.log(" staff_name field:", ((_a2 = response.data) == null ? void 0 : _a2.staff_name) || "Not found");
          console.log(" name fields:", (_b = response.data) == null ? void 0 : _b.firstName, (_c = response.data) == null ? void 0 : _c.lastName);
          return response.data;
        } catch (error2) {
          console.error(`Direct fetch error for employee ID ${employeeId}:`, error2);
          return null;
        }
      };
      const promises = employeeIds.map(async (id) => {
        try {
          console.log(`Fetching employee details for ID: ${id}`);
          const employee = await fetchEmployeeDirectly(id);
          console.log("Employee data response:", employee);
          if (employee && employee.staff_name) {
            console.log(`Found employee ${employee.staff_name} for ID: ${id}`);
            newEmployeeNames[id] = employee.staff_name;
          } else {
            console.log(`No name found for employee ID: ${id}`);
            newEmployeeNames[id] = `Employee ID: ${id}`;
          }
        } catch (error2) {
          console.error(`Error fetching employee ID ${id}:`, error2);
          newEmployeeNames[id] = `Employee ID: ${id}`;
        }
        return id;
      });
      await Promise.all(promises);
      console.log("Updating employee names state:", newEmployeeNames);
      setEmployeeNames(newEmployeeNames);
    };
    fetchEmployeeNames();
  }, [assessments, employeeNames, dispatch]);
  const criteriaModalRef = reactExports.useRef(null);
  const openCriteriaModal = () => {
    console.log("Opening criteria modal");
    if (criteria.length === 0) {
      console.log("No criteria loaded, fetching criteria...");
      fetchCriteria(assessmentType).then(() => {
        console.log("Criteria fetched for modal");
      }).catch((error2) => {
        console.error("Error fetching criteria for modal:", error2);
        const defaultCriteriaList = [
          { id: "criterion_1", name: "Communication Skills", description: "Ability to convey information clearly and effectively." },
          { id: "criterion_2", name: "Problem Solving", description: "Ability to identify and resolve issues efficiently." },
          { id: "criterion_3", name: "Teamwork", description: "Ability to collaborate with others towards common goals." },
          { id: "criterion_4", name: "Leadership", description: "Ability to guide and influence others positively." },
          { id: "criterion_5", name: "Initiative", description: "Ability to take action without being prompted." },
          { id: "criterion_6", name: "Adaptability", description: "Ability to adjust to new conditions and requirements." }
        ];
        console.log("Using default criteria as fallback");
        setCriteria(defaultCriteriaList);
      }).finally(() => {
        if (selectedCriteriaIds.length === 0 && criteria.length > 0) {
          const initialSelected = criteria.slice(0, 1).map((c2) => c2.id || c2._id || c2.sno || `criterion_${criteria.indexOf(c2) + 1}`).filter(Boolean);
          console.log("Setting initial selected criteria:", initialSelected);
          setSelectedCriteriaIds(initialSelected);
        }
      });
    } else {
      console.log("Criteria already loaded for modal:", criteria.length, "items");
      if (selectedCriteriaIds.length === 0) {
        const initialSelected = criteria.slice(0, 1).map((c2) => c2.id || c2._id || c2.sno || `criterion_${criteria.indexOf(c2) + 1}`).filter(Boolean);
        console.log("Setting initial selected criteria:", initialSelected);
        setSelectedCriteriaIds(initialSelected);
      }
    }
    try {
      if (window.bootstrap) {
        const modal = new window.bootstrap.Modal(criteriaModalRef.current);
        modal.show();
        console.log("Modal shown successfully using Bootstrap");
      } else if (window.jQuery) {
        window.jQuery(criteriaModalRef.current).modal("show");
        console.log("Modal shown successfully using jQuery");
      } else {
        const modalElement = criteriaModalRef.current;
        if (modalElement) {
          modalElement.style.display = "block";
          modalElement.classList.add("show");
          document.body.classList.add("modal-open");
          let backdrop = document.querySelector(".modal-backdrop");
          if (!backdrop) {
            backdrop = document.createElement("div");
            backdrop.className = "modal-backdrop fade show";
            document.body.appendChild(backdrop);
          }
          console.log("Modal shown successfully using DOM manipulation");
        }
      }
    } catch (error2) {
      console.error("Error showing modal:", error2);
      alert("Please select criteria from the list below.");
    }
  };
  const closeCriteriaModal = () => {
    console.log("Closing criteria modal");
    try {
      if (window.bootstrap && criteriaModalRef.current) {
        const modalInstance = window.bootstrap.Modal.getInstance(criteriaModalRef.current);
        if (modalInstance) {
          modalInstance.hide();
          console.log("Modal hidden successfully using Bootstrap");
        } else {
          console.warn("No Bootstrap modal instance found, trying fallback");
          const modalElement = criteriaModalRef.current;
          if (modalElement) {
            modalElement.style.display = "none";
            modalElement.classList.remove("show");
            document.body.classList.remove("modal-open");
            const backdrop = document.querySelector(".modal-backdrop");
            if (backdrop) backdrop.parentNode.removeChild(backdrop);
            console.log("Modal hidden using DOM manipulation fallback");
          }
        }
      } else if (window.jQuery) {
        window.jQuery(criteriaModalRef.current).modal("hide");
        console.log("Modal hidden successfully using jQuery");
      } else {
        const modalElement = criteriaModalRef.current;
        if (modalElement) {
          modalElement.style.display = "none";
          modalElement.classList.remove("show");
          document.body.classList.remove("modal-open");
          const backdrop = document.querySelector(".modal-backdrop");
          if (backdrop) {
            backdrop.parentNode.removeChild(backdrop);
          }
          console.log("Modal hidden using DOM manipulation");
        }
      }
    } catch (error2) {
      console.error("Error closing modal:", error2);
    }
  };
  reactExports.useEffect(() => {
    if (!configId || configId === ":configId" || configId === "undefined") {
      const fetchActiveConfigurations = async () => {
        try {
          setLoading2(true);
          const allConfigs = await APIService.getAppraisalConfigurations(dispatch);
          const now = /* @__PURE__ */ new Date();
          let activeConfigs = allConfigs.filter((config2) => {
            const startDate = new Date(config2.start_date);
            const endDate = new Date(config2.end_date);
            return startDate <= now && now <= endDate;
          });
          if (activeConfigs.length === 0) {
            const ninetyDaysAgo = /* @__PURE__ */ new Date();
            ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
            activeConfigs = allConfigs.filter((config2) => {
              const endDate = new Date(config2.end_date);
              return endDate > ninetyDaysAgo && endDate <= now;
            });
            activeConfigs.sort((a2, b2) => new Date(b2.end_date) - new Date(a2.end_date));
          }
          if (configId && activeConfigs && activeConfigs.length > 0) {
            navigate(`/performance-assessment/${activeConfigs[0].sno}`);
          } else if (configId) {
            setActiveTab("new");
            Swal.fire({
              title: "No Active Configurations",
              text: "There are no active appraisal configurations, but you can still create a new assessment.",
              icon: "info",
              showConfirmButton: false,
              timer: 3e3
            });
          }
        } catch (error2) {
          console.error("Error fetching active configurations:", error2);
          Swal.fire({
            title: "Error",
            text: "Failed to fetch active configurations. Please try again later.",
            icon: "error",
            showConfirmButton: false,
            timer: 3e3
          });
        } finally {
          setLoading2(false);
        }
      };
      fetchActiveConfigurations();
    }
  }, [configId, navigate, dispatch]);
  reactExports.useEffect(() => {
    if (searchTerm.trim() !== "") {
      const filtered = employees.filter(
        (emp) => {
          var _a2, _b;
          return ((_a2 = emp.name) == null ? void 0 : _a2.toLowerCase().includes(searchTerm.toLowerCase())) || ((_b = emp.job_role) == null ? void 0 : _b.toLowerCase().includes(searchTerm.toLowerCase()));
        }
      );
      setFilteredEmployees(filtered);
    } else {
      setFilteredEmployees(employees);
    }
  }, [searchTerm, employees]);
  const defaultCriteria = [
    {
      id: "default_1",
      name: "Communication Skills",
      description: "Ability to convey information clearly and effectively."
    },
    {
      id: "default_2",
      name: "Problem Solving",
      description: "Ability to identify and resolve issues efficiently."
    },
    {
      id: "default_3",
      name: "Teamwork",
      description: "Ability to collaborate with others towards common goals."
    },
    {
      id: "default_4",
      name: "Leadership",
      description: "Ability to guide and influence others positively."
    },
    {
      id: "default_5",
      name: "Initiative",
      description: "Ability to take action without being prompted."
    },
    {
      id: "default_6",
      name: "Adaptability",
      description: "Ability to adjust to new conditions and requirements."
    },
    {
      id: "default_7",
      name: "Time Management",
      description: "Ability to use time effectively and productively."
    },
    {
      id: "default_8",
      name: "Quality of Work",
      description: "Consistency and accuracy in completing tasks."
    },
    {
      id: "default_9",
      name: "Technical Skills",
      description: "Proficiency in technical skills required for the role."
    },
    {
      id: "default_10",
      name: "Customer Focus",
      description: "Dedication to meeting customer needs and expectations."
    }
  ];
  const toggleCriteriaSelection = (criterionId) => {
    if (!criterionId) {
      console.warn("Attempted to toggle selection with invalid criterionId:", criterionId);
      return;
    }
    console.log("Toggling criterion selection:", criterionId);
    setSelectedCriteriaIds((prevSelected) => {
      if (prevSelected.includes(criterionId)) {
        console.log("Removing criterion from selection:", criterionId);
        return prevSelected.filter((id) => id !== criterionId);
      } else {
        console.log("Adding criterion to selection:", criterionId);
        return [...prevSelected, criterionId];
      }
    });
  };
  const toggleAllCriteria = () => {
    if (criteria.length === 0) {
      console.warn("No criteria available to toggle selection");
      return;
    }
    console.log("Toggling all criteria selection");
    const allSelected = criteria.every((criterion) => {
      const criterionId = criterion.id || criterion._id || criterion.sno;
      return criterionId && selectedCriteriaIds.includes(criterionId);
    });
    if (allSelected) {
      console.log("Deselecting all criteria");
      setSelectedCriteriaIds([]);
    } else {
      const allIds = criteria.map((criterion) => criterion.id || criterion._id || criterion.sno).filter(Boolean);
      console.log("Selecting all criteria:", allIds);
      setSelectedCriteriaIds(allIds);
    }
  };
  const getFilteredCriteria = () => {
    if (!criteria || criteria.length === 0) {
      console.log("No criteria available for filtering");
      return [];
    }
    if (selectedCriteriaIds.length === 0) {
      console.log("No criteria selected, showing first 1 by default");
      return criteria.slice(0, 3);
    } else {
      const filtered = criteria.filter((criterion) => {
        const criterionId = criterion.id || criterion._id || criterion.sno;
        return selectedCriteriaIds.includes(criterionId);
      });
      console.log("Filtered criteria:", filtered);
      return filtered.length > 0 ? filtered : criteria.slice(0, 1);
    }
  };
  const fetchCriteria = async (type = null) => {
    try {
      const typeToUse = type || assessmentType || "self";
      console.log("Fetching criteria for type:", typeToUse);
      const criteriaFromApi = await APIService.getAllPcriteria(dispatch);
      console.log("API returned criteria:", criteriaFromApi);
      const normalizedCriteria = criteriaFromApi.map((criterion, index2) => {
        return {
          id: criterion.id || criterion._id || criterion.sno || `criterion_${index2 + 1}`,
          name: criterion.criteriaName || criterion.name || criterion.title || criterion.criteria_name || `Criterion ${index2 + 1}`,
          description: criterion.description || criterion.details || criterion.criteria_description || ""
        };
      });
      setCriteria(normalizedCriteria);
      console.log("Normalized criteria for display:", normalizedCriteria);
      if (selectedCriteriaIds.length === 0 && normalizedCriteria && normalizedCriteria.length > 0) {
        const defaultSelected = normalizedCriteria.slice(0, 1).map((criterion) => criterion.id);
        setSelectedCriteriaIds(defaultSelected);
        console.log("Default selected criteria IDs:", defaultSelected);
      }
      const initialRatings = {};
      const initialComments = {};
      normalizedCriteria.forEach((criterion) => {
        const criterionId = criterion.id;
        if (criterionId && !assessmentForm.ratings[criterionId]) {
          initialRatings[criterionId] = 0;
          initialComments[criterionId] = "";
        }
      });
      setAssessmentForm((prev) => ({
        ...prev,
        ratings: { ...prev.ratings, ...initialRatings },
        comments: { ...prev.comments, ...initialComments }
      }));
    } catch (error2) {
      console.error("Error fetching criteria:", error2);
      console.warn("Using default criteria due to fetch error");
      setCriteria(defaultCriteria);
      const normalizedDefaultCriteria = defaultCriteria.map((criterion, index2) => ({
        id: criterion.id || `default_${index2}`,
        name: criterion.name || `Default Criterion ${index2 + 1}`,
        description: criterion.description || ""
      }));
      setCriteria(normalizedDefaultCriteria);
      const initialRatings = {};
      const initialComments = {};
      normalizedDefaultCriteria.forEach((criterion) => {
        initialRatings[criterion.id] = 0;
        initialComments[criterion.id] = "";
      });
      setAssessmentForm((prev) => ({
        ...prev,
        ratings: { ...prev.ratings, ...initialRatings },
        comments: { ...prev.comments, ...initialComments }
      }));
      if (selectedCriteriaIds.length === 0) {
        const defaultSelected = normalizedDefaultCriteria.slice(0, 1).map((criterion) => criterion.id).filter(Boolean);
        setSelectedCriteriaIds(defaultSelected);
      }
    }
  };
  const fetchEmployees = async () => {
    try {
      setLoading2(true);
      const result = await APIService.getAllEmployees(dispatch);
      setEmployees(result);
      setFilteredEmployees(result);
    } catch (error2) {
      console.error("Error fetching employees:", error2);
      Swal.fire("Error", "Failed to fetch employees", "error");
    } finally {
      setLoading2(false);
    }
  };
  const getMockAssessments = (tabStatus) => {
    console.warn("MOCK DATA DISABLED - Using real database data only");
    return [];
  };
  const fetchEmployeeDetails = async (employeeId) => {
    if (!employeeId) return null;
    if (employeeCache[employeeId]) {
      console.log(`Using cached employee data for ID: ${employeeId}`);
      return employeeCache[employeeId];
    }
    try {
      console.log(`Fetching employee details for ID: ${employeeId}`);
      const employeeData = await APIService.getEmployeeById(employeeId);
      setEmployeeCache((prev) => ({
        ...prev,
        [employeeId]: employeeData
      }));
      if (employeeData && employeeData.staff_name) {
        setEmployeeNames((prev) => ({
          ...prev,
          [employeeId]: employeeData.staff_name
        }));
      }
      return employeeData;
    } catch (error2) {
      console.error(`Error fetching employee details for ID ${employeeId}:`, error2);
      return null;
    }
  };
  const fetchAssessments = async (page = 1) => {
    try {
      setLoading2(true);
      const skip = (page - 1) * itemsPerPage;
      let statusValue = null;
      if (activeTab === "pending") {
        statusValue = "pending";
      } else if (activeTab === "completed") {
        statusValue = "completed";
      }
      console.log(`Fetching assessments for tab: ${activeTab} with status filter: ${statusValue || "all"}`);
      console.log(`API endpoint will be called with config_id=${configId}, status=${statusValue || "all"}`);
      const queryParams = new URLSearchParams();
      queryParams.append("skip", skip);
      queryParams.append("limit", itemsPerPage);
      const numericConfigId = parseInt(configId, 10);
      console.log("Using numeric configId:", numericConfigId);
      queryParams.append("config_id", numericConfigId);
      if (statusValue) {
        queryParams.append("status", statusValue);
      }
      const token = localStorage.getItem("auth_token") || sessionStorage.getItem("auth_token");
      console.log("Auth token for debug (first 10 chars):", token ? token.substring(0, 10) + "..." : "No token found");
      try {
        console.log(`Fetching assessments with config_id=${configId}, status=${statusValue || "all"}`);
        const result = await APIService.getAssessments({
          config_id: numericConfigId,
          // Use the numeric ID we validated
          status: statusValue,
          skip,
          limit: itemsPerPage
        }, dispatch);
        console.log("APIService.getAssessments result:", result);
        if (result) {
          console.log("API Response:", result);
          console.log("API Response Structure:", JSON.stringify(result, null, 2));
          const apiAssessments = result.assessments || result.data || (Array.isArray(result) ? result : []);
          console.log("API Assessments Data:", apiAssessments);
          console.log("API Assessments Count:", apiAssessments ? apiAssessments.length : 0);
          console.log("First Assessment Sample:", apiAssessments && apiAssessments.length > 0 ? JSON.stringify(apiAssessments[0], null, 2) : "No data");
          console.log("Using real API data");
          setAssessments(apiAssessments || []);
          setTotalItems(result.total || (apiAssessments ? apiAssessments.length : 0));
          setCurrentPage(page);
        } else {
          console.warn("API returned no result object, using mock data temporarily");
          console.error("API CALL FAILED - Please check network and authentication");
          const mockData = getMockAssessments(activeTab);
          setAssessments(mockData);
          setTotalItems(mockData.length);
          setCurrentPage(page);
        }
      } catch (innerError) {
        console.error("Error fetching assessments:", innerError);
        if (innerError.response && innerError.response.status === 403) {
          console.warn("API returned 403, falling back to mock data:", {
            endpoint: `/api/appraisal/assessments?${queryParams.toString()}`,
            message: "Using mock data as fallback without interrupting user experience"
          });
        } else {
          console.warn(`API error - continuing with mock data for ${activeTab}`);
          if (innerError.message && innerError.message.includes("getToken")) {
            console.warn("Authentication token issue");
            alert("Session expired. Please refresh the page or log in again.");
          }
        }
      }
    } catch (error2) {
      console.error("Error in fetchAssessments outer try block:", error2);
      if (page > 1) {
        Swal.fire("Error", "Failed to fetch assessments", "error");
      } else {
        console.warn("Initial assessment load failed, showing empty list");
        setAssessments([]);
      }
    } finally {
      setLoading2(false);
    }
  };
  const handleAssessmentSubmit = async () => {
    try {
      if (!selectedEmployeeId) {
        Swal.fire("Error", "Please select an employee", "error");
        return;
      }
      if (Object.keys(assessmentForm.ratings).length === 0) {
        Swal.fire("Error", "Please provide ratings for all criteria", "error");
        return;
      }
      setLoading2(true);
      let validAssessmentType = assessmentType;
      const allowedTypes = ["self", "manager", "peer", "subordinate"];
      if (!allowedTypes.includes(assessmentType)) {
        validAssessmentType = "self";
      }
      let staffName = "";
      if (selectedEmployeeId && employeeNames[selectedEmployeeId]) {
        staffName = employeeNames[selectedEmployeeId];
      } else {
        const employee = employeeCache[selectedEmployeeId];
        if (employee && employee.staff_name) {
          staffName = employee.staff_name;
        } else {
          staffName = selectedEmployeeId.toString();
        }
      }
      const cleanRatings = {};
      const cleanComments = {};
      Object.keys(assessmentForm.ratings).forEach((key) => {
        if (!/^[0-9a-f]{24}$/i.test(key)) {
          cleanRatings[key] = assessmentForm.ratings[key];
        }
      });
      Object.keys(assessmentForm.comments || {}).forEach((key) => {
        if (!/^[0-9a-f]{24}$/i.test(key)) {
          cleanComments[key] = assessmentForm.comments[key];
        }
      });
      const formData = {
        config_sno: parseInt(configId, 10),
        // Changed from config_id to config_sno to match backend requirements
        staff_name: staffName,
        // Using staff_name instead of employee_id as required by backend
        type: validAssessmentType,
        responses: cleanRatings,
        // Only using criteria names as keys
        comments: cleanComments,
        // Only using criteria names as keys
        general_comment: assessmentForm.generalComment || "",
        // Separate general comment field
        // Include criteria_map to help backend map criteria names back to IDs if needed
        criteria_map: assessmentForm.criteriaMap || {},
        // Add required fields from backend schema
        last_completed_step: 1,
        progress: (() => {
          const totalCriteria = selectedCriteriaIds.length || Object.keys(assessmentForm.ratings).length || 1;
          const completedCriteria = Object.keys(assessmentForm.ratings).filter(
            (key) => assessmentForm.ratings[key] && assessmentForm.ratings[key] !== "" && assessmentForm.ratings[key] !== null
          ).length;
          return Math.round(completedCriteria / totalCriteria * 100);
        })(),
        status: (() => {
          const totalCriteria = selectedCriteriaIds.length || Object.keys(assessmentForm.ratings).length || 1;
          const completedCriteria = Object.keys(assessmentForm.ratings).filter(
            (key) => assessmentForm.ratings[key] && assessmentForm.ratings[key] !== "" && assessmentForm.ratings[key] !== null
          ).length;
          if (completedCriteria === totalCriteria && completedCriteria > 0) {
            return "completed";
          } else if (completedCriteria > 0) {
            return "in_progress";
          } else {
            return "pending";
          }
        })(),
        is_anonymous: false
      };
      console.log("Submitting assessment data:", formData);
      await APIService.createAssessment(formData, dispatch);
      Swal.fire("Success", "Assessment submitted successfully", "success");
      setSelectedEmployeeId(null);
      setAssessmentForm({
        staff_name: "",
        // Changed from employeeId to staff_name
        assessmentType: "self",
        comments: {},
        generalComment: "",
        ratings: {},
        criteriaMap: {}
      });
      fetchAssessments(1);
    } catch (error2) {
      console.error("Error submitting assessment:", error2);
      Swal.fire("Error", "Failed to submit assessment", "error");
    } finally {
      setLoading2(false);
    }
  };
  const handleEmployeeSelect = (employee) => {
    const staffName = employee.staff_name || employee.employeeID || employee.sno || employee.id || employee._id;
    setSelectedEmployeeId(staffName);
    setAssessmentForm((prev) => ({
      ...prev,
      employeeId: staffName
      // This will actually contain staff_name now
    }));
    setShowEmployeeModal(false);
  };
  const handleRatingChange = (criteriaId, criteriaTitle, ratingValue) => {
    setAssessmentForm((prev) => ({
      ...prev,
      ratings: {
        ...prev.ratings,
        [criteriaTitle]: ratingValue.toString()
        // Store rating as string to match expected format "5" not 5
      },
      // Store a mapping of names to IDs for reference
      criteriaMap: {
        ...prev.criteriaMap,
        [criteriaTitle]: criteriaId
      }
    }));
  };
  const handleCommentChange = (criteriaId, criteriaName, comment) => {
    setAssessmentForm((prev) => ({
      ...prev,
      comments: {
        ...prev.comments,
        [criteriaName]: comment
        // Use criteria name as the key instead of ID
      },
      // Store a mapping of names to IDs for reference
      criteriaMap: {
        ...prev.criteriaMap,
        [criteriaName]: criteriaId
      }
    }));
  };
  const toggleEmployeeModal = () => {
    if (!showEmployeeModal) {
      fetchEmployees();
    }
    setShowEmployeeModal(!showEmployeeModal);
  };
  const toggleTab = (tab) => {
    console.log(`Switching to tab: ${tab} from previous tab: ${activeTab}`);
    setActiveTab(tab);
    setTimeout(() => {
      let statusForAPI = null;
      if (tab === "completed") {
        statusForAPI = "completed";
      } else if (tab === "pending") {
        statusForAPI = "pending";
      }
      console.log(`Fetching assessments with status: ${statusForAPI || "all"}`);
      fetchAssessments(1);
    }, 50);
  };
  const handlePageChange = (page) => {
    if (page >= 1 && page <= Math.ceil(totalItems / itemsPerPage)) {
      fetchAssessments(page);
    }
  };
  const handleViewAssessment = async (assessmentId) => {
    try {
      setViewAssessmentLoading(true);
      const assessment = assessments.find(
        (a2) => a2._id === assessmentId || a2.id === assessmentId || a2.sno === assessmentId
      );
      if (assessment) {
        console.log("Found assessment in current list:", assessment);
        console.log("Comments data structure:", assessment.comments);
        console.log("General comment:", assessment.general_comment);
        const assessmentWithFormattedComments = {
          ...assessment,
          // Ensure comments are properly formatted
          comments: assessment.comments || {}
        };
        setSelectedAssessment(assessmentWithFormattedComments);
        setShowViewModal(true);
      } else {
        console.log("Assessment not found in current list, fetching from API...");
        const fetchedAssessment = await fetchAssessmentDetails(assessmentId);
        if (fetchedAssessment) {
          console.log("Fetched assessment from API:", fetchedAssessment);
          console.log("Fetched comments:", fetchedAssessment.comments);
          console.log("Fetched general comment:", fetchedAssessment.general_comment);
          const assessmentWithFormattedComments = {
            ...fetchedAssessment,
            // Ensure comments are properly formatted
            comments: fetchedAssessment.comments || {}
          };
          setSelectedAssessment(assessmentWithFormattedComments);
          setShowViewModal(true);
        } else {
          throw new Error("Assessment not found");
        }
      }
    } catch (error2) {
      console.error("Error fetching assessment details:", error2);
      Swal.fire({
        icon: "error",
        title: "Error",
        text: "Could not retrieve assessment details. Please try again later."
      });
    } finally {
      setViewAssessmentLoading(false);
    }
  };
  const fetchAssessmentDetails = async (assessmentId) => {
    try {
      const response = await APIService.getAssessment(assessmentId, dispatch);
      return response;
    } catch (error2) {
      console.error("Error fetching assessment details:", error2);
      return null;
    }
  };
  const handleContinueAssessment = (assessmentId) => {
    navigate(`/assessment/${assessmentId}/edit`);
  };
  const getFilteredAssessments = () => {
    console.log(`Filtering ${assessments.length} assessments for ${activeTab} tab`);
    const filtered = assessments.filter((assessment) => {
      var _a2;
      const status = ((_a2 = assessment.status) == null ? void 0 : _a2.toLowerCase()) || "pending";
      switch (activeTab) {
        case "pending":
          return status === "pending" || status === "in_progress";
        case "completed":
          return status === "completed";
        default:
          return true;
      }
    });
    console.log(`Found ${filtered.length} ${activeTab} assessments after filtering`);
    filtered.forEach((a2, i2) => console.log(`Filtered assessment ${i2 + 1}:`, a2.status));
    return filtered;
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "d-flex justify-content-center align-items-center", style: { height: "200px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner-border", role: "status", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "visually-hidden", children: "Loading..." }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container-fluid", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "card-title", children: "Performance Assessment" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "nav nav-tabs mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `nav-link ${activeTab === "new" ? "active" : ""}`,
              onClick: () => toggleTab("new"),
              children: "New Assessment"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `nav-link ${activeTab === "pending" ? "active" : ""}`,
              onClick: () => toggleTab("pending"),
              children: "Pending Assessments"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `nav-link ${activeTab === "completed" ? "active" : ""}`,
              onClick: () => toggleTab("completed"),
              children: "Completed Assessments"
            }
          ) })
        ] }),
        activeTab === "new" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-pane active", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: "Create New Assessment" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group mb-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Assessment Type" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                className: "form-control",
                value: assessmentType,
                onChange: (e2) => {
                  const newType = e2.target.value;
                  setAssessmentType(newType);
                  setAssessmentForm((prev) => ({
                    ...prev,
                    assessmentType: newType
                  }));
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "self", children: "Self Assessment" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "manager", children: "Manager Assessment" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "peer", children: "Peer Assessment" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "subordinate", children: "Subordinate Assessment" })
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group mb-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Select Employee" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-group", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  className: "form-control",
                  value: selectedEmployeeId ? (() => {
                    if (selectedEmployeeId && typeof selectedEmployeeId === "string" && selectedEmployeeId.length > 0) {
                      if (/[a-zA-Z]/.test(selectedEmployeeId)) {
                        return selectedEmployeeId;
                      }
                    }
                    const emp = employees.find(
                      (e2) => e2.staff_name === selectedEmployeeId || e2.sno === selectedEmployeeId || e2.id === selectedEmployeeId || e2._id === selectedEmployeeId || e2.employeeID === selectedEmployeeId
                    );
                    return emp ? emp.staff_name || emp.name || `${emp.firstName || ""} ${emp.lastName || ""}` : selectedEmployeeId || "Select Employee";
                  })() : "Select Employee",
                  placeholder: "Click to select employee",
                  readOnly: true
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "input-group-append", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "btn btn-outline-secondary",
                  type: "button",
                  onClick: toggleEmployeeModal,
                  children: "Browse"
                }
              ) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-group mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-header bg-primary text-white d-flex justify-content-between align-items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mb-0", children: "Assessment Criteria" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                type: "button",
                className: "btn btn-light btn-sm",
                onClick: openCriteriaModal,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-cog me-1" }),
                  " Select Criteria"
                ]
              }
            )
          ] }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal fade", id: "criteriaSelectionModal", ref: criteriaModalRef, tabIndex: "-1", "aria-labelledby": "criteriaSelectionModalLabel", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-dialog modal-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "modal-title", id: "criteriaSelectionModalLabel", children: "Select Performance Criteria" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: "btn-close", "aria-label": "Close", onClick: closeCriteriaModal })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted mb-3", children: "Select the criteria you want to include in this assessment. You can select multiple criteria." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-3 border-bottom pb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-check", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    className: "form-check-input",
                    type: "checkbox",
                    id: "select-all-criteria",
                    checked: criteria.length > 0 && selectedCriteriaIds.length === criteria.length,
                    onChange: toggleAllCriteria
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-check-label fw-bold", htmlFor: "select-all-criteria", children: "Select All Criteria" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { className: "text-muted", children: [
                "Debug: ",
                criteria ? `${criteria.length} criteria available` : "No criteria available"
              ] }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: criteria && criteria.length > 0 ? criteria.map((criterion, index2) => {
                const criterionId = criterion.id || criterion._id || criterion.sno || `criterion_${index2 + 1}`;
                const criteriaTitle = criterion.name || criterion.title || criterion.criteria_name || `Criterion ${index2 + 1}`;
                const criteriaDescription = criterion.description || criterion.details || criterion.criteria_description || "";
                return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-check", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      className: "form-check-input",
                      type: "checkbox",
                      id: `criteria-check-${index2}`,
                      checked: selectedCriteriaIds.includes(criterionId),
                      onChange: () => toggleCriteriaSelection(criterionId)
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "form-check-label", htmlFor: `criteria-check-${index2}`, children: [
                    criteriaTitle,
                    criteriaDescription && /* @__PURE__ */ jsxRuntimeExports.jsx("small", { className: "d-block text-muted", children: criteriaDescription })
                  ] })
                ] }) }, `criterion-${index2}`);
              }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-12 text-center py-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No criteria available. Please check API connection or refresh the page." }) }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: "btn btn-secondary", onClick: closeCriteriaModal, children: "Close" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "btn btn-primary",
                  onClick: () => {
                    if (selectedCriteriaIds.length === 0 && criteria.length > 0) {
                      const defaultSelected = criteria.slice(0, 1).map((criterion) => criterion.id || criterion._id || criterion.sno || `criterion_${criteria.indexOf(criterion) + 1}`).filter(Boolean);
                      console.log("No criteria selected, defaulting to first 1:", defaultSelected);
                      setSelectedCriteriaIds(defaultSelected);
                    } else {
                      console.log("Applying selection with criteria IDs:", selectedCriteriaIds);
                    }
                    const selectedCriteria = criteria.filter((criterion) => {
                      const criterionId = criterion.id || criterion._id || criterion.sno;
                      return selectedCriteriaIds.includes(criterionId);
                    });
                    const initialRatings = {};
                    const initialComments = {};
                    selectedCriteria.forEach((criterion) => {
                      const criterionId = criterion.id || criterion._id || criterion.sno;
                      if (criterionId && !assessmentForm.ratings[criterionId]) {
                        initialRatings[criterionId] = 0;
                        initialComments[criterionId] = "";
                      }
                    });
                    setAssessmentForm((prev) => ({
                      ...prev,
                      ratings: { ...prev.ratings, ...initialRatings },
                      comments: { ...prev.comments, ...initialComments }
                    }));
                    closeCriteriaModal();
                  },
                  children: "Apply Selection"
                }
              )
            ] })
          ] }) }) }),
          getFilteredCriteria().length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-group mb-3", children: getFilteredCriteria().map((criterion, index2) => {
            const criterionId = criterion.id || criterion._id || criterion.sno || `criterion_${index2 + 1}`;
            const criteriaTitle = criterion.name || criterion.title || criterion.criteria_name || `Criterion ${index2 + 1}`;
            const criteriaDescription = criterion.description || criterion.details || criterion.criteria_description || "Rate the performance for this criterion";
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { className: "card-title fw-bold", children: criteriaTitle }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted", children: criteriaDescription }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rating-group mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row align-items-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "fw-bold", children: "Rating:" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "btn-group", role: "group", children: [1, 2, 3, 4, 5].map((rating) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "label",
                  {
                    className: `btn ${assessmentForm.ratings[criteriaTitle] === rating.toString() ? "btn-primary" : "btn-outline-primary"} me-2`,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "radio",
                          name: `rating_${criterionId}`,
                          value: rating,
                          checked: assessmentForm.ratings[criteriaTitle] === rating,
                          onChange: () => handleRatingChange(criterionId, criteriaTitle, rating),
                          className: "form-check-input d-none"
                        }
                      ),
                      rating
                    ]
                  },
                  `rating-${criterionId}-${rating}`
                )) }) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group mt-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "fw-bold mb-2", children: "Comments" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "textarea",
                  {
                    className: "form-control",
                    placeholder: "Enter comments for this criterion",
                    value: assessmentForm.comments[criteriaTitle] || "",
                    onChange: (e2) => handleCommentChange(criterionId, criteriaTitle, e2.target.value),
                    rows: "3"
                  }
                )
              ] })
            ] }) }, `assessment-criterion-${index2}`);
          }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "alert alert-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-info-circle me-2" }),
            "Loading assessment criteria... If no criteria appear, please try changing the assessment type or contact your administrator."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group mt-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "comments", children: "General Comments" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "textarea",
              {
                id: "comments",
                className: "form-control",
                placeholder: "Enter your general comments here...",
                value: assessmentForm.generalComment || "",
                onChange: (e2) => setAssessmentForm({ ...assessmentForm, generalComment: e2.target.value }),
                rows: "4"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn btn-primary",
              onClick: handleAssessmentSubmit,
              disabled: loading,
              children: loading ? "Submitting..." : "Submit Assessment"
            }
          ) })
        ] }),
        (activeTab === "pending" || activeTab === "completed") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h5", { children: [
            activeTab === "pending" ? "Pending" : "Completed",
            " Assessments"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "table-responsive mt-4", children: [
            loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner-border text-primary", role: "status", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "visually-hidden", children: "Loading..." }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2", children: "Loading assessments from database..." })
            ] }) : getFilteredAssessments().length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "table table-striped", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Employee" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Assessment Type" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Status" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Progress" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Created Date" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Actions" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: getFilteredAssessments().map((assessment) => {
                console.log("Rendering filtered assessment:", assessment);
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: (() => {
                    if (assessment.staff_name) return assessment.staff_name;
                    if (assessment.employeeName) return assessment.employeeName;
                    const employeeId = assessment.employee_id;
                    if (employeeNames[employeeId]) {
                      return employeeNames[employeeId];
                    }
                    return assessment.employee_id ? `Employee ID: ${assessment.employee_id}` : "Unknown Employee";
                  })() }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: assessment.type || "N/A" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `badge ${assessment.status === "completed" ? "bg-success" : assessment.status === "in_progress" ? "bg-info" : "bg-warning"}`, children: assessment.status || "pending" }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                    assessment.progress || 0,
                    "%"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: new Date(assessment.created_at || Date.now()).toLocaleDateString() }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        className: "btn btn-sm btn-primary me-2",
                        onClick: () => handleViewAssessment(assessment._id || assessment.sno),
                        children: "View"
                      }
                    ),
                    assessment.status !== "completed" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        className: "btn btn-sm btn-success",
                        onClick: () => handleContinueAssessment(assessment._id || assessment.sno),
                        children: "Continue"
                      }
                    )
                  ] })
                ] }, assessment._id || assessment.id || assessment.sno);
              }) })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No assessments found." }) }),
            assessments.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "pagination justify-content-end", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: `page-item ${currentPage === 1 ? "disabled" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "a",
                {
                  className: "page-link",
                  href: "#",
                  onClick: (e2) => {
                    e2.preventDefault();
                    handlePageChange(currentPage - 1);
                  },
                  "aria-disabled": currentPage === 1,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "aria-hidden": "true", children: "" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Previous" })
                  ]
                }
              ) }),
              Array.from({ length: Math.ceil(totalItems / itemsPerPage) }, (_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: `page-item ${currentPage === i2 + 1 ? "active" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  className: "page-link",
                  href: "#",
                  onClick: (e2) => {
                    e2.preventDefault();
                    handlePageChange(i2 + 1);
                  },
                  children: i2 + 1
                }
              ) }, i2)),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: `page-item ${currentPage === Math.ceil(totalItems / itemsPerPage) ? "disabled" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "a",
                {
                  className: "page-link",
                  href: "#",
                  onClick: (e2) => {
                    e2.preventDefault();
                    handlePageChange(currentPage + 1);
                  },
                  "aria-disabled": currentPage === Math.ceil(totalItems / itemsPerPage),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "aria-hidden": "true", children: "" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Next" })
                  ]
                }
              ) })
            ] }) }) })
          ] })
        ] })
      ] })
    ] }) }) }),
    showEmployeeModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal", style: { display: "block", backgroundColor: "rgba(0,0,0,0.5)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-dialog", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "modal-title", children: "Select Employee" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            className: "btn-close",
            onClick: toggleEmployeeModal,
            "aria-label": "Close"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "input-group mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            className: "form-control",
            placeholder: "Search employees...",
            value: searchTerm,
            onChange: (e2) => setSearchTerm(e2.target.value)
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "list-group", style: { maxHeight: "400px", overflowY: "auto" }, children: filteredEmployees.map((employee) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            className: "list-group-item list-group-item-action",
            onClick: () => handleEmployeeSelect(employee),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { className: "mb-1", children: employee.staff_name || employee.name || `${employee.firstName || ""} ${employee.lastName || ""}` }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { className: "text-muted", children: employee.job_role || employee.position || employee.designation || "Employee" })
            ]
          },
          employee.id || employee._id || employee.sno || employee.employeeID
        )) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-footer", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          className: "btn btn-secondary",
          onClick: toggleEmployeeModal,
          children: "Close"
        }
      ) })
    ] }) }) }),
    showViewModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal", style: { display: "block", backgroundColor: "rgba(0,0,0,0.5)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-dialog modal-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "modal-title", children: "Assessment Details" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            className: "btn-close",
            onClick: () => setShowViewModal(false),
            "aria-label": "Close"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-body", children: viewAssessmentLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner-border text-primary", role: "status", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "visually-hidden", children: "Loading..." }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2", children: "Loading assessment details..." })
      ] }) : selectedAssessment ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "assessment-details", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "card-title", children: "General Information" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: "table table-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Employee:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: selectedAssessment.staff_name || selectedAssessment.employeeName || (employeeNames[selectedAssessment.employee_id] || `Employee ID: ${selectedAssessment.employee_id}`) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Assessment Type:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: selectedAssessment.type || "N/A" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Status:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `badge ${selectedAssessment.status === "completed" ? "bg-success" : selectedAssessment.status === "in_progress" ? "bg-info" : "bg-warning"}`, children: selectedAssessment.status || "pending" }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Progress:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: `progress-bar ${selectedAssessment.progress === 100 ? "bg-success" : "bg-primary"}`,
                    role: "progressbar",
                    style: { width: `${selectedAssessment.progress || 0}%` },
                    "aria-valuenow": selectedAssessment.progress || 0,
                    "aria-valuemin": "0",
                    "aria-valuemax": "100",
                    children: [
                      selectedAssessment.progress || 0,
                      "%"
                    ]
                  }
                ) }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Created Date:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: new Date(selectedAssessment.created_at || Date.now()).toLocaleDateString() })
              ] }),
              selectedAssessment.completed_at && /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Completed Date:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: new Date(selectedAssessment.completed_at).toLocaleDateString() })
              ] })
            ] }) })
          ] }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "card-title", children: "Comments" }),
            (() => {
              console.log("Rendering comments section with assessment:", selectedAssessment);
              console.log("Comments object structure:", JSON.stringify(selectedAssessment.comments));
              const commentData = selectedAssessment.comments || selectedAssessment.comment || {};
              const hasGeneralComment = selectedAssessment.general_comment || selectedAssessment.generalComment || selectedAssessment.general_comments;
              const hasSpecificComments = commentData && typeof commentData === "object" && Object.keys(commentData).length > 0;
              if (hasGeneralComment || hasSpecificComments) {
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { children: "General Comment:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "card-text", children: selectedAssessment.general_comment || selectedAssessment.generalComment || selectedAssessment.general_comments || "No general comment provided." }),
                  hasSpecificComments && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { children: "Specific Comments:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "list-group", children: Object.entries(commentData).filter(
                      ([key, value]) => (
                        // Only show entries with valid comments and filter MongoDB IDs
                        !/^[0-9a-f]{24}$/i.test(key) && typeof value === "string"
                      )
                    ).map(([criteriaName, comment]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "list-group-item", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
                        criteriaName,
                        ":"
                      ] }),
                      " ",
                      comment
                    ] }, criteriaName)) })
                  ] })
                ] });
              } else {
                return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "card-text", children: "No comments available." }) });
              }
            })()
          ] }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "card-title", children: "Ratings" }),
          selectedAssessment.responses && Object.keys(selectedAssessment.responses).length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "table", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Criteria" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Rating" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: Object.entries(selectedAssessment.responses).filter(([key, _2]) => !/^[0-9a-f]{24}$/i.test(key)).map(([criteriaName, rating]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: criteriaName }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "d-flex", children: [1, 2, 3, 4, 5].map((num) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: `badge rounded-pill me-1 ${num <= parseInt(rating) ? "bg-primary" : "bg-secondary"}`,
                  style: { width: "24px", height: "24px" },
                  children: num
                },
                `rating-${criteriaName}-${num}`
              )) }) })
            ] }, criteriaName)) })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No ratings available." })
        ] }) })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "alert alert-info", children: "No assessment details available." }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-footer", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          className: "btn btn-secondary",
          onClick: () => setShowViewModal(false),
          children: "Close"
        }
      ) })
    ] }) }) })
  ] });
};
const mockAssessments = [
  {
    id: "assess-1",
    title: "Q4 2024 Self Assessment",
    status: "in-progress",
    progress: 60,
    created_at: "2024-12-01",
    updated_at: "2024-12-15"
  },
  {
    id: "assess-2",
    title: "Q3 2024 Self Assessment",
    status: "completed",
    progress: 100,
    created_at: "2024-09-01",
    updated_at: "2024-09-30"
  }
];
const SelfAssessment = () => {
  const { configId, assessmentId } = useParams();
  const navigate = useNavigate();
  const [loading, setLoading2] = reactExports.useState(false);
  const [submitting, setSubmitting] = reactExports.useState(false);
  const [criteria, setCriteria] = reactExports.useState([]);
  const [criteriaError, setCriteriaError] = reactExports.useState(null);
  const [assessments, setAssessments] = reactExports.useState([]);
  const [activeTab, setActiveTab] = reactExports.useState("pending");
  const [currentStep, setCurrentStep] = reactExports.useState(0);
  const [showViewModal, setShowViewModal] = reactExports.useState(false);
  const [selectedAssessment, setSelectedAssessment] = reactExports.useState(null);
  const [currentAssessmentId, setCurrentAssessmentId] = reactExports.useState(assessmentId || null);
  const [summaryStats, setSummaryStats] = reactExports.useState({
    total: 0,
    completed: 0,
    avgProgress: 0
  });
  const [assessmentForm, setAssessmentForm] = reactExports.useState({
    ratings: {},
    comments: {},
    generalComment: "",
    progress: 0
  });
  reactExports.useEffect(() => {
    const fetchSummary = async () => {
      try {
        const isManager = localStorage.getItem("user_role") === "manager" || sessionStorage.getItem("user_role") === "manager";
        console.log("User appears to have manager role:", isManager ? "Yes" : "No");
        if (!isManager) {
          console.log("User is not a manager, skipping summary fetch");
          return;
        }
        const summaryData = await APIServices2.getSelfAssessmentSummary();
        console.log("Assessment summary data:", summaryData);
        setSummaryStats({
          total: summaryData.total || 0,
          completed: summaryData.completed || 0,
          avgProgress: summaryData.avg_progress || 0
        });
      } catch (error2) {
        console.error("Error fetching assessment summary:", error2);
        if (error2.response && error2.response.status === 401) {
          console.log("Permission denied for summary - user likely not a manager");
        }
      }
    };
    fetchSummary();
  }, []);
  reactExports.useEffect(() => {
    const localDraftId = localStorage.getItem("currentSelfAssessmentDraftId");
    if (localDraftId) {
      try {
        const localFormData = localStorage.getItem(`self_assessment_form_${localDraftId}`);
        if (localFormData) {
          const parsedForm = JSON.parse(localFormData);
          setAssessmentForm(parsedForm);
          console.log("Loaded draft assessment from local storage:", parsedForm);
        }
      } catch (e2) {
        console.error("Error loading local draft:", e2);
      }
    }
    const fetchData = async () => {
      try {
        console.log("SelfAssessment: Starting to fetch data...");
        setLoading2(true);
        setCriteriaError(null);
        console.log("SelfAssessment: Fetching all performance criteria...");
        const criteriaData = await APIServices2.getAllPcriteria();
        const filteredCriteria = criteriaData.filter(
          (criterion) => !criterion.assessment_type || criterion.assessment_type === "self" || criterion.type === "self"
        );
        console.log("SelfAssessment: Performance criteria fetched successfully:", filteredCriteria);
        const transformedCriteria = filteredCriteria.map((criterion) => ({
          id: criterion.id || criterion.sno || criterion._id || `criterion_${Math.random().toString(36).substr(2, 9)}`,
          title: criterion.question || criterion.criteriaName || criterion.title || criterion.name || "Unnamed Criterion",
          description: criterion.description || criterion.desc || criterion.details || "No description available",
          category: criterion.category || criterion.type || criterion.group || "General",
          weight: criterion.weight || 1,
          // Preserve all original properties
          ...criterion
        }));
        console.log("SelfAssessment: Transformed criteria:", transformedCriteria);
        setCriteria(transformedCriteria);
        try {
          const assessmentData = await APIServices2.getSelfAssessments();
          console.log("SelfAssessment: User assessments fetched:", assessmentData);
          if (assessmentData && assessmentData.assessments) {
            setAssessments(assessmentData.assessments.map((assessment) => ({
              id: assessment._id || assessment.id,
              title: assessment.title || `Self Assessment (${new Date(assessment.created_at).toLocaleDateString()})`,
              status: assessment.status || "pending",
              progress: assessment.progress || 0,
              created_at: assessment.created_at,
              updated_at: assessment.updated_at || assessment.created_at,
              responses: assessment.responses || {},
              comments: assessment.comments || {},
              generalComment: assessment.general_comment || "",
              // Preserve all original data
              ...assessment
            })));
          } else {
            setAssessments(mockAssessments);
          }
        } catch (assessmentError) {
          console.error("SelfAssessment: Failed to fetch assessments:", assessmentError);
          setAssessments(mockAssessments);
        }
        if (assessmentId) {
          try {
            const assessmentDetails = await APIServices2.getSelfAssessment(assessmentId);
            console.log("SelfAssessment: Loaded specific assessment:", assessmentDetails);
            const loadedRatings = assessmentDetails.ratings || {};
            let calculatedProgress = 0;
            if (Object.keys(loadedRatings).length > 0) {
              const progressMap = {
                1: 20,
                // Rating 1 = 20%
                2: 40,
                // Rating 2 = 40%
                3: 60,
                // Rating 3 = 60%
                4: 80,
                // Rating 4 = 80%
                5: 100
                // Rating 5 = 100%
              };
              const ratingValues = Object.values(loadedRatings);
              const progressValues = ratingValues.map((rating) => progressMap[rating] || 0);
              calculatedProgress = progressValues.length > 0 ? Math.max(...progressValues) : 0;
            }
            setAssessmentForm({
              ratings: loadedRatings,
              comments: assessmentDetails.comments || {},
              generalComment: assessmentDetails.general_comment || "",
              progress: calculatedProgress
              // Use our calculated progress instead
            });
            if (assessmentDetails.last_completed_step !== void 0) {
              setCurrentStep(assessmentDetails.last_completed_step);
            }
          } catch (error2) {
            console.error("Error loading assessment details:", error2);
            Swal.fire({
              title: "Error",
              text: "Failed to load assessment details",
              icon: "error"
            });
          }
        }
      } catch (error2) {
        console.error("SelfAssessment: Failed to fetch criteria:", error2);
        setCriteriaError(`Failed to load assessment criteria: ${error2.message}`);
        setCriteria([]);
        Swal.fire({
          title: "Error",
          text: `Failed to load assessment criteria: ${error2.message}`,
          icon: "error",
          confirmButtonText: "OK"
        });
      } finally {
        console.log("SelfAssessment: Fetch data completed");
        setLoading2(false);
      }
    };
    fetchData();
  }, []);
  const calculateProgress = () => {
    if (criteria.length === 0) return 0;
    const ratingValues = Object.values(assessmentForm.ratings);
    if (ratingValues.length === 0) return 0;
    const progressMap = {
      1: 20,
      // Rating 1 = 20%
      2: 40,
      // Rating 2 = 40%
      3: 60,
      // Rating 3 = 60%
      4: 80,
      // Rating 4 = 80%
      5: 100
      // Rating 5 = 100%
    };
    const progressValues = ratingValues.map((rating) => progressMap[rating] || 0);
    const highestProgress = progressValues.length > 0 ? Math.max(...progressValues) : 0;
    return highestProgress;
  };
  const handleRatingChange = (criteriaId, ratingValue) => {
    const progressMap = {
      1: 20,
      // Rating 1 = 20% (explicitly set to ensure this value is used)
      2: 40,
      // Rating 2 = 40%
      3: 60,
      // Rating 3 = 60%
      4: 80,
      // Rating 4 = 80%
      5: 100
      // Rating 5 = 100%
    };
    const newProgress = progressMap[ratingValue] || 0;
    const updatedRatings = {
      ...assessmentForm.ratings,
      [criteriaId]: ratingValue
    };
    setAssessmentForm((prev) => ({
      ...prev,
      ratings: updatedRatings,
      progress: newProgress
    }));
  };
  const handleCommentChange = (criteriaId, comment) => {
    setAssessmentForm((prev) => ({
      ...prev,
      comments: {
        ...prev.comments,
        [criteriaId]: comment
      }
    }));
  };
  const handleGeneralCommentChange = (comment) => {
    setAssessmentForm((prev) => ({
      ...prev,
      generalComment: comment
    }));
  };
  const handleNext = async () => {
    try {
      await saveProgress();
      if (currentStep < criteria.length - 1) {
        setCurrentStep((prev) => prev + 1);
      }
    } catch (error2) {
      console.error("Error saving progress before moving to next step:", error2);
      Swal.fire({
        title: "Warning",
        text: "Could not save your progress, but you can continue. Please try saving later.",
        icon: "warning",
        confirmButtonText: "Continue Anyway"
      }).then(() => {
        if (currentStep < criteria.length - 1) {
          setCurrentStep((prev) => prev + 1);
        }
      });
    }
  };
  const handlePrevious = () => {
    if (currentStep > 0) {
      setCurrentStep((prev) => prev - 1);
    }
  };
  const getCurrentUserName = () => {
    const defaultUserName = "john dula";
    try {
      const userNameElement = document.querySelector(".user-name") || document.querySelector(".profile-name") || document.querySelector(".username");
      if (userNameElement && userNameElement.textContent.trim()) {
        return userNameElement.textContent.trim();
      }
      const storageKeys = ["userInfo", "user", "authData", "userData", "auth", "profile"];
      for (const key of storageKeys) {
        try {
          const data = JSON.parse(localStorage.getItem(key) || sessionStorage.getItem(key) || "{}");
          if (data && (data.fullName || data.name || data.username)) {
            return data.fullName || data.name || data.username;
          }
          if (data && data.user && (data.user.fullName || data.user.name || data.user.username)) {
            return data.user.fullName || data.user.name || data.user.username;
          }
        } catch (e2) {
          console.warn(`Error parsing ${key} from storage:`, e2);
        }
      }
      console.log("Using default user name:", defaultUserName);
      return defaultUserName;
    } catch (e2) {
      console.error("Error retrieving user name:", e2);
      return defaultUserName;
    }
  };
  const saveProgress = async () => {
    var _a2;
    try {
      console.log("Saving assessment progress locally:", assessmentForm);
      setSubmitting(true);
      const userName = getCurrentUserName();
      console.log("Using user name for assessment:", userName);
      const responsesObj = {};
      const commentsObj = {};
      const progressMap = {
        1: 20,
        // Rating 1 = 20%
        2: 40,
        // Rating 2 = 40%
        3: 60,
        // Rating 3 = 60%
        4: 80,
        // Rating 4 = 80%
        5: 100
        // Rating 5 = 100%handleSubmit 
      };
      Object.keys(assessmentForm.ratings || {}).forEach((criteriaId) => {
        const criteriaDetail = criteria.find((c2) => c2.id === criteriaId || c2.id.toString() === criteriaId.toString());
        const ratingValue = assessmentForm.ratings[criteriaId];
        const progress = progressMap[ratingValue] || 0;
        responsesObj[criteriaId.toString()] = {
          value: ratingValue.toString(),
          criteria_name: (criteriaDetail == null ? void 0 : criteriaDetail.title) || "",
          category: (criteriaDetail == null ? void 0 : criteriaDetail.category) || "",
          description: (criteriaDetail == null ? void 0 : criteriaDetail.description) || "",
          progress
          // Save the progress value for each criteria
        };
        if (assessmentForm.comments && assessmentForm.comments[criteriaId]) {
          commentsObj[criteriaId.toString()] = assessmentForm.comments[criteriaId];
        }
      });
      console.log("Saving responses locally with criteria details:", responsesObj);
      const activeConfigId = configId || 1;
      if (configId && configId.toString() === "1" && assessmentId) {
        try {
          const apiData = {
            config_sno: Number(configId),
            assessment_id: assessmentId,
            staff_name: userName,
            type: "self",
            responses: responsesObj,
            // This now includes progress for each criteria
            comments: commentsObj,
            general_comment: assessmentForm.generalComment || "",
            progress: Number(calculateProgress() || 0),
            status: "draft"
          };
          console.log("Sending API data with progress values:", apiData);
        } catch (error2) {
          console.error("Error sending API data:", error2);
        }
      }
      const localStorageData = {
        // Required fields
        config_sno: Number(activeConfigId),
        staff_name: userName,
        type: "self",
        // Enhanced fields with structured data
        responses: responsesObj,
        comments: commentsObj,
        general_comment: assessmentForm.generalComment || "",
        last_completed_step: Number(currentStep || 0),
        progress: Number(calculateProgress() || 0),
        status: "draft",
        // Using 'draft' status for locally saved data
        is_anonymous: false,
        // Include criteria metadata for reference
        metadata: {
          criteria_count: Object.keys(responsesObj).length,
          last_saved: (/* @__PURE__ */ new Date()).toISOString(),
          assessment_name: ((_a2 = criteria[0]) == null ? void 0 : _a2.config_name) || "Performance Self Assessment"
        }
      };
      const storageId = assessmentId || `local_draft_${(/* @__PURE__ */ new Date()).getTime()}`;
      localStorage.setItem(`self_assessment_${storageId}`, JSON.stringify(localStorageData));
      localStorage.setItem(`self_assessment_form_${storageId}`, JSON.stringify(assessmentForm));
      if (!assessmentId) {
        setCurrentAssessmentId(storageId);
        localStorage.setItem("currentSelfAssessmentDraftId", storageId);
        console.log("Created and stored local draft ID:", storageId);
      }
      Swal.fire({
        title: "Success",
        text: "Progress saved locally. Submit assessment when complete to save to database.",
        icon: "success",
        confirmButtonText: "OK"
      });
    } catch (error2) {
      console.error("Error saving assessment locally:", error2);
      Swal.fire({
        title: "Error",
        text: `Failed to save progress locally: ${error2.message}`,
        icon: "error",
        confirmButtonText: "OK"
      });
    } finally {
      setSubmitting(false);
    }
  };
  const handleSubmit = async () => {
    const confirmation = await Swal.fire({
      title: "Submit Self Assessment?",
      text: "Are you sure you want to submit this self assessment? You cannot edit it afterwards.",
      icon: "question",
      showCancelButton: true,
      confirmButtonText: "Yes, Submit",
      cancelButtonText: "Cancel"
    });
    if (!confirmation.isConfirmed) {
      return;
    }
    setSubmitting(true);
    console.log("Starting assessment submission process...");
    try {
      const userName = getCurrentUserName();
      const responsesObj = {};
      const commentsObj = {};
      const progressMap = {
        1: 20,
        // Rating 1 = 20%
        2: 40,
        // Rating 2 = 40%
        3: 60,
        // Rating 3 = 60%
        4: 80,
        // Rating 4 = 80%
        5: 100
        // Rating 5 = 100%
      };
      Object.keys(assessmentForm.ratings || {}).forEach((criteriaId) => {
        const criteriaDetail = criteria.find((c2) => c2.id === criteriaId || c2.id.toString() === criteriaId.toString());
        const ratingValue = assessmentForm.ratings[criteriaId];
        const progress = progressMap[ratingValue] || 0;
        responsesObj[criteriaId.toString()] = {
          value: ratingValue.toString(),
          criteria_name: (criteriaDetail == null ? void 0 : criteriaDetail.title) || "",
          category: (criteriaDetail == null ? void 0 : criteriaDetail.category) || "",
          description: (criteriaDetail == null ? void 0 : criteriaDetail.description) || "",
          progress
          // Add progress for each criteria
        };
        if (assessmentForm.comments && assessmentForm.comments[criteriaId]) {
          commentsObj[criteriaId.toString()] = assessmentForm.comments[criteriaId];
        }
      });
      console.log("Responses with progress values:", responsesObj);
      const activeConfigId = 1;
      const payload = {
        // Required fields from AssessmentCreate model
        config_sno: activeConfigId,
        // Use exactly 1 as the config_sno
        staff_name: userName,
        type: "self",
        // Enum value must be exact string
        // Enhanced responses with criteria details
        responses: responsesObj,
        // Now contains full criteria information with progress
        comments: commentsObj,
        // Now contains any comments for each criteria
        // Additional assessment data
        general_comment: assessmentForm.generalComment || "",
        last_completed_step: Number(currentStep || 0),
        progress: Number(calculateProgress() || 0),
        status: "pending",
        // Must match AssessmentStatus.PENDING exactly
        is_anonymous: false
      };
      console.log("Sending payload to backend:", JSON.stringify(payload, null, 2));
      const isLocalDraft = typeof currentAssessmentId === "string" && currentAssessmentId.includes("local_draft");
      if (!currentAssessmentId || isLocalDraft) {
        console.log("Assessment is a local draft or new. Creating backend record first...");
        console.log("FINAL PAYLOAD BEING SENT:", JSON.stringify(payload, null, 2));
        const saveResult = await APIServices2.createSelfAssessment(payload);
        console.log("FULL API RESPONSE:", JSON.stringify(saveResult, null, 2));
        let newId = null;
        if (saveResult) {
          if (saveResult.sno) {
            console.log("Found sno field:", saveResult.sno);
            newId = saveResult.sno;
          } else if (saveResult.id) {
            console.log("Found id field, but backend expects sno:", saveResult.id);
            newId = saveResult.id;
          } else if (saveResult._id) {
            console.log("Found MongoDB _id field, but backend expects sno:", saveResult._id);
            newId = saveResult._id;
          } else if (typeof saveResult === "string" || typeof saveResult === "number") {
            console.log("Response is a primitive value, using as sno:", saveResult);
            newId = saveResult;
          } else {
            console.error("No ID found in response!", saveResult);
            console.error("Raw response:", typeof saveResult, saveResult);
            throw new Error("Could not create assessment - no ID returned");
          }
        } else {
          console.error("Empty response from API");
          throw new Error("Could not create assessment - empty response");
        }
        if (newId) {
          console.log("Successfully saved assessment to backend with ID:", newId);
          setCurrentAssessmentId(newId);
          localStorage.setItem("currentSelfAssessmentId", newId);
          console.log("Waiting briefly before submission to ensure assessment is persisted...");
          await new Promise((resolve) => setTimeout(resolve, 1e3));
          console.log("Now submitting the saved assessment with ID:", newId);
          await APIServices2.submitSelfAssessment(newId);
        } else {
          throw new Error("Could not create assessment - no ID returned");
        }
      } else {
        console.log(`Submitting existing assessment with ID: ${currentAssessmentId}`);
        await APIServices2.submitSelfAssessment(currentAssessmentId);
      }
      Swal.fire({
        title: "Success",
        text: "Assessment submitted successfully!",
        icon: "success",
        confirmButtonText: "OK"
      }).then(() => {
        navigate("/assessment");
      });
    } catch (error2) {
      console.error("Error submitting assessment:", error2);
      if (error2.response) {
        console.error("Error response:", error2.response.data);
      }
      Swal.fire({
        title: "Error",
        text: `Failed to submit assessment: ${error2.message}`,
        icon: "error",
        confirmButtonText: "OK"
      });
    } finally {
      setSubmitting(false);
    }
  };
  const getFilteredAssessments = () => {
    return assessments.filter((assessment) => {
      switch (activeTab) {
        case "completed":
          return assessment.status === "completed";
        case "in-progress":
          return assessment.status === "in-progress";
        case "pending":
        default:
          return assessment.status === "pending";
      }
    });
  };
  const handleViewAssessment = async (assessment) => {
    try {
      setLoading2(true);
      if (assessment.id && (!assessment.responses || Object.keys(assessment.responses).length === 0)) {
        const fullAssessment = await APIServices2.getSelfAssessment(assessment.id);
        if (fullAssessment) {
          setSelectedAssessment({
            ...assessment,
            ...fullAssessment
          });
        } else {
          setSelectedAssessment(assessment);
        }
      } else {
        setSelectedAssessment(assessment);
      }
      setShowViewModal(true);
    } catch (error2) {
      console.error("Error loading assessment details:", error2);
      Swal.fire({
        title: "Error",
        text: `Failed to load assessment details: ${error2.message}`,
        icon: "error",
        confirmButtonText: "OK"
      });
    } finally {
      setLoading2(false);
    }
  };
  if (!configId) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card shadow", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-header bg-primary text-white", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "h4 mb-0", children: "Self Assessments" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "small mb-0", children: "Manage your performance assessments" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "nav nav-tabs mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `nav-link ${activeTab === "pending" ? "active" : ""}`,
              onClick: () => setActiveTab("pending"),
              children: "Pending"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `nav-link ${activeTab === "in-progress" ? "active" : ""}`,
              onClick: () => setActiveTab("in-progress"),
              children: "In Progress"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `nav-link ${activeTab === "completed" ? "active" : ""}`,
              onClick: () => setActiveTab("completed"),
              children: "Completed"
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tab-content", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tab-pane active", children: getFilteredAssessments().length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "list-group mb-4", children: getFilteredAssessments().map((assessment) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "list-group-item list-group-item-action", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between align-items-start", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mb-1", children: assessment.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex gap-3 mb-2 small text-muted", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                "Created: ",
                new Date(assessment.created_at).toLocaleDateString()
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                "Updated: ",
                new Date(assessment.updated_at).toLocaleDateString()
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `badge bg-${assessment.status === "completed" ? "success" : "secondary"}`, children: assessment.status })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress", style: { height: "10px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "progress-bar",
                  role: "progressbar",
                  style: { width: `${assessment.progress}%` },
                  "aria-valuenow": assessment.progress,
                  "aria-valuemin": "0",
                  "aria-valuemax": "100"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "small text-end mt-1", children: [
                assessment.progress,
                "%"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "btn-group btn-group-sm ms-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                className: "btn btn-outline-primary",
                onClick: () => handleViewAssessment(assessment),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "bi bi-eye me-1" }),
                  "View"
                ]
              }
            ),
            assessment.status !== "completed" && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "btn btn-primary",
                onClick: () => navigate(`/self-assessment/config-1/${assessment.id}`),
                children: "Continue"
              }
            )
          ] })
        ] }) }, assessment.id)) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "bi bi-exclamation-circle text-muted", style: { fontSize: "3rem" } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mt-3", children: "No assessments found" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted", children: "No assessments found for this category." })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 text-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn btn-primary",
            onClick: () => navigate("/self-assessment/config-1"),
            children: "Start New Assessment"
          }
        ) })
      ] })
    ] }) });
  }
  const currentCriteria = criteria.length > 0 ? criteria[currentStep] : null;
  const safeGet = (obj, path, fallback = "") => {
    try {
      if (!obj) return fallback;
      const parts = path.split(".");
      return parts.reduce((acc, part) => acc && acc[part] !== void 0 ? acc[part] : fallback, obj);
    } catch (e2) {
      return fallback;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container p-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card shadow", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-header bg-primary text-white", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "h4 mb-0", children: "Self Assessment" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted mb-0", children: "Performance evaluation and feedback" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-body p-4", children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "d-flex justify-content-center align-items-center py-5", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner-border text-primary", role: "status", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "visually-hidden", children: "Loading..." }) }) }) : criteriaError ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "bi bi-exclamation-circle text-muted", style: { fontSize: "3rem" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mt-3", children: "Error Loading Criteria" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted", children: criteriaError }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn btn-primary mt-3",
            onClick: () => window.location.reload(),
            children: "Retry"
          }
        )
      ] }) : criteria.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "bi bi-info-circle text-muted", style: { fontSize: "3rem" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mt-3", children: "No Criteria Available" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted", children: "No assessment criteria found. Please contact your administrator." })
      ] }) : !currentCriteria ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "bi bi-exclamation-triangle text-muted", style: { fontSize: "3rem" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mt-3", children: "Invalid Step" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted", children: "Current assessment step is invalid." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn btn-primary mt-3",
            onClick: () => setCurrentStep(0),
            children: "Go to First Step"
          }
        )
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between align-items-center mb-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mb-0", children: "Assessment Progress" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "badge bg-primary", children: [
              assessmentForm.ratings && currentCriteria && currentCriteria.id && assessmentForm.ratings[currentCriteria.id] === 1 ? "20" : assessmentForm.progress,
              "%"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress", style: { height: "10px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "progress-bar",
              role: "progressbar",
              style: {
                width: `${assessmentForm.ratings && currentCriteria && currentCriteria.id && assessmentForm.ratings[currentCriteria.id] === 1 ? "20" : assessmentForm.progress}%`
              },
              "aria-valuenow": assessmentForm.ratings && currentCriteria && currentCriteria.id && assessmentForm.ratings[currentCriteria.id] === 1 ? 20 : assessmentForm.progress,
              "aria-valuemin": "0",
              "aria-valuemax": "100"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "small text-muted mt-2", children: [
            "Step ",
            currentStep + 1,
            " of ",
            criteria.length
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-header bg-light", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mb-1", children: safeGet(currentCriteria, "title", "Unnamed Criterion") }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-label fw-bold", children: "Rating *" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "d-flex gap-2 mb-2", children: [1, 2, 3, 4, 5].map((rating) => {
                const hasExplicitRating = assessmentForm.ratings && currentCriteria && currentCriteria.id && Object.prototype.hasOwnProperty.call(assessmentForm.ratings, currentCriteria.id) && assessmentForm.ratings[currentCriteria.id] !== void 0 && assessmentForm.ratings[currentCriteria.id] !== null && assessmentForm.ratings[currentCriteria.id] !== 0 && assessmentForm.ratings[currentCriteria.id] !== "" && !isNaN(Number(assessmentForm.ratings[currentCriteria.id]));
                const isSelected2 = hasExplicitRating && Number(assessmentForm.ratings[currentCriteria.id]) === Number(rating);
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    className: `btn ${isSelected2 ? "btn-primary" : "btn-outline-primary"}`,
                    style: { width: "45px", height: "45px" },
                    onClick: () => handleRatingChange(currentCriteria.id, rating),
                    disabled: submitting,
                    "aria-label": `Rating ${rating}`,
                    "data-testid": `rating-button-${rating}`,
                    children: rating
                  },
                  rating
                );
              }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between small text-muted", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Poor" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Excellent" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: `comment_${currentCriteria.id}`, className: "form-label fw-bold", children: "Comments" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "textarea",
                {
                  className: "form-control",
                  id: `comment_${currentCriteria.id}`,
                  value: assessmentForm.comments[currentCriteria.id] || "",
                  onChange: (e2) => handleCommentChange(currentCriteria.id, e2.target.value),
                  placeholder: "Provide any comments or examples to support your rating...",
                  disabled: submitting,
                  rows: 4
                }
              )
            ] })
          ] })
        ] }),
        currentStep === criteria.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mb-0", children: "General Comments" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-body", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              className: "form-control",
              value: assessmentForm.generalComment,
              onChange: (e2) => handleGeneralCommentChange(e2.target.value),
              placeholder: "Provide any general comments about this self assessment...",
              disabled: submitting,
              rows: 4
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between align-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              type: "button",
              className: "btn btn-outline-secondary",
              onClick: handlePrevious,
              disabled: currentStep === 0 || submitting,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "bi bi-arrow-left me-1" }),
                "Previous"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: "btn btn-outline-primary",
                onClick: saveProgress,
                disabled: submitting,
                children: submitting ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "spinner-border spinner-border-sm me-1", role: "status", "aria-hidden": "true" }),
                  "Saving..."
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "bi bi-save me-1" }),
                  "Save Progress"
                ] })
              }
            ),
            currentStep < criteria.length - 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                type: "button",
                className: "btn btn-primary",
                onClick: handleNext,
                disabled: submitting,
                children: [
                  "Next",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "bi bi-arrow-right ms-1" })
                ]
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: "btn btn-success",
                onClick: handleSubmit,
                disabled: submitting,
                children: submitting ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "spinner-border spinner-border-sm me-1", role: "status", "aria-hidden": "true" }),
                  "Submitting..."
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "bi bi-send me-1" }),
                  "Submit Assessment"
                ] })
              }
            )
          ] })
        ] })
      ] }) })
    ] }),
    showViewModal && selectedAssessment && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ViewAssessmentModal,
      {
        assessment: selectedAssessment,
        criteria,
        onClose: () => setShowViewModal(false)
      }
    )
  ] });
};
const ViewAssessmentModal = ({ assessment, criteria, onClose }) => {
  const safeGet = (obj, path, fallback = "") => {
    try {
      if (!obj) return fallback;
      const parts = path.split(".");
      return parts.reduce((acc, part) => acc && acc[part] !== void 0 ? acc[part] : fallback, obj);
    } catch (e2) {
      return fallback;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal d-block", tabIndex: "-1", style: { backgroundColor: "rgba(0,0,0,0.5)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-dialog modal-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header bg-primary text-white", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "modal-title", children: "Assessment Details" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: "btn-close btn-close-white", onClick: onClose })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3 row", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "col-sm-3 col-form-label", children: "Title:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-sm-9", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "form-control-plaintext", children: assessment.title }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-md-6 mb-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { className: "text-muted", children: "Status" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: assessment.status })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-md-6 mb-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { className: "text-muted", children: "Progress" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex align-items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress flex-grow-1", style: { height: "10px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "progress-bar",
                role: "progressbar",
                style: { width: `${assessment.progress}%` },
                "aria-valuenow": assessment.progress,
                "aria-valuemin": "0",
                "aria-valuemax": "100"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              assessment.progress,
              "%"
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-md-6 mb-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { className: "text-muted", children: "Created" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: new Date(assessment.created_at).toLocaleString() })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-md-6 mb-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { className: "text-muted", children: "Last Updated" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: new Date(assessment.updated_at).toLocaleString() })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mb-3", children: "Responses" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4", children: assessment.responses && Object.entries(assessment.responses).map(([criteriaId, response]) => {
        const criterion = criteria.find((c2) => c2 && c2.id === criteriaId);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card border-start border-primary mb-3", style: { borderLeftWidth: "4px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-header bg-light", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { className: "mb-0", children: safeGet(criterion, "title", `Criterion ${criteriaId}`) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badge bg-secondary", children: safeGet(criterion, "category", "Uncategorized") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "fw-bold", children: "Rating:" }),
              " ",
              safeGet(response, "rating", "?"),
              "/5"
            ] }),
            safeGet(response, "comment") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "fw-bold", children: "Comment:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "p-2 bg-light rounded mt-1", children: safeGet(response, "comment", "") })
            ] })
          ] })
        ] }, criteriaId);
      }) }),
      assessment.generalComment && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mb-2", children: "General Comments" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 bg-light rounded", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: assessment.generalComment }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-footer", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: "btn btn-secondary", onClick: onClose, children: "Close" }) })
  ] }) }) });
};
const normalizeEmployeeData$1 = (employee) => {
  if (!employee) return null;
  return {
    // Use employeeID for API calls and _id for React's key prop.
    id: employee.employeeID,
    // Use employeeID for API calls
    _id: employee._id,
    // Preserve original _id for React keys
    name: employee.name || employee.staff_name || employee.fullName || "Unknown",
    email: employee.email || employee.emailAddress || "",
    department: employee.department || employee.dept || "",
    jobRole: employee.job_role || employee.jobRole || employee.position || "",
    ...employee
  };
};
const RATING_TO_PERCENTAGE = { 1: 20, 2: 40, 3: 60, 4: 80, 5: 100 };
const ManagerAssessment = () => {
  const { configid: configId, employeeId } = useParams();
  const navigate = useNavigate();
  const [loading, setLoading2] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState(null);
  const [submitting, setSubmitting] = reactExports.useState(false);
  const [showAssessment, setShowAssessment] = reactExports.useState(false);
  const [progress, setProgress] = reactExports.useState(0);
  const [selectedAssessmentType, setSelectedAssessmentType] = reactExports.useState("");
  const [assessmentTypes, setAssessmentTypes] = reactExports.useState([]);
  const [selectedEmployeeId, setSelectedEmployeeId] = reactExports.useState("");
  const [employeesList, setEmployeesList] = reactExports.useState([]);
  const [loadingEmployees, setLoadingEmployees] = reactExports.useState(false);
  const [employee, setEmployee] = reactExports.useState(null);
  const [criteria, setCriteria] = reactExports.useState([]);
  const [appraisalConfig, setAppraisalConfig] = reactExports.useState(null);
  const [currentManager, setCurrentManager] = reactExports.useState(null);
  const [currentStep, setCurrentStep] = reactExports.useState(0);
  const [assessmentForm, setAssessmentForm] = reactExports.useState({
    ratings: {},
    comments: {},
    general_comment: ""
  });
  const [assessmentSno, setAssessmentSno] = reactExports.useState(null);
  const fetchEmployeesForManager = async () => {
    setLoadingEmployees(true);
    try {
      const managerData = await APIServices2.getCurrentEmployeeData();
      setCurrentManager(managerData);
      let allEmployees = await APIServices2.getEmployees();
      let employeesData = allEmployees.filter((emp) => emp.userType === "employee");
      if (managerData) {
        const managerId = managerData.employeeID;
        employeesData = employeesData.filter((emp) => emp.employeeID !== managerId);
      }
      const normalizedEmployees = employeesData.map(normalizeEmployeeData$1);
      setEmployeesList(normalizedEmployees);
      if (normalizedEmployees.length > 0) {
        const defaultEmployeeId = normalizedEmployees[0].id;
        console.log("Setting default employee ID:", defaultEmployeeId);
        setSelectedEmployeeId(defaultEmployeeId);
      }
    } catch (err) {
      setError("Failed to load employees list.");
      setEmployeesList([]);
    } finally {
      setLoadingEmployees(false);
    }
  };
  reactExports.useEffect(() => {
    fetchEmployeesForManager();
  }, []);
  reactExports.useEffect(() => {
    if (selectedEmployeeId) {
      console.log("Employee ID changed, fetching assessment types for:", selectedEmployeeId);
      fetchAssessmentTypes(selectedEmployeeId);
    }
  }, [selectedEmployeeId]);
  const fetchAssessmentTypes = async (employeeId2) => {
    if (!employeeId2) return;
    try {
      setLoading2(true);
      console.log("Fetching assessment types for employee ID:", employeeId2);
      const types = await APIServices2.getAssessmentTypesForEmployee(employeeId2);
      console.log("Assessment types API response:", types);
      if (Array.isArray(types) && types.length > 0) {
        console.log("Setting assessment types from array:", types);
        setAssessmentTypes(types);
        setSelectedAssessmentType(types[0]);
      } else if (types && !Array.isArray(types)) {
        console.log("API returned non-array response, handling as single type");
        const typeArray = [types].flat();
        setAssessmentTypes(typeArray);
        setSelectedAssessmentType(typeArray[0]);
      } else {
        console.log("Unexpected empty response from API");
        setAssessmentTypes([]);
        setSelectedAssessmentType("");
      }
    } catch (err) {
      console.error("Error fetching assessment types:", err);
      setAssessmentTypes([]);
      setSelectedAssessmentType("");
    } finally {
      setLoading2(false);
    }
  };
  const loadAssessmentCriteria = async () => {
    try {
      console.log("ManagerAssessment: Fetching all performance criteria...");
      setLoading2(true);
      setError(null);
      const criteriaData = await APIServices2.getAllPcriteria();
      if (!Array.isArray(criteriaData)) {
        throw new Error("Criteria data is not in the expected format.");
      }
      const filteredCriteria = criteriaData.filter(
        (criterion) => !criterion.assessment_type || criterion.assessment_type === "manager" || criterion.type === "manager"
      );
      console.log("ManagerAssessment: Performance criteria fetched and filtered:", filteredCriteria);
      const transformedCriteria = filteredCriteria.map((criterion) => ({
        id: criterion.id || criterion.sno || criterion._id || `criterion_${Math.random().toString(36).substr(2, 9)}`,
        title: criterion.question || criterion.criteriaName || criterion.title || criterion.name || "Unnamed Criterion",
        description: criterion.description || criterion.desc || criterion.details || "No description available",
        category: criterion.category || criterion.type || criterion.group || "General",
        weight: criterion.weight || 1,
        ...criterion
      }));
      console.log("ManagerAssessment: Transformed criteria:", transformedCriteria);
      setCriteria(transformedCriteria);
    } catch (err) {
      console.error("Failed to load or transform assessment criteria:", err);
      setError("Failed to load assessment criteria. Please try again.");
      setCriteria([]);
      throw err;
    }
  };
  const handleStartAssessment = async () => {
    var _a2, _b;
    if (!selectedEmployeeId) {
      Swal.fire("Error", "Please select an employee to assess.", "error");
      return;
    }
    setLoading2(true);
    setError(null);
    try {
      if (!currentManager) {
        Swal.fire("Error", "Manager data is not available. Please refresh.", "error");
        setLoading2(false);
        return;
      }
      console.log("Starting assessment with employee ID:", selectedEmployeeId);
      console.log("Current manager:", currentManager);
      const activeConfigId = parseInt(configId, 10) || 1;
      console.log("Active config ID for assessment:", activeConfigId);
      console.log("Fetching employee data for ID:", selectedEmployeeId);
      try {
        const employeeData = await APIServices2.getEmployeeForManager(currentManager.employeeID, selectedEmployeeId);
        console.log("Received employee data:", employeeData);
        const normalizedEmployee2 = normalizeEmployeeData$1(employeeData);
        setEmployee(normalizedEmployee2);
      } catch (empError) {
        console.error("Error fetching employee data:", empError);
        throw new Error("Could not fetch employee data");
      }
      try {
        console.log("Loading assessment criteria...");
        await loadAssessmentCriteria();
        console.log("Assessment criteria loaded successfully");
      } catch (criteriaError) {
        console.error("Error loading assessment criteria:", criteriaError);
        throw new Error("Could not load assessment criteria");
      }
      console.log("Checking for existing assessments for employee ID:", selectedEmployeeId);
      let existingAssessments;
      try {
        existingAssessments = await APIServices2.getManagerAssessments({ employee_id: selectedEmployeeId });
        console.log("Existing assessments found:", existingAssessments);
      } catch (assessError) {
        console.error("Error fetching existing assessments:", assessError);
        throw new Error("Could not fetch existing assessments");
      }
      if (existingAssessments && existingAssessments.assessments && existingAssessments.assessments.length > 0) {
        const assessment = existingAssessments.assessments[0];
        setAssessmentSno(assessment.sno);
        setAssessmentForm({
          ratings: assessment.responses.ratings || {},
          comments: assessment.responses.comments || {}
        });
        setProgress(assessment.progress || 0);
        setCurrentStep(assessment.last_completed_step || 0);
        Swal.fire("Resumed", "Existing assessment progress has been loaded.", "info");
      } else {
        const newAssessmentData = {
          employee_id: selectedEmployeeId,
          manager_id: currentManager.employeeID,
          config_id: activeConfigId,
          // Use the active config ID, not 0
          config_sno: activeConfigId,
          // Use the active config ID, not 0
          staff_name: normalizedEmployee.name,
          // Use the just-fetched data
          type: "manager",
          status: "in_progress",
          responses: {
            ratings: {},
            comments: {}
          },
          general_comment: "",
          progress: 0,
          last_completed_step: 0,
          is_anonymous: false
        };
        console.log("Creating new assessment with config_id:", activeConfigId);
        try {
          const createdAssessment = await APIServices2.createManagerAssessment(newAssessmentData);
          console.log("Created assessment response:", createdAssessment);
          if (!createdAssessment || !createdAssessment.sno) {
            console.error("Invalid assessment response structure:", createdAssessment);
            throw new Error("Assessment created but returned invalid data");
          }
          setAssessmentSno(createdAssessment.sno);
          setAssessmentForm({
            ratings: ((_a2 = createdAssessment.responses) == null ? void 0 : _a2.ratings) || {},
            comments: ((_b = createdAssessment.responses) == null ? void 0 : _b.comments) || {}
          });
          setProgress(0);
          setCurrentStep(0);
        } catch (createError) {
          console.error("Failed to create assessment:", createError);
          throw new Error("Could not create new assessment: " + createError.message);
        }
      }
      console.log("Final state values before showing assessment:", {
        currentStep: 0,
        // We've explicitly set this to 0
        criteriaLength: criteria.length,
        showAssessment: true,
        assessmentTitle: selectedAssessmentType
      });
      if (criteria.length === 0) {
        console.warn("No criteria loaded - assessment may not display correctly");
      }
      setAppraisalConfig({ title: selectedAssessmentType });
      setShowAssessment(true);
      setTimeout(() => {
        console.log("Forcing currentStep to 0 after state update");
        setCurrentStep(0);
      }, 0);
    } catch (err) {
      console.error("Error in handleStartAssessment:", err);
      const errorMessage = err.message || "Could not start or resume the assessment.";
      Swal.fire("Error", errorMessage, "error");
    } finally {
      setLoading2(false);
    }
  };
  const handleGeneralCommentChange = (e2) => {
    setAssessmentForm((prev) => ({ ...prev, general_comment: e2.target.value }));
  };
  const handleRatingChange = (criteriaSno, rating) => {
    const newRatings = {
      ...assessmentForm.ratings,
      [criteriaSno]: rating
    };
    setAssessmentForm((prev) => ({
      ...prev,
      ratings: newRatings
    }));
    const totalRated = Object.keys(newRatings).length;
    if (totalRated > 0) {
      const totalPercentage = Object.values(newRatings).reduce((sum, r2) => sum + (RATING_TO_PERCENTAGE[r2] || 0), 0);
      const newProgress = Math.round(totalPercentage / totalRated * 100) / 100;
      setProgress(newProgress);
    }
  };
  const handleCommentChange = (criteriaId, comment) => {
    setAssessmentForm((prev) => ({
      ...prev,
      comments: { ...prev.comments, [criteriaId]: comment }
    }));
  };
  const handleNext = () => {
    if (currentStep < criteria.length - 1) {
      setCurrentStep((prev) => prev + 1);
    }
  };
  const handlePrevious = () => {
    if (currentStep > 0) {
      setCurrentStep((prev) => prev - 1);
    }
  };
  const saveDraft = () => {
    Swal.fire({
      title: "Draft Saved Locally",
      text: "Your progress is saved in this browser session. Please submit when complete.",
      icon: "success",
      toast: true,
      position: "top-end",
      showConfirmButton: false,
      timer: 3e3,
      timerProgressBar: true
    });
  };
  const handleSubmit = async () => {
    const confirmation = await Swal.fire({
      title: "Submit Manager Assessment?",
      text: "Are you sure you want to submit this manager assessment? You cannot edit it afterwards.",
      icon: "question",
      showCancelButton: true,
      confirmButtonText: "Yes, Submit",
      cancelButtonText: "Cancel",
      confirmButtonColor: "#3085d6",
      cancelButtonColor: "#d33"
    });
    if (!confirmation.isConfirmed) {
      return;
    }
    setSubmitting(true);
    console.log("Starting manager assessment submission process...");
    try {
      if (!currentManager) {
        throw new Error("Manager data not available. Please refresh.");
      }
      if (!selectedEmployeeId) {
        throw new Error("No employee selected for assessment.");
      }
      const activeConfigId = parseInt(configId, 10) || 1;
      console.log("Using config_id/config_sno:", activeConfigId);
      const responsesObj = {};
      const commentsObj = {};
      const ratingsObj = {};
      Object.keys(assessmentForm.ratings || {}).forEach((criteriaId) => {
        const criteriaDetail = criteria.find((c2) => c2.sno.toString() === criteriaId);
        const criteriaName = (criteriaDetail == null ? void 0 : criteriaDetail.criteriaName) || `Criteria ${criteriaId}`;
        const ratingValue = assessmentForm.ratings[criteriaId];
        ratingsObj[criteriaName] = ratingValue.toString();
        responsesObj[criteriaName] = ratingValue.toString();
        if (assessmentForm.comments && assessmentForm.comments[criteriaId]) {
          commentsObj[criteriaName] = assessmentForm.comments[criteriaId];
        }
      });
      const payload = {
        employee_id: selectedEmployeeId,
        manager_id: currentManager.employeeID,
        config_id: activeConfigId,
        config_sno: activeConfigId,
        staff_name: (employee == null ? void 0 : employee.name) || "",
        type: "manager",
        responses: responsesObj,
        comments: commentsObj,
        ratings: ratingsObj,
        general_comment: assessmentForm.general_comment || "",
        last_completed_step: Number(currentStep || 0),
        progress: 100,
        // Final submission is always 100%
        status: "completed",
        is_anonymous: false
      };
      console.log("Final submission payload:", JSON.stringify(payload, null, 2));
      try {
        console.log("Creating new manager assessment for submission...");
        const result = await APIServices2.createManagerAssessment(payload);
        console.log("Submission result:", result);
        if (result && result.sno) {
          const newSno = result.sno;
          setAssessmentSno(newSno);
          Swal.fire({
            title: "Assessment Submitted!",
            text: "Manager assessment has been successfully submitted.",
            icon: "success",
            confirmButtonText: "OK"
          });
          setTimeout(() => navigate("/manager-assessment-summary"), 1500);
        } else {
          throw new Error("Could not create assessment - no SNO returned");
        }
      } catch (error22) {
        console.error("Error submitting assessment:", error22);
        Swal.fire({
          title: "Submission Failed",
          text: `${error22.message || "An unknown error occurred"}`,
          icon: "error",
          confirmButtonText: "OK"
        });
      }
    } catch (error22) {
      console.error("Error during assessment preparation:", error22);
      Swal.fire({
        title: "Error",
        text: error22.message,
        icon: "error",
        confirmButtonText: "OK"
      });
    } finally {
      setSubmitting(false);
    }
  };
  const currentCriteria = criteria[currentStep];
  if (!showAssessment) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mt-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4", children: "Manager Assessment Portal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "bg-primary text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "mb-0", children: "Start a New Assessment" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardBody, { children: [
          error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { color: "danger", children: error2 }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { for: "employeeSelect", children: "Employee" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  type: "select",
                  id: "employeeSelect",
                  value: selectedEmployeeId,
                  onChange: (e2) => {
                    const employeeId2 = e2.target.value;
                    setSelectedEmployeeId(employeeId2);
                    if (employeeId2) {
                      fetchAssessmentTypes(employeeId2);
                    }
                  },
                  disabled: loadingEmployees || employeesList.length === 0,
                  children: loadingEmployees ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { children: "Loading..." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "-- Select an Employee --" }),
                    employeesList.map((emp) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: emp.employeeID, children: emp.name }, emp.employeeID))
                  ] })
                }
              )
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { for: "assessmentType", children: "Assessment Type" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  type: "select",
                  id: "assessmentType",
                  value: selectedAssessmentType,
                  onChange: (e2) => setSelectedAssessmentType(e2.target.value),
                  disabled: !selectedEmployeeId || assessmentTypes.length === 0,
                  children: !selectedEmployeeId ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "-- Select an employee first --" }) : assessmentTypes.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "No assessment types available" }) : assessmentTypes.map((type, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: type, children: type }, index2))
                }
              )
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "success", onClick: handleStartAssessment, disabled: loading || !selectedEmployeeId, children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "sm" }) : "Start Assessment" })
        ] })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "self-assessment-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "assessment-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Manager Assessment" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-muted", children: [
        "Performance evaluation for ",
        employee == null ? void 0 : employee.name
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "assessment-progress-card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "progress-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: "Assessment Progress" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "progress-percentage", children: [
          progress,
          "%"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Progress$1, { value: progress, className: "mb-2" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "step-indicator", children: [
        "Step ",
        currentStep + 1,
        " of ",
        criteria.length
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-bar-container mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "progress-bar", style: { width: `${Math.round(progress)}%` }, children: [
      Math.round(progress),
      "%"
    ] }) }),
    currentCriteria ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "assessment-criteria-card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "criteria-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: currentCriteria.criteriaName || "Performance Criteria" }),
        assessmentForm.ratings[currentCriteria.sno] && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "criteria-percentage", children: [
          RATING_TO_PERCENTAGE[assessmentForm.ratings[currentCriteria.sno]],
          "%"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rating-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { className: "rating-label", children: "Rating *" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rating-buttons", children: [1, 2, 3, 4, 5].map((rate) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            className: assessmentForm.ratings[currentCriteria.sno] === rate ? "active" : "",
            onClick: () => handleRatingChange(currentCriteria.sno, rate),
            disabled: submitting,
            children: rate
          },
          rate
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rating-scale", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Poor" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Excellent" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "comments-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { for: `comments-${currentCriteria.sno}`, children: "Manager's Comment" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            type: "textarea",
            id: `comments-${currentCriteria.sno}`,
            rows: "4",
            placeholder: "Provide your feedback...",
            value: assessmentForm.comments[currentCriteria.sno] || "",
            onChange: (e2) => handleCommentChange(currentCriteria.sno, e2.target.value),
            disabled: submitting
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { color: "warning", children: "No criteria loaded for this assessment." }),
    currentStep === criteria.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mb-0", children: "General Comments" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-body", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          className: "form-control",
          name: "general_comment",
          id: "general_comment",
          value: assessmentForm.general_comment || "",
          onChange: handleGeneralCommentChange,
          placeholder: "Provide any general comments about this self assessment...",
          disabled: submitting,
          rows: 3
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "assessment-footer-actions", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          color: "light",
          onClick: handlePrevious,
          disabled: currentStep === 0 || submitting,
          children: "Previous"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            outline: true,
            color: "primary",
            className: "mr-2",
            onClick: saveDraft,
            disabled: submitting,
            children: submitting ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "sm" }) : "Save Draft"
          }
        ),
        currentStep < criteria.length - 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "primary", onClick: handleNext, disabled: submitting, children: "Next" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "success", onClick: handleSubmit, disabled: submitting, children: submitting ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "sm" }) : "Submit Assessment" })
      ] })
    ] })
  ] });
};
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}
function constructFrom(date2, value) {
  if (date2 instanceof Date) {
    return new date2.constructor(value);
  } else {
    return new Date(value);
  }
}
function addDays(date2, amount) {
  const _date2 = toDate(date2);
  if (isNaN(amount)) return constructFrom(date2, NaN);
  _date2.setDate(_date2.getDate() + amount);
  return _date2;
}
var build = {};
var browser_min$1 = { exports: {} };
var browser_min = browser_min$1.exports;
var hasRequiredBrowser_min;
function requireBrowser_min() {
  if (hasRequiredBrowser_min) return browser_min$1.exports;
  hasRequiredBrowser_min = 1;
  (function(module, exports$1) {
    !(function(t2, e2) {
      module.exports = e2(requireReactDom(), requireReact());
    })(browser_min, (function(t2, e2) {
      function r2(t3) {
        return t3 && "object" == typeof t3 && "default" in t3 ? t3 : { default: t3 };
      }
      var o2 = r2(e2);
      function n2(t3, e3) {
        var r3 = Object.keys(t3);
        if (Object.getOwnPropertySymbols) {
          var o3 = Object.getOwnPropertySymbols(t3);
          e3 && (o3 = o3.filter((function(e4) {
            return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
          }))), r3.push.apply(r3, o3);
        }
        return r3;
      }
      function i2(t3) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? n2(Object(r3), true).forEach((function(e4) {
            a2(t3, e4, r3[e4]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(r3)) : n2(Object(r3)).forEach((function(e4) {
            Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(r3, e4));
          }));
        }
        return t3;
      }
      function a2(t3, e3, r3) {
        return e3 in t3 ? Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t3[e3] = r3, t3;
      }
      function l2(t3, e3) {
        return (function(t4) {
          if (Array.isArray(t4)) return t4;
        })(t3) || (function(t4, e4) {
          var r3 = null == t4 ? null : "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
          if (null == r3) return;
          var o3, n3, i3 = [], a3 = true, l3 = false;
          try {
            for (r3 = r3.call(t4); !(a3 = (o3 = r3.next()).done) && (i3.push(o3.value), !e4 || i3.length !== e4); a3 = true) ;
          } catch (t5) {
            l3 = true, n3 = t5;
          } finally {
            try {
              a3 || null == r3.return || r3.return();
            } finally {
              if (l3) throw n3;
            }
          }
          return i3;
        })(t3, e3) || (function(t4, e4) {
          if (!t4) return;
          if ("string" == typeof t4) return c2(t4, e4);
          var r3 = Object.prototype.toString.call(t4).slice(8, -1);
          "Object" === r3 && t4.constructor && (r3 = t4.constructor.name);
          if ("Map" === r3 || "Set" === r3) return Array.from(t4);
          if ("Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3)) return c2(t4, e4);
        })(t3, e3) || (function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        })();
      }
      function c2(t3, e3) {
        (null == e3 || e3 > t3.length) && (e3 = t3.length);
        for (var r3 = 0, o3 = new Array(e3); r3 < e3; r3++) o3[r3] = t3[r3];
        return o3;
      }
      function u2(r3, n3) {
        var a3 = r3.element, l3 = r3.popper, c3 = r3.position, u3 = void 0 === c3 ? "bottom-center" : c3, s3 = r3.containerStyle, d3 = r3.containerClassName, p3 = void 0 === d3 ? "" : d3, h2 = r3.arrow, m2 = r3.arrowStyle, v2 = void 0 === m2 ? {} : m2, b2 = r3.arrowClassName, y2 = void 0 === b2 ? "" : b2, g2 = r3.fixMainPosition, w2 = r3.fixRelativePosition, O2 = r3.offsetY, E2 = r3.offsetX, P2 = r3.animations, x2 = r3.zIndex, j2 = void 0 === x2 ? 0 : x2, M2 = r3.popperShadow, T2 = r3.onChange, S2 = r3.active, C2 = void 0 === S2 || S2, N2 = r3.portal, L2 = r3.portalTarget, R2 = "undefined" != typeof window, A2 = R2 && L2 instanceof HTMLElement, z2 = true === h2, I2 = l3 && true === C2, X = e2.useRef(), D2 = e2.useRef(), H2 = e2.useRef(), Y2 = e2.useRef(), k2 = e2.useMemo((function() {
          return { position: u3, fixMainPosition: g2, fixRelativePosition: w2, offsetY: O2, offsetX: E2, defaultArrow: z2, animations: P2, zIndex: j2, onChange: T2 };
        }), [u3, g2, w2, O2, E2, z2, P2, T2, j2]), V2 = e2.useCallback((function() {
          H2.current && (H2.current.style.transition = ""), D2.current && (D2.current.parentNode.style.transition = "");
        }), []), W2 = { element: i2({ display: "inline-block", height: "max-content" }, s3), arrow: i2({ visibility: "hidden", left: "0", top: "0", position: "absolute" }, v2), popper: { position: "absolute", left: "0", top: "0", willChange: "transform", visibility: "hidden", zIndex: j2 } };
        R2 && !Y2.current && (Y2.current = document.createElement("div"), Y2.current.data = { portal: N2, isValidPortalTarget: A2 }), e2.useEffect((function() {
          if (N2 && !A2) {
            var t3 = Y2.current;
            return document.body.appendChild(t3), function() {
              document.body.contains(t3) && document.body.removeChild(t3);
            };
          }
        }), [N2, A2]), e2.useEffect((function() {
          if (!I2) return V2(), D2.current.parentNode.style.visibility = "hidden", void (H2.current && (H2.current.style.visibility = "hidden"));
          function t3(t4) {
            t4 && "resize" !== t4.type && !t4.target.contains(X.current) || (t4 && V2(), f2(X, D2, H2, k2, t4));
          }
          return t3(), document.addEventListener("scroll", t3, true), window.addEventListener("resize", t3), function() {
            document.removeEventListener("scroll", t3, true), window.removeEventListener("resize", t3);
          };
        }), [I2, k2, V2]), e2.useEffect((function() {
          var t3 = { portal: N2, isValidPortalTarget: A2 }, e3 = Y2.current.data;
          JSON.stringify(t3) !== JSON.stringify(e3) && (Y2.current.data = t3, X.current.refreshPosition());
        }), [N2, A2]);
        var q = o2.default.createElement(o2.default.Fragment, null, (function() {
          if (!h2 || !I2) return null;
          var t3 = o2.default.createElement("div", { ref: H2, style: W2.arrow }), r4 = e2.isValidElement(h2) ? { children: h2 } : { className: "ep-arrow ".concat(M2 ? "ep-shadow" : "", " ").concat(y2) };
          return e2.cloneElement(t3, r4);
        })(), o2.default.createElement("div", { className: M2 ? "ep-popper-shadow" : "", style: W2.popper }, o2.default.createElement("div", { ref: D2 }, l3)));
        return o2.default.createElement("div", { ref: function(t3) {
          t3 && (t3.removeTransition = V2, t3.refreshPosition = function() {
            return setTimeout((function() {
              return f2(X, D2, H2, k2, {});
            }), 10);
          });
          if (X.current = t3, n3 instanceof Function) return n3(t3);
          n3 && (n3.current = t3);
        }, className: p3, style: W2.element }, a3, N2 && R2 ? t2.createPortal(q, A2 ? L2 : Y2.current) : q);
      }
      function f2(t3, e3, r3, o3, n3) {
        var a3 = o3.position, c3 = o3.fixMainPosition, u3 = o3.fixRelativePosition, f3 = o3.offsetY, h2 = void 0 === f3 ? 0 : f3, m2 = o3.offsetX, v2 = void 0 === m2 ? 0 : m2, b2 = o3.defaultArrow, y2 = o3.animations, g2 = void 0 === y2 ? [] : y2, w2 = o3.zIndex, O2 = o3.onChange;
        if (t3.current && e3.current) {
          var E2, P2, x2, j2, M2 = (P2 = void 0 !== window.pageXOffset, x2 = "CSS1Compat" === (document.compatMode || ""), { scrollLeft: P2 ? window.pageXOffset : x2 ? document.documentElement.scrollLeft : document.body.scrollLeft, scrollTop: P2 ? window.pageYOffset : x2 ? document.documentElement.scrollTop : document.body.scrollTop }), T2 = M2.scrollLeft, S2 = M2.scrollTop, C2 = s2(t3.current, T2, S2), N2 = C2.top, L2 = C2.left, R2 = C2.height, A2 = C2.width, z2 = C2.right, I2 = C2.bottom, X = s2(e3.current, T2, S2), D2 = X.top, H2 = X.left, Y2 = X.height, k2 = X.width, V2 = document.documentElement, W2 = V2.clientHeight, q = V2.clientWidth, F2 = e3.current.parentNode, J2 = (function(t4) {
            if (!t4) return [0, 0];
            var e4 = l2((t4.style.transform.match(/translate\((.*?)px,\s(.*?)px\)/) || []).map((function(t5) {
              return Number(t5);
            })), 3), r4 = e4[1], o4 = void 0 === r4 ? 0 : r4, n4 = e4[2];
            return [o4, void 0 === n4 ? 0 : n4];
          })(F2), B = l2(J2, 2), U2 = B[0], $2 = B[1], G = (function(t4) {
            var e4 = l2(t4.split("-"), 2), r4 = e4[0], o4 = void 0 === r4 ? "bottom" : r4, n4 = e4[1], i3 = void 0 === n4 ? "center" : n4;
            "auto" === o4 && (o4 = "bottom");
            "auto" === i3 && (i3 = "center");
            var a4 = "top" === o4 || "bottom" === o4, c4 = "left" === o4 || "right" === o4;
            c4 && ("start" === i3 && (i3 = "top"), "end" === i3 && (i3 = "bottom"));
            a4 && ("start" === i3 && (i3 = "left"), "end" === i3 && (i3 = "right"));
            return [o4, i3, a4, c4];
          })(a3), K = l2(G, 4), Q = K[0], Z = K[1], _2 = K[2], tt = K[3], et = Q, rt = function(t4, e4) {
            return "translate(".concat(t4, "px, ").concat(e4, "px)");
          }, ot = A2 - k2, nt = R2 - Y2, it = "left" === Z ? 0 : "right" === Z ? ot : ot / 2, at = ot - it, lt = "top" === Z ? 0 : "bottom" === Z ? nt : nt / 2, ct = nt - lt, ut = L2 - H2 + U2, ft = N2 - D2 + $2, st = 0, dt = 0, pt = d2(t3.current), ht = [], mt = r3.current, vt = s2(mt, T2, S2) || {}, bt = vt.height, yt = void 0 === bt ? 0 : bt, gt = vt.width, wt = void 0 === gt ? 0 : gt, Ot = ut, Et = ft, Pt = { top: "bottom", bottom: "top", left: "right", right: "left" };
          for (_2 && (ut += it, ft += "top" === Q ? -Y2 : R2, b2 && (yt = 11, wt = 20)), tt && (ut += "left" === Q ? -k2 : A2, ft += lt, b2 && (yt = 20, wt = 11)); pt; ) ht.push(pt), jt(s2(pt, T2, S2)), pt = d2(pt.parentNode);
          if (jt({ top: S2, bottom: S2 + W2, left: T2, right: T2 + q, height: W2, width: q }), _2 && (ft += "bottom" === et ? h2 : -h2), tt && (ut += "right" === et ? v2 : -v2), ut -= st, ft -= dt, E2 = Pt[et], mt) _2 && ((j2 = A2 < k2) ? Ot += A2 / 2 : Ot = ut + k2 / 2, Ot -= wt / 2, "bottom" === et && (Et = ft, ft += yt), "top" === et && (Et = (ft -= yt) + Y2), st < 0 && st - it < 0 && (j2 ? Ot += (it - st) / 2 : A2 - it + st < k2 && (Ot += (A2 - it + st - k2) / 2)), st > 0 && st + at > 0 && (j2 ? Ot -= (st + at) / 2 : A2 - st - at < k2 && (Ot -= (A2 - st - at - k2) / 2))), tt && ((j2 = R2 < Y2) ? Et += R2 / 2 : Et = ft + Y2 / 2, Et -= yt / 2, "left" === et && (Ot = (ut -= wt) + k2), "right" === et && (Ot = ut, ut += wt), dt < 0 && dt - lt < 0 && (j2 ? Et += (lt - dt) / 2 : R2 - lt + dt < Y2 && (Et += (R2 - lt + dt - Y2) / 2)), dt > 0 && dt + ct > 0 && (j2 ? Et -= (dt + ct) / 2 : R2 - dt - ct < Y2 && (Et -= (R2 - dt - ct - Y2) / 2))), mt.setAttribute("direction", E2), mt.style.height = yt + "px", mt.style.width = wt + "px", mt.style.transform = rt(Ot, Et), mt.style.visibility = "visible", mt.style.zIndex = w2 + 1;
          F2.style.transform = rt(ut, ft);
          var xt = { popper: { top: ft, bottom: ft + Y2, left: ut, right: ut + k2, height: Y2, width: k2 }, element: { top: N2, bottom: I2, left: L2, right: z2, height: R2, width: A2 }, arrow: { top: Et, bottom: Et + yt, left: Ot, right: Ot + wt, height: yt, width: wt, direction: E2 }, position: et + "-" + (0 !== st ? "auto" : Z), scroll: { scrollLeft: T2, scrollTop: S2 }, scrollableParents: ht, event: n3 };
          n3 || g2.forEach((function(t4) {
            t4({ popper: F2, arrow: mt, data: i2(i2({}, xt), {}, { getTransform: rt, mirror: Pt }) });
          })), F2.style.visibility = "visible", "function" == typeof O2 && O2(xt);
        }
        function jt(t4) {
          var e4 = t4.top, r4 = t4.bottom, o4 = t4.left, n4 = t4.right, i3 = t4.height, a4 = t4.width;
          if (_2) {
            var l3 = Math.round(N2 - e4 + R2 / 2), f4 = Math.round(i3 / 2);
            c3 || (N2 - (Y2 + h2 + yt) < e4 && l3 <= f4 && "top" === et ? (ft += Y2 + R2, et = "bottom") : I2 + Y2 + h2 + yt > i3 + e4 && l3 >= f4 && "bottom" === et && (ft -= Y2 + R2, et = "top")), u3 || (L2 + it < o4 && (st = p2(z2 - wt > o4 ? L2 + it - o4 : -A2 + it + wt, st)), z2 - at > n4 && (st = p2(L2 + wt < n4 ? z2 - at - n4 : A2 - at - wt, st)));
          }
          if (tt) {
            var s3 = Math.round(L2 - o4 + A2 / 2), d3 = Math.round(a4 / 2);
            c3 || (L2 - (k2 + v2 + wt) < o4 && s3 < d3 && "left" === et ? (ut += A2 + k2, et = "right") : z2 + k2 + v2 + wt > n4 && s3 > d3 && "right" === et && (ut -= A2 + k2, et = "left")), u3 || (N2 + lt < e4 && (dt = p2(I2 - yt > e4 ? N2 + lt - e4 : -R2 + lt + yt, dt)), I2 - ct > r4 && (dt = p2(N2 + yt < r4 ? I2 - ct - r4 : R2 - ct - yt, dt)));
          }
        }
      }
      function s2(t3, e3, r3) {
        if (t3) {
          var o3 = t3.getBoundingClientRect(), n3 = o3.top, i3 = o3.left, a3 = o3.width, l3 = o3.height, c3 = n3 + r3, u3 = i3 + e3;
          return { top: c3, bottom: c3 + l3, left: u3, right: u3 + a3, width: a3, height: l3 };
        }
      }
      function d2(t3) {
        if (t3 && "HTML" !== t3.tagName) {
          var e3 = window.getComputedStyle(t3), r3 = function(t4) {
            return ["auto", "scroll"].includes(t4);
          };
          return t3.clientHeight < t3.scrollHeight && r3(e3.overflowX) || t3.clientWidth < t3.scrollWidth && r3(e3.overflowY) ? t3 : d2(t3.parentNode);
        }
      }
      function p2(t3, e3) {
        return Math.round(Math.abs(t3)) > Math.round(Math.abs(e3)) ? t3 : e3;
      }
      return e2.forwardRef(u2);
    }));
  })(browser_min$1);
  return browser_min$1.exports;
}
function t(e2) {
  return t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t2) {
    return typeof t2;
  } : function(t2) {
    return t2 && "function" == typeof Symbol && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
  }, t(e2);
}
function e(t2) {
  return (function(t3) {
    if (Array.isArray(t3)) return c(t3);
  })(t2) || n(t2) || h(t2) || (function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  })();
}
function n(t2) {
  if ("undefined" != typeof Symbol && null != t2[Symbol.iterator] || null != t2["@@iterator"]) return Array.from(t2);
}
function r(t2, e2) {
  var n2 = "undefined" != typeof Symbol && t2[Symbol.iterator] || t2["@@iterator"];
  if (!n2) {
    if (Array.isArray(t2) || (n2 = h(t2)) || e2) {
      n2 && (t2 = n2);
      var r2 = 0, i2 = function() {
      };
      return { s: i2, n: function() {
        return r2 >= t2.length ? { done: true } : { done: false, value: t2[r2++] };
      }, e: function(t3) {
        throw t3;
      }, f: i2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var a2, s2 = true, u2 = false;
  return { s: function() {
    n2 = n2.call(t2);
  }, n: function() {
    var t3 = n2.next();
    return s2 = t3.done, t3;
  }, e: function(t3) {
    u2 = true, a2 = t3;
  }, f: function() {
    try {
      s2 || null == n2.return || n2.return();
    } finally {
      if (u2) throw a2;
    }
  } };
}
function i(t2, e2) {
  var n2 = Object.keys(t2);
  if (Object.getOwnPropertySymbols) {
    var r2 = Object.getOwnPropertySymbols(t2);
    e2 && (r2 = r2.filter((function(e3) {
      return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
    }))), n2.push.apply(n2, r2);
  }
  return n2;
}
function a(t2) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var n2 = null != arguments[e2] ? arguments[e2] : {};
    e2 % 2 ? i(Object(n2), true).forEach((function(e3) {
      s(t2, e3, n2[e3]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(n2)) : i(Object(n2)).forEach((function(e3) {
      Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(n2, e3));
    }));
  }
  return t2;
}
function s(t2, e2, n2) {
  return (e2 = y(e2)) in t2 ? Object.defineProperty(t2, e2, { value: n2, enumerable: true, configurable: true, writable: true }) : t2[e2] = n2, t2;
}
function u(t2, e2) {
  return l(t2) || (function(t3, e3) {
    var n2 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
    if (null != n2) {
      var r2, i2, a2, s2, u2 = [], o2 = true, h2 = false;
      try {
        if (a2 = (n2 = n2.call(t3)).next, 0 === e3) {
          if (Object(n2) !== n2) return;
          o2 = false;
        } else for (; !(o2 = (r2 = a2.call(n2)).done) && (u2.push(r2.value), u2.length !== e3); o2 = true) ;
      } catch (t4) {
        h2 = true, i2 = t4;
      } finally {
        try {
          if (!o2 && null != n2.return && (s2 = n2.return(), Object(s2) !== s2)) return;
        } finally {
          if (h2) throw i2;
        }
      }
      return u2;
    }
  })(t2, e2) || h(t2, e2) || o();
}
function o() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function h(t2, e2) {
  if (t2) {
    if ("string" == typeof t2) return c(t2, e2);
    var n2 = Object.prototype.toString.call(t2).slice(8, -1);
    return "Object" === n2 && t2.constructor && (n2 = t2.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(t2) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? c(t2, e2) : void 0;
  }
}
function c(t2, e2) {
  (null == e2 || e2 > t2.length) && (e2 = t2.length);
  for (var n2 = 0, r2 = new Array(e2); n2 < e2; n2++) r2[n2] = t2[n2];
  return r2;
}
function l(t2) {
  if (Array.isArray(t2)) return t2;
}
function f(t2, e2) {
  for (var n2 = 0; n2 < e2.length; n2++) {
    var r2 = e2[n2];
    r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t2, y(r2.key), r2);
  }
}
function y(e2) {
  var n2 = (function(e3, n3) {
    if ("object" !== t(e3) || null === e3) return e3;
    var r2 = e3[Symbol.toPrimitive];
    if (void 0 !== r2) {
      var i2 = r2.call(e3, n3);
      if ("object" !== t(i2)) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(e3);
  })(e2, "string");
  return "symbol" === t(n2) ? n2 : String(n2);
}
function d(t2, e2, n2) {
  !(function(t3, e3) {
    if (e3.has(t3)) throw new TypeError("Cannot initialize the same private elements twice on an object");
  })(t2, e2), e2.set(t2, n2);
}
function m(t2, e2) {
  return (function(t3, e3) {
    if (e3.get) return e3.get.call(t3);
    return e3.value;
  })(t2, g(t2, e2, "get"));
}
function v(t2, e2, n2) {
  return (function(t3, e3, n3) {
    if (e3.set) e3.set.call(t3, n3);
    else {
      if (!e3.writable) throw new TypeError("attempted to set read only private field");
      e3.value = n3;
    }
  })(t2, g(t2, e2, "set"), n2), n2;
}
function g(t2, e2, n2) {
  if (!e2.has(t2)) throw new TypeError("attempted to " + n2 + " private field on non-instance");
  return e2.get(t2);
}
function p(t2) {
  return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
}
function k(t2) {
  return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
}
var b = { name: "gregorian_en", months: [["January", "Jan"], ["February", "Feb"], ["March", "Mar"], ["April", "Apr"], ["May", "May"], ["June", "Jun"], ["July", "Jul"], ["August", "Aug"], ["September", "Sep"], ["October", "Oct"], ["November", "Nov"], ["December", "Dec"]], weekDays: [["Saturday", "Sat"], ["Sunday", "Sun"], ["Monday", "Mon"], ["Tuesday", "Tue"], ["Wednesday", "Wed"], ["Thursday", "Thu"], ["Friday", "Fri"]], digits: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], meridiems: [["AM", "am"], ["PM", "pm"]] }, w = { name: "gregorian", startYear: 1, yearLength: 365, epoch: 1721424, century: 20, weekStartDayIndex: 1, getMonthLengths: function(t2) {
  return [31, t2 ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
}, isLeap: function(t2) {
  return t2 % 4 == 0 && t2 % 100 != 0 || t2 % 400 == 0;
}, getLeaps: function(t2) {
  if (0 !== t2) {
    for (var e2 = t2 > 0 ? 1 : -1, n2 = []; t2 > 0 ? e2 <= t2 : t2 <= e2; ) this.isLeap(e2) && n2.push(e2), t2 > 0 ? e2++ : e2--;
    return n2;
  }
}, getDayOfYear: function(t2) {
  for (var e2 = t2.year, n2 = t2.month, r2 = t2.day, i2 = this.getMonthLengths(this.isLeap(e2)), a2 = 0; a2 < n2.index; a2++) r2 += i2[a2];
  return r2;
}, getAllDays: function(t2) {
  var e2 = t2.year;
  return this.yearLength * (e2 - 1) + this.leapsLength(e2) + this.getDayOfYear(t2);
}, leapsLength: function(t2) {
  return ((t2 - 1) / 4 | 0) + (-(t2 - 1) / 100 | 0) + ((t2 - 1) / 400 | 0);
}, guessYear: function(t2, e2) {
  return ~~(t2 / 365.24) + (e2 > 0 ? 1 : -1);
} };
function D(t2) {
  return t2 && t2.constructor === Object;
}
function M(t2) {
  if (!isNaN(t2)) return parseInt(t2);
}
function O(t2) {
  return Array.isArray(t2);
}
function S(t2, e2, n2) {
  return void 0 === t2 || t2 < e2 || t2 > n2;
}
var Y = /* @__PURE__ */ new WeakMap(), L = /* @__PURE__ */ new WeakMap(), W = /* @__PURE__ */ new WeakMap(), j = /* @__PURE__ */ new WeakMap(), x = /* @__PURE__ */ new WeakMap(), N = /* @__PURE__ */ new WeakMap(), A = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakMap(), P = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap(), H = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap(), z = (function() {
  function i2(t2) {
    var e2 = this;
    !(function(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    })(this, i2), d(this, Y, { writable: true, value: void 0 }), d(this, L, { writable: true, value: void 0 }), d(this, W, { writable: true, value: void 0 }), d(this, j, { writable: true, value: void 0 }), d(this, x, { writable: true, value: void 0 }), d(this, N, { writable: true, value: void 0 }), d(this, A, { writable: true, value: void 0 }), d(this, I, { writable: true, value: void 0 }), d(this, P, { writable: true, value: b }), d(this, T, { writable: true, value: w }), d(this, F, { writable: true, value: false }), d(this, E, { writable: true, value: {} }), d(this, H, { writable: true, value: /^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d\.\d\d\dZ$/ }), d(this, V, { writable: true, value: [] }), d(this, J, { writable: true, value: true }), d(this, _, { writable: true, value: function(t3, n3) {
      switch (t3) {
        case "YYYY":
          return ["year", n3];
        case "YY":
          return ["year", "".concat(m(e2, T).century).concat(n3)];
        case "MMMM":
        case "MMM":
          return ["month", e2.months.findIndex((function(t4) {
            var e3 = t4.name, r4 = t4.shortName;
            return new RegExp(n3, "i").test(e3 + r4);
          })) + 1];
        case "MM":
        case "M":
          return ["month", n3];
        case "DD":
        case "D":
          return ["day", n3];
        case "HH":
        case "H":
          return ["hour", n3];
        case "hh":
        case "h":
          var r3 = M(n3);
          return ["hour", r3 > 12 ? r3 - 12 : r3];
        case "mm":
        case "m":
          return ["minute", n3];
        case "ss":
        case "s":
          return ["second", n3];
        case "SSS":
        case "SS":
        case "S":
          return ["millisecond", n3];
        default:
          return [];
      }
    } }), d(this, C, { writable: true, value: function() {
      return 0 === m(e2, Y) && 0 !== m(e2, T).startYear;
    } }), d(this, U, { writable: true, value: function() {
      if (m(e2, J) && e2.isValid) {
        var t3 = Math.floor, n3 = function(e3, n4) {
          return [(a3 = e3, (a3 < 0 ? -1 : 1) * Math.abs(t3(e3 / n4))), (r4 = e3, i4 = n4, (r4 < 0 && -0 !== t3(r4 % i4) ? i4 : 0) + t3(e3 % n4))];
          var r4, i4, a3;
        }, r3 = function() {
          if (m(e2, L) < 0 || m(e2, L) > 11) {
            var t4 = m(e2, L) < 0 ? -1 : 1, r4 = u(n3(m(e2, L), 12), 2), i4 = r4[0], a3 = r4[1];
            v(e2, Y, m(e2, Y) + i4), v(e2, L, a3), m(e2, C).call(e2) && v(e2, Y, t4);
          }
        };
        for (v(e2, J, false), [["millisecond", "second", 1e3], ["second", "minute", 60], ["minute", "hour", 60], ["hour", "day", 24]].forEach((function(t4) {
          var r4 = u(t4, 3), i4 = r4[0], a3 = r4[1], s5 = r4[2];
          if ((function(t5, e3) {
            return t5 >= e3 || t5 < 0;
          })(e2[i4], s5)) {
            var o3 = u(n3(e2[i4], s5), 2), h2 = o3[0], c3 = o3[1];
            e2[a3] += h2, e2[i4] = c3;
          }
        })), v(e2, J, true), r3(); m(e2, W) < -m(e2, T).yearLength || m(e2, W) > m(e2, T).yearLength; ) {
          if (m(e2, L) > 0) {
            for (var i3 = m(e2, T).getMonthLengths(e2.isLeap), a2 = 0; a2 < m(e2, L); a2++) v(e2, W, m(e2, W) + i3[a2]);
            v(e2, L, 0);
          }
          var s4 = e2.isLeap ? e2.calendar.yearLength + 1 : e2.calendar.yearLength;
          v(e2, W, m(e2, W) + s4 * (m(e2, W) < 0 ? 1 : -1)), v(e2, Y, m(e2, Y) + (m(e2, W) < 0 ? -1 : 1));
        }
        for (; ; ) {
          var o2;
          for (r3(); m(e2, W) < 1; ) v(e2, L, m(e2, L) - 1), r3(), v(e2, W, e2.month.length + m(e2, W));
          if (m(e2, W) <= e2.month.length || isNaN(m(e2, W))) break;
          v(e2, W, m(e2, W) - e2.month.length), v(e2, L, (o2 = m(e2, L), o2++, o2));
        }
        m(e2, j) || v(e2, j, 0), m(e2, x) || v(e2, x, 0), m(e2, N) || v(e2, N, 0), m(e2, A) || v(e2, A, 0);
      }
    } }), d(this, R, { writable: true, value: function() {
      return (m(e2, E).weekDays || m(e2, P).weekDays).map((function(t3, n3) {
        var r3 = u(t3, 2), i3 = r3[0], a2 = r3[1], s4 = n3 - e2.weekStartDayIndex;
        return s4 < 0 && (s4 += 7), { name: i3, shortName: a2, index: s4, number: s4 + 1, toString: function() {
          return this.number.toString();
        }, valueOf: function() {
          return this.number;
        } };
      }));
    } });
    var n2 = D(t2) ? a({}, t2) : t2, r2 = true;
    if (n2 && "boolean" != typeof n2 || (n2 = { date: /* @__PURE__ */ new Date() }), D(n2) || (n2 = { date: n2 }), 0 !== Object.keys(n2).length) {
      for (var s3 in D(n2.calendar) && v(this, T, n2.calendar), D(n2.locale) && v(this, P, n2.locale), isNaN(n2.year) && isNaN(n2.month) && isNaN(n2.day) && !n2.date && (n2.date = /* @__PURE__ */ new Date()), n2.date && ("string" == typeof n2.date && n2.format && v(this, I, n2.format), this.setDate(n2.date), n2.calendar && this.convert(n2.calendar), r2 = false), delete n2.calendar, delete n2.locale, delete n2.date, n2) this.set(s3, n2[s3]);
      m(this, C).call(this) && v(this, Y, -1), r2 && m(this, U).call(this);
    }
  }
  var s2, c2;
  return s2 = i2, c2 = [{ key: "parse", value: function(t2) {
    if (!t2) return this;
    var i3, a2, s3 = m(this, I), c3 = m(this, P).digits, f2 = r(c3);
    try {
      for (f2.s(); !(i3 = f2.n()).done; ) {
        var y2 = i3.value;
        t2 = t2.replace(new RegExp(y2, "g"), c3.indexOf(y2));
      }
    } catch (t3) {
      f2.e(t3);
    } finally {
      f2.f();
    }
    if (s3) for (var d2 = s3.split(/[^\w\u0600-\u06FF]/), g2 = t2.split(/[^\w\u0600-\u06FF]/), p2 = 0; p2 < d2.length; p2++) this.set.apply(this, e(m(this, _).call(this, d2[p2], g2[p2])));
    else {
      var k2 = t2.match(/(-?\d{2,4})?\W?([A-z]{3,9}|\d{1,2})?\W?(\d{1,2})?\W?(\d{1,2})?\W?(\d{1,2})?\W?(\d{1,2})?\W?(\d{1,3})?\W?(am|pm)?/), b2 = (l(a2 = k2) || n(a2) || h(a2) || o()).slice(1), w2 = b2[1];
      w2 && (w2 = /\d+/.test(w2) ? M(w2) - 1 : this.months.findIndex((function(t3) {
        return new RegExp(w2, "i").test(t3.name);
      }))), b2[1] = w2;
      var D2 = u(b2.map(M), 7), O2 = D2[0], S2 = D2[1], T2 = D2[2], F2 = D2[3], E2 = D2[4], H2 = D2[5], V2 = D2[6];
      v(this, Y, O2), v(this, L, S2), v(this, W, T2), v(this, j, F2), v(this, x, E2), v(this, N, H2), v(this, A, V2);
    }
    var J2 = u(m(this, P).meridiems[1], 2), C2 = J2[0], R2 = J2[1];
    return m(this, j) < 12 && (t2.includes(C2) || t2.includes(R2)) && v(this, j, m(this, j) + 12), m(this, U).call(this), this;
  } }, { key: "convert", value: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : w, e2 = arguments.length > 1 ? arguments[1] : void 0;
    if (D(e2) && v(this, P, e2), !D(t2) || t2.name === m(this, T).name) return this;
    var n2 = this.toJulianDay() - t2.epoch, r2 = new i2({ calendar: t2, year: t2.guessYear(n2, m(this, Y)), month: 1, day: 1 });
    return r2.day += n2 - r2.toDays(), v(this, Y, r2.year), v(this, L, r2.month.index), v(this, W, r2.day), v(this, T, t2), this;
  } }, { key: "format", value: function(e2, n2) {
    if (!this.isValid || e2 && "string" != typeof e2) return "";
    e2 || (e2 = m(this, I) || "YYYY/MM/DD"), O(n2) || (n2 = []), n2 = (n2 = n2.concat(m(this, V))).filter((function(e3) {
      return "string" == typeof e3 || (console.warn("type of all items in the ignore list must be string, found", t(e3)), false);
    })).map((function(t2) {
      return t2.replace(/[*/+\-()[\]{}\s$^]/g, (function(t3) {
        return "\\" + t3;
      }));
    }));
    var i3, a2 = new RegExp("".concat(n2.join("|")).concat(n2.length > 0 ? "|" : "", "YYYY|YY|MMMM|MMM|MM|M|WW|W|DDDD|DDD|DD|D|dddd|ddd|dd|d|HH|H|hh|h|mm|m|ss|s|SSS|SS|S|A|a|."), "g"), s3 = "", u2 = r(e2.match(a2) || []);
    try {
      for (u2.s(); !(i3 = u2.n()).done; ) {
        var o2 = i3.value, h2 = this.getValue(o2);
        s3 += n2.includes(o2) ? o2 : 0 === h2 ? h2 : h2 || o2;
      }
    } catch (t2) {
      u2.e(t2);
    } finally {
      u2.f();
    }
    var c3 = this.digits;
    return s3.replace(/[0-9]/g, (function(t2) {
      return c3[t2];
    }));
  } }, { key: "getProperty", value: function(t2) {
    return this.getValue(t2);
  } }, { key: "getValue", value: function(t2) {
    var e2 = function(t3) {
      return t3 < 10 ? "0" + t3 : t3;
    };
    switch (t2) {
      case "YYYY":
        return this.year;
      case "YY":
        return this.year.toString().substring(2, 4);
      case "MMMM":
        return this.month.name;
      case "MMM":
        return this.month.shortName;
      case "MM":
        return e2(this.month.number);
      case "M":
        return this.month.number;
      case "WW":
        return e2(this.weekOfYear);
      case "W":
        return this.weekOfYear;
      case "DDDD":
      case "DDD":
        return this.dayOfYear;
      case "DD":
        return e2(this.day);
      case "D":
        return this.day;
      case "HH":
        return e2(this.hour);
      case "H":
        return this.hour;
      case "dddd":
        return this.weekDay.name;
      case "ddd":
        return this.weekDay.shortName;
      case "dd":
        return e2(this.weekDay.number);
      case "d":
        return this.weekDay.number;
      case "hh":
        return e2(this.hour > 12 ? this.hour - 12 : this.hour || 12);
      case "h":
        return this.hour > 12 ? this.hour - 12 : this.hour || 12;
      case "mm":
        return e2(this.minute);
      case "m":
        return this.minute;
      case "ss":
        return e2(this.second);
      case "s":
        return this.second;
      case "SSS":
        return m(this, A) < 10 ? "00".concat(m(this, A)) : m(this, A) < 100 ? "0".concat(m(this, A)) : m(this, A);
      case "SS":
        return m(this, A) < 10 ? "00" : m(this, A) < 100 ? ("0" + m(this, A)).substring(2, 0) : m(this, A).toString().substring(0, 2);
      case "S":
        return m(this, A) < 10 || m(this, A) < 100 ? "0" : m(this, A).toString().substring(0, 1);
      case "a":
        return this.hour >= 12 ? m(this, P).meridiems[1][1] : m(this, P).meridiems[0][1];
      case "A":
        return this.hour >= 12 ? m(this, P).meridiems[1][0] : m(this, P).meridiems[0][0];
      default:
        return "";
    }
  } }, { key: "setYear", value: function(t2) {
    return this.year = t2, this;
  } }, { key: "setMonths", value: function(t2) {
    return this.months = t2, this;
  } }, { key: "setMonth", value: function(t2) {
    return this.month = t2, this;
  } }, { key: "setWeekDays", value: function(t2) {
    return this.weekDays = t2, this;
  } }, { key: "setDigits", value: function(t2) {
    return this.digits = t2, this;
  } }, { key: "setDay", value: function(t2) {
    return this.day = t2, this;
  } }, { key: "setHour", value: function(t2) {
    return this.hour = t2, this;
  } }, { key: "setMinute", value: function(t2) {
    return this.minute = t2, this;
  } }, { key: "setSecond", value: function(t2) {
    return this.second = t2, this;
  } }, { key: "setMillisecond", value: function(t2) {
    return this.millisecond = t2, this;
  } }, { key: "setFormat", value: function(t2) {
    return v(this, I, t2), this;
  } }, { key: "setLocale", value: function(t2) {
    return this.locale = t2, this;
  } }, { key: "setCalendar", value: function(t2) {
    return this.calendar = t2, this;
  } }, { key: "setDate", value: function(t2) {
    if ("string" == typeof t2) {
      if (!m(this, H).test(t2)) return this.parse(t2);
      t2 = new Date(t2);
    }
    return "number" == typeof t2 && (t2 = new Date(t2)), t2 instanceof Date && (v(this, T, w), v(this, Y, t2.getFullYear()), v(this, L, t2.getMonth()), v(this, W, t2.getDate()), v(this, j, t2.getHours()), v(this, x, t2.getMinutes()), v(this, N, t2.getSeconds()), v(this, A, t2.getMilliseconds()), v(this, F, false)), t2 instanceof i2 && (v(this, Y, t2.year), v(this, L, t2.month.index), v(this, W, t2.day), v(this, j, t2.hour), v(this, x, t2.minute), v(this, N, t2.second), v(this, A, t2.millisecond), v(this, P, t2.locale), v(this, I, t2._format), v(this, T, t2.calendar), v(this, F, t2.isUTC), v(this, V, t2.ignoreList), v(this, E, t2.custom)), this;
  } }, { key: "setIgnoreList", value: function(t2) {
    return this.ignoreList = t2, this;
  } }, { key: "set", value: function(t2, e2) {
    if (null == t2) return this;
    if (D(t2)) {
      var n2 = a({}, t2);
      for (var r2 in n2.date && (this.setDate(n2.date), delete n2.date), n2.calendar && (this.convert(n2.calendar), delete n2.calendar), n2.locale && (this.setLocale(n2.locale), delete n2.locale), v(this, J, false), n2) this.set(r2, n2[r2]);
      return v(this, J, true), m(this, U).call(this), this;
    }
    "format" === t2 && (t2 = "_format");
    try {
      this[t2] = e2;
    } catch (t3) {
    }
    return this;
  } }, { key: "add", value: function(t2, e2) {
    if (!(t2 = M(t2)) || !e2) return this;
    switch (e2) {
      case "years":
      case "y":
        e2 = "year";
        break;
      case "months":
      case "M":
        e2 = "month";
        break;
      case "days":
      case "d":
        e2 = "day";
        break;
      case "hours":
      case "h":
        e2 = "hour";
        break;
      case "minutes":
      case "m":
        e2 = "minute";
        break;
      case "seconds":
      case "s":
        e2 = "second";
        break;
      case "milliseconds":
      case "ms":
        e2 = "millisecond";
    }
    return this[e2] += t2, this;
  } }, { key: "subtract", value: function(t2, e2) {
    return this.add(-t2, e2);
  } }, { key: "toFirstOfYear", value: function() {
    return this.month = 1, this.day = 1, this;
  } }, { key: "toLastOfYear", value: function() {
    return this.day >= 29 && (this.day = 29), this.month = 12, this.toLastOfMonth(), this;
  } }, { key: "toFirstOfMonth", value: function() {
    return v(this, W, 1), this;
  } }, { key: "toLastOfMonth", value: function() {
    return v(this, W, 0), v(this, L, m(this, L) + 1), m(this, U).call(this), this;
  } }, { key: "toFirstOfWeek", value: function() {
    return this.day -= this.weekDay.index, this;
  } }, { key: "toLastOfWeek", value: function() {
    return this.day += 6 - this.weekDay.index, this;
  } }, { key: "toFirstWeekOfYear", value: function() {
    return this.toFirstOfYear(), 0 === this.weekDay.index ? this : this.toLastOfWeek().setDay(this.day + 1);
  } }, { key: "toLastWeekOfYear", value: function() {
    return this.toLastOfYear().toFirstOfWeek();
  } }, { key: "toString", value: function() {
    return this.format();
  } }, { key: "toDate", value: function() {
    var t2 = new i2(this);
    return "gregorian" !== m(this, T).name && t2.convert(w), new Date(t2.year, t2.month.index, t2.day, t2.hour, t2.minute, t2.second, t2.millisecond);
  } }, { key: "toUTC", value: function() {
    return m(this, F) || (this.minute += this.toDate().getTimezoneOffset(), v(this, F, true)), this;
  } }, { key: "toUnix", value: function() {
    return this.unix;
  } }, { key: "toJulianDay", value: function() {
    return this.toDays() + m(this, T).epoch;
  } }, { key: "toObject", value: function() {
    return { year: m(this, Y), month: this.month, day: m(this, W), weekDay: this.weekDay, hour: m(this, j), minute: m(this, x), second: m(this, N), millisecond: m(this, A), weekOfYear: this.weekOfYear, dayOfYear: this.dayOfYear, daysLeft: this.daysLeft, calendar: m(this, T), locale: m(this, P), format: m(this, I) || "YYYY/MM/DD", ignoreList: m(this, V) };
  } }, { key: "toJSON", value: function() {
    return this.valueOf();
  } }, { key: "valueOf", value: function() {
    return this.toDate().valueOf();
  } }, { key: "toDays", value: function() {
    if (this.isValid) return m(this, T).getAllDays(this);
  } }, { key: "dayOfBeginning", get: function() {
    return this.toDays();
  } }, { key: "dayOfYear", get: function() {
    if (this.isValid) return m(this, T).getDayOfYear(this);
  } }, { key: "weekOfYear", get: function() {
    if (this.isValid) return 1 + ~~(this.dayOfYear / 7);
  } }, { key: "daysLeft", get: function() {
    if (this.isValid) {
      var t2 = m(this, T).yearLength;
      return (this.isLeap ? t2 + 1 : t2) - this.dayOfYear;
    }
  } }, { key: "year", get: function() {
    return m(this, Y);
  }, set: function(t2) {
    v(this, Y, M(t2)), m(this, U).call(this);
  } }, { key: "month", get: function() {
    return this.months[m(this, L)] || {};
  }, set: function(t2) {
    var e2;
    t2 = null !== (e2 = M(t2.valueOf()) - 1) && void 0 !== e2 ? e2 : void 0, v(this, L, t2), S(t2, 0, 11) && m(this, U).call(this);
  } }, { key: "monthIndex", get: function() {
    return m(this, L);
  } }, { key: "day", get: function() {
    return m(this, W);
  }, set: function(t2) {
    t2 = M(t2), v(this, W, t2), S(t2, 1, 28) && m(this, U).call(this);
  } }, { key: "weekDay", get: function() {
    if (!this.isValid) return {};
    var t2 = (this.toJulianDay() + 3) % 7;
    return m(this, R).call(this)[t2];
  } }, { key: "hour", get: function() {
    return m(this, j);
  }, set: function(t2) {
    t2 = M(t2), v(this, j, t2), S(t2, 0, 23) && m(this, U).call(this);
  } }, { key: "minute", get: function() {
    return m(this, x);
  }, set: function(t2) {
    t2 = M(t2), v(this, x, t2), S(t2, 0, 59) && m(this, U).call(this);
  } }, { key: "second", get: function() {
    return m(this, N);
  }, set: function(t2) {
    t2 = M(t2), v(this, N, t2), S(t2, 0, 59) && m(this, U).call(this);
  } }, { key: "millisecond", get: function() {
    return m(this, A);
  }, set: function(t2) {
    t2 = M(t2), v(this, A, t2), S(t2, 0, 999) && m(this, U).call(this);
  } }, { key: "months", get: function() {
    var t2 = m(this, T).getMonthLengths(this.isLeap), e2 = (m(this, E).months || m(this, P).months).map((function(e3, n2) {
      var r2 = u(e3, 2);
      return { name: r2[0], shortName: r2[1], length: t2[n2], index: n2, number: n2 + 1, toString: function() {
        return this.number.toString();
      }, valueOf: function() {
        return this.number;
      } };
    }));
    return e2;
  }, set: function(t2) {
    if (!t2) return delete m(this, E).months;
    O(t2) && 12 === t2.length && t2.every((function(t3) {
      return O(t3) && 2 === t3.length && t3.every((function(t4) {
        return "string" == typeof t4;
      }));
    })) && (m(this, E).months = t2);
  } }, { key: "weekDays", get: function() {
    return m(this, R).call(this).sort((function(t2, e2) {
      return t2.index - e2.index;
    }));
  }, set: function(t2) {
    if (!t2) return delete m(this, E).weekDays;
    O(t2) && 7 === t2.length && t2.every((function(t3) {
      return O(t3) && 2 === t3.length && t3.every((function(t4) {
        return "string" == typeof t4;
      }));
    })) && (m(this, E).weekDays = t2);
  } }, { key: "leaps", get: function() {
    return m(this, T).getLeaps(m(this, Y));
  } }, { key: "calendar", get: function() {
    return m(this, T);
  }, set: function(t2) {
    this.convert(t2);
  } }, { key: "locale", get: function() {
    return m(this, P);
  }, set: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : b;
    D(t2) && v(this, P, t2);
  } }, { key: "custom", get: function() {
    return m(this, E);
  } }, { key: "meridiems", get: function() {
    return m(this, P).meridiems;
  } }, { key: "digits", get: function() {
    return m(this, E).digits || m(this, P).digits;
  }, set: function(t2) {
    if (!t2) return delete m(this, E).digits;
    O(t2) && 10 === t2.length && (m(this, E).digits = t2);
  } }, { key: "_format", get: function() {
    return m(this, I);
  }, set: function(t2) {
    "string" == typeof t2 && v(this, I, t2);
  } }, { key: "isLeap", get: function() {
    return m(this, T).isLeap(m(this, Y));
  } }, { key: "isValid", get: function() {
    return !isNaN(m(this, Y)) && !isNaN(m(this, L)) && !isNaN(m(this, W));
  } }, { key: "isUTC", get: function() {
    return m(this, F);
  } }, { key: "unix", get: function() {
    return (this.valueOf() - this.millisecond) / 1e3;
  } }, { key: "ignoreList", get: function() {
    return m(this, V);
  }, set: function(t2) {
    O(t2) && v(this, V, t2);
  } }, { key: "weekStartDayIndex", get: function() {
    return m(this, T).weekStartDayIndex;
  }, set: function(t2) {
    void 0 !== (t2 = M(t2)) && (m(this, T).weekStartDayIndex = Math.abs(t2) % 7);
  } }, { key: "date", set: function(t2) {
    this.setDate(t2);
  } }], c2 && f(s2.prototype, c2), Object.defineProperty(s2, "prototype", { writable: false }), i2;
})(), $ = p(k(z));
const index_module = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: $
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(index_module);
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var e2 = requireReact(), r2 = requireBrowser_min(), t2 = require$$2;
    function n2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var a2 = n2(e2), o2 = n2(r2), d2 = n2(t2);
    function i2(e3, r3) {
      var t3 = Object.keys(e3);
      if (Object.getOwnPropertySymbols) {
        var n3 = Object.getOwnPropertySymbols(e3);
        r3 && (n3 = n3.filter((function(r4) {
          return Object.getOwnPropertyDescriptor(e3, r4).enumerable;
        }))), t3.push.apply(t3, n3);
      }
      return t3;
    }
    function l2(e3) {
      for (var r3 = 1; r3 < arguments.length; r3++) {
        var t3 = null != arguments[r3] ? arguments[r3] : {};
        r3 % 2 ? i2(Object(t3), true).forEach((function(r4) {
          c2(e3, r4, t3[r4]);
        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : i2(Object(t3)).forEach((function(r4) {
          Object.defineProperty(e3, r4, Object.getOwnPropertyDescriptor(t3, r4));
        }));
      }
      return e3;
    }
    function c2(e3, r3, t3) {
      return (r3 = (function(e4) {
        var r4 = (function(e5, r5) {
          if ("object" != typeof e5 || null === e5) return e5;
          var t4 = e5[Symbol.toPrimitive];
          if (void 0 !== t4) {
            var n3 = t4.call(e5, r5);
            if ("object" != typeof n3) return n3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r5 ? String : Number)(e5);
        })(e4, "string");
        return "symbol" == typeof r4 ? r4 : String(r4);
      })(r3)) in e3 ? Object.defineProperty(e3, r3, { value: t3, enumerable: true, configurable: true, writable: true }) : e3[r3] = t3, e3;
    }
    function u2() {
      return u2 = Object.assign ? Object.assign.bind() : function(e3) {
        for (var r3 = 1; r3 < arguments.length; r3++) {
          var t3 = arguments[r3];
          for (var n3 in t3) Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
        }
        return e3;
      }, u2.apply(this, arguments);
    }
    function s2(e3, r3) {
      if (null == e3) return {};
      var t3, n3, a3 = (function(e4, r4) {
        if (null == e4) return {};
        var t4, n4, a4 = {}, o4 = Object.keys(e4);
        for (n4 = 0; n4 < o4.length; n4++) t4 = o4[n4], r4.indexOf(t4) >= 0 || (a4[t4] = e4[t4]);
        return a4;
      })(e3, r3);
      if (Object.getOwnPropertySymbols) {
        var o3 = Object.getOwnPropertySymbols(e3);
        for (n3 = 0; n3 < o3.length; n3++) t3 = o3[n3], r3.indexOf(t3) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, t3) && (a3[t3] = e3[t3]);
      }
      return a3;
    }
    function f2(e3, r3) {
      return (function(e4) {
        if (Array.isArray(e4)) return e4;
      })(e3) || (function(e4, r4) {
        var t3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
        if (null != t3) {
          var n3, a3, o3, d3, i3 = [], l3 = true, c3 = false;
          try {
            if (o3 = (t3 = t3.call(e4)).next, 0 === r4) {
              if (Object(t3) !== t3) return;
              l3 = false;
            } else for (; !(l3 = (n3 = o3.call(t3)).done) && (i3.push(n3.value), i3.length !== r4); l3 = true) ;
          } catch (e5) {
            c3 = true, a3 = e5;
          } finally {
            try {
              if (!l3 && null != t3.return && (d3 = t3.return(), Object(d3) !== d3)) return;
            } finally {
              if (c3) throw a3;
            }
          }
          return i3;
        }
      })(e3, r3) || m2(e3, r3) || (function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      })();
    }
    function p2(e3) {
      return (function(e4) {
        if (Array.isArray(e4)) return h2(e4);
      })(e3) || (function(e4) {
        if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
      })(e3) || m2(e3) || (function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      })();
    }
    function m2(e3, r3) {
      if (e3) {
        if ("string" == typeof e3) return h2(e3, r3);
        var t3 = Object.prototype.toString.call(e3).slice(8, -1);
        return "Object" === t3 && e3.constructor && (t3 = e3.constructor.name), "Map" === t3 || "Set" === t3 ? Array.from(e3) : "Arguments" === t3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t3) ? h2(e3, r3) : void 0;
      }
    }
    function h2(e3, r3) {
      (null == r3 || r3 > e3.length) && (r3 = e3.length);
      for (var t3 = 0, n3 = new Array(r3); t3 < r3; t3++) n3[t3] = e3[t3];
      return n3;
    }
    function y2(e3, r3) {
      var t3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
      if (!t3) {
        if (Array.isArray(e3) || (t3 = m2(e3)) || r3) {
          t3 && (e3 = t3);
          var n3 = 0, a3 = function() {
          };
          return { s: a3, n: function() {
            return n3 >= e3.length ? { done: true } : { done: false, value: e3[n3++] };
          }, e: function(e4) {
            throw e4;
          }, f: a3 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o3, d3 = true, i3 = false;
      return { s: function() {
        t3 = t3.call(e3);
      }, n: function() {
        var e4 = t3.next();
        return d3 = e4.done, e4;
      }, e: function(e4) {
        i3 = true, o3 = e4;
      }, f: function() {
        try {
          d3 || null == t3.return || t3.return();
        } finally {
          if (i3) throw o3;
        }
      } };
    }
    function g2(e3) {
      return Array.isArray(e3);
    }
    function v2(r3) {
      var t3 = r3.state.date, n3 = t3.calendar, o3 = t3.locale, i3 = r3.customWeekDays, l3 = r3.weekStartDayIndex, c3 = r3.displayWeekNumbers, u3 = r3.weekNumber, s3 = e2.useMemo((function() {
        var e3 = i3;
        return g2(e3) && e3.length >= 7 ? (e3.length = 7, e3 = e3.map((function(e4) {
          return g2(e4) & e4.length > 1 ? e4 = e4[1] : g2(e4) && (e4 = e4[0]), e4;
        }))) : e3 = new d2.default({ year: 1, calendar: n3, locale: o3 }).weekDays.map((function(e4) {
          return e4.shortName;
        })), e3;
      }), [n3, o3, i3]);
      return s3 = p2(s3).slice(l3).concat(p2(s3).splice(0, l3)), a2.default.createElement("div", { className: "rmdp-week" }, c3 && a2.default.createElement("div", { className: "rmdp-week-day" }, u3), s3.map((function(e3, r4) {
        return a2.default.createElement("div", { key: r4, className: "rmdp-week-day" }, e3);
      })));
    }
    function b2(e3, r3) {
      var t3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
      if (!e3 || !r3) return false;
      if (e3.year === r3.year) {
        if (n3) return true;
        if (e3.monthIndex === r3.monthIndex) return !!t3 || e3.day === r3.day;
      }
    }
    function x2(e3) {
      var r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "YYYY/MM/DD";
      return e3.format(r3);
    }
    function w2(e3, r3, t3) {
      var n3 = t3.multiple, a3 = t3.range, o3 = t3.selectedDate, i3 = t3.onlyMonthPicker, l3 = t3.onlyYearPicker, c3 = t3.format, u3 = t3.focused, s3 = t3.weekPicker;
      e3.setFormat(c3);
      var m3 = new d2.default(e3);
      return o3 = n3 && a3 ? (function() {
        var e4 = true;
        g2(o3) || (o3 = [[o3]]);
        var r4 = o3.find((function(e5) {
          return 1 === e5.length;
        })), t4 = i3 ? "YYYY/MM" : "YYYY/MM/DD", n4 = o3;
        if (r4) {
          var a4 = r4[0];
          n4 = n4.filter((function(e5) {
            if (1 === e5.length) return true;
            var r5 = f2(e5, 2), n5 = r5[0], o4 = r5[1], d3 = f2([a4, m3].sort((function(e6, r6) {
              return e6 - r6;
            })), 2), i4 = [n5, o4, d3[0], d3[1]].map((function(e6) {
              return x2(e6, t4);
            })), l4 = f2(i4, 4), c4 = l4[0], u4 = l4[1], s4 = l4[2], p3 = l4[3];
            return !(s4 <= c4 && p3 >= u4 || s4 >= c4 && p3 >= u4 && s4 <= u4 || s4 <= c4 && p3 <= u4 && p3 >= c4);
          }));
        } else n4 = n4.filter((function(e5) {
          if (!g2(e5)) return true;
          if (0 === e5.length) return false;
          var r5 = f2(e5, 2), n5 = [r5[0], r5[1], m3].map((function(e6) {
            return x2(e6, t4);
          })), a5 = f2(n5, 3), o4 = a5[0], d3 = a5[1], i4 = a5[2];
          return !(i4 >= o4 && i4 <= d3);
        }));
        n4 = n4.map((function(r5) {
          var t5;
          return g2(r5) ? 1 === r5.length ? (e4 = false, t5 = r5.concat(m3)) : t5 = r5 : (e4 = false, t5 = [r5, m3]), t5.sort((function(e5, r6) {
            return e5 - r6;
          }));
        })), e4 && (n4 = [].concat(p2(n4), [[m3]]));
        return n4;
      })() : n3 ? (function() {
        var t4 = o3.filter((function(r4) {
          return !b2(e3, r4, i3, l3);
        }));
        t4.length === o3.length ? t4.push(m3) : m3 = t4.find((function(e4) {
          return b2(e4, u3);
        }));
        r3 && t4.sort((function(e4, r4) {
          return e4 - r4;
        }));
        return t4;
      })() : a3 ? (function() {
        if (s3) return [new d2.default(m3).toFirstOfWeek(), new d2.default(m3).toLastOfWeek()];
        if (2 === o3.length || 0 === o3.length) return [m3];
        if (1 === o3.length) return [o3[0], m3].sort((function(e4, r4) {
          return e4 - r4;
        }));
      })() : m3, [o3, m3];
    }
    function k2(e3, r3, t3, n3) {
      var a3 = [], o3 = t3 ? "YYYY/MM" : "YYYY/MM/DD", d3 = x2(e3, o3);
      function i3(r4) {
        var n4 = r4[0], i4 = r4[1];
        if (1 === r4.length) b2(e3, n4, t3) && a3.push("rmdp-range");
        else if (2 === r4.length) {
          var l3 = [n4, i4].map((function(e4) {
            return x2(e4, o3);
          })), c3 = f2(l3, 2), u3 = c3[0], s3 = c3[1];
          d3 >= u3 && d3 <= s3 && a3.push("rmdp-range"), d3 === u3 && a3.push("start"), d3 === s3 && a3.push("end");
        }
      }
      return n3 ? (g2(r3) ? r3 : [[r3]]).forEach(i3) : i3(r3), a3.join(" ");
    }
    function D2(e3, r3, t3, n3) {
      var a3 = arguments.length > 5 ? arguments[5] : void 0, o3 = [];
      if (n3 && t3) {
        var d3, i3 = "day" === (arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "day") ? "YYYY/MM/DD" : "YYYY/MM", l3 = t3.format(i3), c3 = e3.format(i3);
        if (a3 || 1 !== (null == r3 ? void 0 : r3.length)) {
          if (a3 && g2(r3)) {
            var u3, s3 = y2(r3);
            try {
              for (s3.s(); !(u3 = s3.n()).done; ) {
                var f3 = u3.value;
                if (g2(f3) && 1 === f3.length) {
                  d3 = f3[0].format(i3);
                  break;
                }
              }
            } catch (e4) {
              s3.e(e4);
            } finally {
              s3.f();
            }
          }
        } else d3 = r3[0].format(i3);
        (c3 > d3 && c3 <= l3 || c3 < d3 && c3 >= l3) && (o3.push("rmdp-range-hover"), c3 === l3 && o3.push(l3 > d3 ? "end" : "start"), g2(r3) && r3.flat().some((function(e4) {
          return e4.format(i3) === c3;
        })) && o3.push("force"));
      }
      return o3;
    }
    function Y2(e3, r3, t3) {
      if (e3) {
        var n3 = E2(e3);
        return t3 ? Array.from(n3.querySelectorAll(r3)) : n3.querySelector(r3);
      }
    }
    function E2(e3) {
      return e3.closest(".rmdp-calendar");
    }
    var O2 = ["selected", "today", "day:not(.rmdp-day-hidden):not(.rmdp-disabled)"];
    function M2(e3, r3, t3) {
      var n3 = t3.type, a3 = void 0 === n3 ? "day" : n3, o3 = t3.format;
      e3.preventDefault();
      var i3 = e3.currentTarget, c3 = e3.key, u3 = e3.code, s3 = "day" === a3 ? 7 : 3, f3 = E2(i3), p3 = f3 && f3.classList.contains("rmdp-rtl"), m3 = { ArrowRight: p3 ? -1 : 1, ArrowLeft: p3 ? 1 : -1, ArrowUp: -s3, ArrowDown: s3 };
      if ("Space" === u3 || " " === c3) i3.click();
      else if (Object.keys(m3).includes(c3)) {
        var h3 = function() {
          if ("month" === a3) return S2(f3, [O2[2]]);
          var e4 = Y2(i3, y3 < 0 ? ".rmdp-left" : ".rmdp-right");
          e4 && (e4.click(), S2(f3));
        }, y3 = m3[c3], g3 = new d2.default(r3.date).add(y3, a3);
        !(function(t4) {
          if (!t4) return h3();
          var n4 = t4.getAttribute("class");
          n4.includes("hidden") || n4.includes("disabled") ? M2(e3, l2(l2({}, r3), {}, { date: g3 }), { type: a3, format: o3 }) : t4.focus();
        })(Y2(i3, '[aria-label*="'.concat(r3.year ? "year ".concat(r3.year + y3) : g3.format(o3), '"]')));
      } else {
        var v3 = Y2(i3, ".rmdp-arrow-container");
        v3 && v3.focus();
      }
    }
    function S2(e3) {
      var r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : O2, t3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], n3 = "[data-active='true']";
      e3.querySelectorAll("".concat(n3, " [tabindex='0']")).forEach((function(e4) {
        return e4.setAttribute("tabindex", "-1");
      })), setTimeout((function() {
        var a3, o3 = y2(r3);
        try {
          for (o3.s(); !(a3 = o3.n()).done; ) {
            var d3 = a3.value, i3 = e3.querySelector("".concat(n3, " .rmdp-").concat(d3));
            if (i3) {
              i3.setAttribute("tabindex", "0"), t3 && i3.focus();
              break;
            }
          }
        } catch (e4) {
          o3.e(e4);
        } finally {
          o3.f();
        }
      }), 10);
    }
    var P2 = "dddd MMMM DD of YYYY";
    function C2(r3) {
      var t3 = r3.state, n3 = r3.onChange, o3 = r3.showOtherDays, i3 = void 0 !== o3 && o3, s3 = r3.mapDays, p3 = r3.onlyShowInRangeDates, m3 = r3.customWeekDays, h3 = r3.sort, y3 = r3.numberOfMonths, g3 = r3.isRTL, x3 = r3.weekStartDayIndex, Y3 = r3.handleFocusedDate, E3 = r3.hideWeekDays, O3 = r3.fullYear, S3 = f2(r3.monthAndYears, 1)[0], C3 = r3.displayWeekNumbers, N3 = r3.weekNumber, I3 = void 0 === N3 ? "" : N3, j3 = r3.rangeHover, T3 = r3.highlightToday, A3 = e2.useRef({}), R3 = e2.useRef(), L3 = t3.today, F3 = t3.minDate, V3 = t3.maxDate, W3 = t3.range, B2 = t3.multiple, K2 = t3.date, _3 = t3.selectedDate, z3 = t3.onlyMonthPicker, H3 = t3.onlyYearPicker, q2 = t3.mustShowMonthPicker, J3 = t3.mustShowYearPicker, U3 = !z3 && !H3, $3 = f2(e2.useState(), 2), G2 = $3[0], Q2 = $3[1];
      A3.current.date = K2;
      var X2 = e2.useMemo((function() {
        return U3 ? (function(e3, r4, t4, n4) {
          if (!e3) return [];
          for (var a3 = [], o4 = 0; o4 < t4; o4++) {
            var i4 = (e3 = new d2.default(e3).toFirstOfMonth()).monthIndex, l3 = [];
            e3.toFirstOfWeek().add(n4, "day"), e3.monthIndex === i4 && e3.day > 1 && e3.subtract(7, "days");
            for (var c3 = 0; c3 < 6; c3++) {
              for (var u3 = [], s4 = 0; s4 < 7; s4++) u3.push({ date: new d2.default(e3), day: e3.format("D"), current: e3.monthIndex === i4 }), e3.day += 1;
              if (l3.push(u3), c3 > 2 && e3.monthIndex !== i4) break;
            }
            a3.push(l3);
          }
          return a3;
        })(A3.current.date, 0, y3, x3) : [];
      }), [K2.monthIndex, K2.year, K2.calendar, K2.locale, U3, i3, y3, x3]);
      return U3 && a2.default.createElement("div", { ref: R3, className: "rmdp-day-picker ".concat(O3 ? "rmdp-full-year" : ""), style: { display: O3 ? "grid" : "flex" }, onMouseLeave: function() {
        return j3 && Q2();
      }, "data-active": U3 && !q2 && !J3 }, X2.map((function(e3, r4) {
        return a2.default.createElement("div", { key: r4, style: c2({}, g3 ? "marginLeft" : "marginRight", r4 + (O3 ? 0 : 1) < y3 ? "10px" : "") }, O3 && a2.default.createElement("div", { className: "rmdp-month-name" }, S3[r4]), !E3 && a2.default.createElement(v2, { state: t3, customWeekDays: m3, weekStartDayIndex: x3, displayWeekNumbers: C3, weekNumber: I3 }), e3.map((function(e4, o4) {
          return a2.default.createElement("div", { key: o4, className: "rmdp-week" }, C3 && a2.default.createElement("div", { className: "rmdp-day rmdp-disabled" }, a2.default.createElement("span", null, e4[0].date.format("WW"))), e4.map((function(e5, o5) {
            var c3 = (function(e6) {
              if (!e6.current && !i3) return {};
              var r5 = {};
              return s3.forEach((function(n4) {
                var a3, o6 = n4({ date: e6.date, today: L3, currentMonth: t3.date.month, selectedDate: t3.selectedDate, isSameDate: b2 });
                (null === (a3 = o6) || void 0 === a3 ? void 0 : a3.constructor) !== Object && (o6 = {}), (o6.disabled || o6.hidden) && (e6.disabled = true), o6.hidden && (e6.hidden = true), r5 = l2(l2({}, r5), o6);
              })), delete r5.disabled, delete r5.hidden, r5;
            })(e5 = { date: e5.date, day: e5.day, current: e5.current }), m4 = Z2(e5) && !e5.disabled, g4 = "".concat(m4 ? "sd" : ""), v3 = c3.children;
            m4 && (g4 = "".concat(g4, " ").concat(c3.className || "")), delete c3.className, delete c3.children;
            var x4 = (function(e6, r5) {
              var t4 = ["rmdp-day"], n4 = e6.date, a3 = e6.hidden, o6 = e6.current;
              if (!Z2(e6) || a3) t4.push("rmdp-day-hidden");
              else {
                (F3 && n4 < F3 || V3 && n4 > V3 || e6.disabled) && (t4.push("rmdp-disabled"), e6.disabled || (e6.disabled = true)), o6 || t4.push("rmdp-deactive");
                var d3 = r5 > 1 && o6 || 1 === r5;
                e6.disabled && p3 || (b2(n4, L3) && T3 && t4.push("rmdp-today"), i4 = n4, [].concat(_3).some((function(e7) {
                  return b2(e7, i4);
                })) && d3 && !W3 && t4.push("rmdp-selected")), W3 && !e6.disabled && d3 && (t4.push(k2(n4, _3, void 0, B2)), t4 = t4.concat(D2(n4, _3, G2, j3, void 0, B2)));
              }
              var i4;
              return t4.join(" ");
            })(e5, y3);
            return (e5.hidden || e5.disabled) && (g4 = g4.replace("sd", "")), a2.default.createElement("div", { key: o5, tabIndex: -1, "aria-label": "Choose ".concat(e5.date.format(P2)), className: x4, onMouseEnter: function() {
              return j3 && Q2(e5.date);
            }, onKeyDown: function(r5) {
              return M2(r5, e5, { format: P2 });
            }, onClick: function() {
              Z2(e5) && !e5.disabled && (function(e6, r5, a3) {
                var o6, i4, c4, u3 = e6.date, s4 = e6.current, p4 = t3.selectedDate, m5 = t3.focused, y4 = t3.date, g5 = y4, v4 = g5.hour, b3 = g5.minute, x5 = g5.second;
                u3.set({ hour: (null === (o6 = p4) || void 0 === o6 ? void 0 : o6.hour) || v4, minute: (null === (i4 = p4) || void 0 === i4 ? void 0 : i4.minute) || b3, second: (null === (c4 = p4) || void 0 === c4 ? void 0 : c4.second) || x5 }), 1 !== a3 || s4 ? a3 > 1 && !s4 && (0 === r5 && u3 < y4 && (y4 = new d2.default(y4).toFirstOfMonth()), r5 > 0 && u3.monthIndex > y4.monthIndex + r5 && r5 + 1 === a3 && (y4 = new d2.default(y4).toFirstOfMonth().add(1, "month"))) : y4 = new d2.default(y4).toFirstOfMonth();
                var k3 = f2(w2(u3, h3, t3), 2);
                p4 = k3[0], m5 = k3[1], n3(p4, l2(l2({}, t3), {}, { date: y4, focused: m5, selectedDate: p4 })), Y3(m5, u3);
              })(e5, r4, y3);
            } }, a2.default.createElement("span", u2({ className: g4 }, c3), Z2(e5) && !e5.hidden ? null != v3 ? v3 : e5.day : ""));
          })));
        })));
      })));
      function Z2(e3) {
        return !!e3.current || i3;
      }
    }
    function N2(e3) {
      var r3 = e3.direction, t3 = e3.onClick, n3 = e3.disabled, o3 = e3.onKeyDown;
      return a2.default.createElement("button", { type: "button", className: "rmdp-arrow-container ".concat(r3, " ").concat(n3 ? "disabled" : ""), onClick: t3, onKeyDown: o3, "aria-roledescription": "button to navigate ".concat(r3.replace("rmdp-", "")) }, a2.default.createElement("i", { className: "rmdp-arrow" }));
    }
    function I2(r3) {
      var t3 = r3.state, n3 = r3.setState, o3 = r3.disableYearPicker, i3 = r3.disableMonthPicker, c3 = r3.buttons, u3 = r3.renderButton, s3 = r3.handleMonthChange, p3 = r3.disabled, m3 = r3.hideMonth, h3 = r3.hideYear, y3 = r3.isRTL, g3 = r3.fullYear, v3 = f2(r3.monthAndYears, 2), b3 = v3[0], x3 = v3[1], w3 = r3.monthYearSeparator, k3 = r3.formatMonth, D3 = r3.formatYear, Y3 = r3.headerOrder, O3 = r3.onYearChange, M3 = {}, P3 = t3.date, C3 = t3.onlyMonthPicker, I3 = t3.onlyYearPicker, j3 = t3.mustShowYearPicker, T3 = t3.minDate, A3 = t3.maxDate, R3 = t3.year, L3 = t3.today, F3 = T3 && P3.year <= T3.year && T3.monthIndex > P3.monthIndex - 1, V3 = A3 && P3.year >= A3.year && A3.monthIndex < P3.monthIndex + 1, W3 = L3.year + 7;
      if (W3 -= 12 * Math.floor((W3 - R3) / 12), (m3 || g3) && h3 && !c3) return null;
      if ((C3 || g3) && (T3 && T3.year >= P3.year && (F3 = true), A3 && A3.year <= P3.year && (V3 = true)), j3 || I3) {
        var B2 = W3 - 11;
        F3 = T3 && T3.year > B2, V3 = A3 && A3.year < W3;
      }
      return p3 && (F3 = true, V3 = true), a2.default.createElement("div", { className: "rmdp-header" }, a2.default.createElement("div", { style: { position: "relative", display: "flex", alignItems: "center" } }, Array.from(new Set(Y3)).map((function(r4, t4) {
        return a2.default.createElement(e2.Fragment, { key: t4 }, (function(r5) {
          switch (r5) {
            case "LEFT_BUTTON":
              return c3 && z3("left");
            case "RIGHT_BUTTON":
              return c3 && z3("right");
            case "MONTH_YEAR":
            case "YEAR_MONTH":
              if (g3) return a2.default.createElement("div", { className: "rmdp-header-values", style: M3 }, !h3 && P3.format("YYYY"));
              var t5 = r5.split("_").filter((function(e3) {
                return "MONTH" === e3 && !m3 || "YEAR" === e3 && !h3;
              }));
              return t5.length > 1 && (t5 = [t5[0], _3(), t5[1]]), b3.map((function(r6, n4) {
                return a2.default.createElement("div", { key: n4, className: "rmdp-header-values", style: M3 }, t5.map((function(t6, d3) {
                  return a2.default.createElement(e2.Fragment, { key: d3 }, (function(e3, r7, t7) {
                    switch (e3) {
                      case "MONTH":
                        return a2.default.createElement("span", { tabIndex: 0, onKeyDown: K2, style: { cursor: p3 || i3 || C3 ? "default" : "pointer" }, onClick: function(e4) {
                          return !i3 && q2("mustShowMonthPicker", e4);
                        } }, (function(e4, r8) {
                          return "function" == typeof k3 ? k3(e4, r8) : e4;
                        })(r7, x3[t7]));
                      case "YEAR":
                        return a2.default.createElement("span", { tabIndex: 0, onKeyDown: K2, style: { cursor: p3 || o3 || I3 ? "default" : "pointer" }, onClick: function(e4) {
                          return !o3 && q2("mustShowYearPicker", e4);
                        } }, (function(e4, r8) {
                          return "function" == typeof k3 ? D3(e4, r8) : e4;
                        })(x3[t7], r7));
                      default:
                        return e3;
                    }
                  })(t6, r6, n4));
                })));
              }));
            default:
              return;
          }
        })(r4));
      }))));
      function K2(e3) {
        var r4 = e3.currentTarget, t4 = e3.key, n4 = e3.code;
        "Space" === n4 || " " === t4 ? (e3.preventDefault(), r4.click()) : "ArrowDown" === n4 && (e3.preventDefault(), S2(E2(e3.target)));
      }
      function _3() {
        return w3 ? a2.default.createElement("span", null, w3) : y3 ? "" : ",";
      }
      function z3(r4) {
        var t4 = function(e3) {
          e3.preventDefault(), H3("right" === r4 ? 1 : -1, e3);
        }, n4 = "left" === r4 && F3 || "right" === r4 && V3;
        return u3 instanceof Function ? u3(r4, t4, n4, K2) : e2.isValidElement(u3) ? e2.cloneElement(u3, { direction: r4, handleClick: t4, disabled: n4, onKeyDown: K2 }) : a2.default.createElement(N2, { direction: "rmdp-".concat(r4), onClick: t4, onKeyDown: K2, disabled: n4 });
      }
      function H3(e3, r4) {
        p3 || e3 < 0 && F3 || e3 > 0 && V3 || (g3 ? (P3.year += e3, null == O3 || O3(new d2.default(P3))) : j3 || I3 ? (R3 += 12 * e3, e3 < 0 && T3 && R3 < T3.year && (R3 = T3.year), e3 > 0 && A3 && R3 > A3.year && (R3 = A3.year)) : (P3.toFirstOfMonth(), C3 ? P3.year += e3 : (P3.month += e3, s3(P3))), n3(l2(l2({}, t3), {}, { date: P3, year: R3 })), S2(E2(r4.target), void 0, false));
      }
      function q2(e3, r4) {
        if (!p3) {
          var a3 = { mustShowMonthPicker: false, mustShowYearPicker: false };
          a3[e3] = !t3[e3], n3(l2(l2({}, t3), a3)), S2(E2(r4.target), void 0, false);
        }
      }
    }
    function j2(e3) {
      return g2(e3) || (e3 = []), JSON.stringify(e3);
    }
    var T2 = "MMMM of YYYY";
    function A2(r3) {
      var t3 = r3.state, n3 = r3.onChange, o3 = r3.customMonths, i3 = r3.sort, c3 = r3.handleMonthChange, u3 = r3.handleFocusedDate, s3 = r3.rangeHover, p3 = r3.highlightToday, m3 = r3.numberOfMonths, h3 = t3.date, y3 = t3.today, v3 = t3.minDate, x3 = t3.maxDate, Y3 = t3.calendar, O3 = t3.locale, P3 = t3.onlyMonthPicker, C3 = t3.onlyYearPicker, N3 = t3.range, I3 = t3.onlyShowInRangeDates, A3 = (t3.mustShowMonthPicker || P3) && !C3, R3 = f2(e2.useState(), 2), L3 = R3[0], F3 = R3[1];
      o3 = o3 && j2(o3);
      var V3 = e2.useMemo((function() {
        var e3 = [], r4 = P3 ? m3 : 1, n4 = o3 && JSON.parse(o3), a3 = new d2.default({ calendar: Y3, locale: O3, format: t3.date._format, year: t3.date.year, month: 1, day: 1 });
        g2(n4) && n4.length >= 12 ? (n4.length = 12, n4 = n4.map((function(e4) {
          return g2(e4) ? e4[0] : e4;
        }))) : n4 = a3.locale.months.map((function(e4) {
          return f2(e4, 1)[0];
        }));
        for (var i4 = 0; i4 < r4; i4++) {
          for (var l3 = [], c4 = 0, u4 = 0; u4 < 4; u4++) {
            for (var s4 = [], p4 = 0; p4 < 3; p4++) s4.push({ date: new d2.default(a3), name: n4[c4] }), c4++, a3.add(1, "month");
            l3.push(s4);
          }
          e3.push(l3);
        }
        return e3;
      }), [Y3, O3, o3, t3.date.year, t3.date._format, m3, P3]);
      return a2.default.createElement("div", { className: "".concat(P3 ? "only " : "", "rmdp-month-picker"), style: { display: A3 ? "flex" : "none" }, "data-active": A3, onMouseLeave: function() {
        return s3 && F3();
      } }, V3.map((function(e3, r4) {
        return a2.default.createElement("div", { key: r4, style: { margin: "0 5px", flex: 1 } }, e3.map((function(e4, r5) {
          return a2.default.createElement("div", { key: r5, className: "rmdp-ym" }, e4.map((function(e5, r6) {
            var t4 = e5.date, n4 = e5.name;
            return a2.default.createElement("div", { key: r6, "aria-label": "Select ".concat(t4.format(T2)), tabIndex: -1, onKeyDown: function(e6) {
              return M2(e6, { date: t4 }, { format: T2, type: "month" });
            }, className: B2(t4), onClick: function(e6) {
              return W3(t4, e6);
            }, onMouseEnter: function() {
              return s3 && F3(t4);
            } }, a2.default.createElement("span", { className: P3 ? "sd" : "" }, n4));
          })));
        })));
      })));
      function W3(e3, r4) {
        var a3 = t3.selectedDate, o4 = t3.focused, d3 = e3.year, s4 = e3.monthIndex;
        if (!(v3 && d3 <= v3.year && s4 < v3.monthIndex || x3 && d3 >= x3.year && s4 > x3.monthIndex)) {
          if (h3.setMonth(s4 + 1), P3) {
            var p4 = f2(w2(e3, i3, t3), 2);
            a3 = p4[0], o4 = p4[1];
          } else c3(h3), S2(E2(r4.target));
          n3(P3 ? a3 : void 0, l2(l2({}, t3), {}, { date: h3, focused: o4, selectedDate: a3, mustShowMonthPicker: false })), P3 && u3(o4, e3);
        }
      }
      function B2(e3) {
        var r4 = ["rmdp-day"], n4 = e3.year, a3 = e3.monthIndex, o4 = t3.selectedDate, d3 = t3.multiple;
        if ((v3 && (n4 < v3.year || n4 === v3.year && a3 < v3.monthIndex) || x3 && (n4 > x3.year || n4 === x3.year && a3 > x3.monthIndex)) && r4.push("rmdp-disabled"), !r4.includes("rmdp-disabled") || !I3) return b2(y3, e3, true) && p3 && r4.push("rmdp-today"), P3 ? N3 ? (r4.push(k2(e3, o4, true, d3)), r4 = r4.concat(D2(e3, o4, L3, s3, "month", d3))) : [].concat(o4).some((function(r5) {
          return b2(r5, e3, true);
        })) && r4.push("rmdp-selected") : h3.monthIndex === a3 && r4.push("rmdp-selected"), r4.join(" ");
      }
    }
    function R2(e3, r3) {
      return e3.replace(/[0-9]/g, (function(e4) {
        return r3[e4];
      }));
    }
    var L2 = "YYYY";
    function F2(r3) {
      var t3 = r3.state, n3 = r3.onChange, o3 = r3.sort, i3 = r3.handleFocusedDate, c3 = r3.onYearChange, u3 = r3.rangeHover, s3 = r3.highlightToday, p3 = t3.date, m3 = t3.today, h3 = t3.minDate, y3 = t3.maxDate, v3 = t3.onlyYearPicker, b3 = t3.range, x3 = t3.onlyShowInRangeDates, k3 = t3.year, D3 = t3.mustShowYearPicker || v3, Y3 = p3.digits, O3 = f2(e2.useState(), 2), P3 = O3[0], C3 = O3[1], N3 = m3.year - 4;
      N3 -= 12 * Math.ceil((N3 - k3) / 12);
      var I3 = e2.useMemo((function() {
        for (var e3 = [], r4 = N3, t4 = 0; t4 < 4; t4++) {
          for (var n4 = [], a3 = 0; a3 < 3; a3++) n4.push(r4), r4++;
          e3.push(n4);
        }
        return e3;
      }), [N3]);
      return a2.default.createElement("div", { className: "".concat(v3 ? "only " : "", "rmdp-year-picker"), style: { display: D3 ? "block" : "none" }, "data-active": D3 }, I3.map((function(e3, r4) {
        return a2.default.createElement("div", { key: r4, className: "rmdp-ym", onMouseLeave: function() {
          return u3 && C3();
        } }, e3.map((function(e4, r5) {
          return a2.default.createElement("div", { key: r5, "aria-label": "Select year ".concat(e4), tabIndex: -1, onKeyDown: function(r6) {
            return M2(r6, { year: e4, date: p3 }, { format: L2, type: "year" });
          }, className: j3(e4), onClick: function(r6) {
            return (function(e5, r7) {
              if (T3(e5)) return;
              var a3 = new d2.default(t3.date).setYear(e5), u4 = t3.selectedDate, s4 = t3.focused;
              if (v3) {
                var p4 = f2(w2(a3, o3, t3), 2);
                u4 = p4[0], s4 = p4[1];
              } else h3 && a3.monthIndex < h3.monthIndex ? a3 = a3.setMonth(h3.monthIndex + 1) : y3 && a3.monthIndex > y3.monthIndex && (a3 = a3.setMonth(y3.monthIndex + 1)), null == c3 || c3(a3), S2(E2(r7.target));
              n3(v3 ? u4 : void 0, l2(l2({}, t3), {}, { date: a3, focused: s4, selectedDate: u4, mustShowYearPicker: false })), v3 && i3(s4, a3);
            })(e4, r6);
          }, onMouseEnter: function() {
            return u3 && C3(e4);
          } }, a2.default.createElement("span", { className: v3 ? "sd" : "" }, R2(e4.toString(), Y3)));
        })));
      })));
      function j3(e3) {
        var r4 = ["rmdp-day"], n4 = t3.date, a3 = t3.selectedDate, o4 = t3.multiple;
        if (T3(e3) && r4.push("rmdp-disabled"), !r4.includes("rmdp-disabled") || !x3) {
          if (m3.year === e3 && s3 && r4.push("rmdp-today"), v3) if (b3) {
            var d3 = function(t4) {
              var n5 = t4[0], a4 = t4[1];
              if (1 === t4.length) {
                if (e3 === n5.year && r4.push("rmdp-range"), u3) {
                  var o5 = t4[0].year;
                  (e3 > o5 && e3 <= P3 || e3 < o5 && e3 >= P3) && (r4.push("rmdp-range-hover"), e3 === P3 && r4.push(P3 > o5 ? "end" : "start"));
                }
              } else 2 === t4.length && (e3 >= n5.year && e3 <= a4.year && r4.push("rmdp-range"), e3 === n5.year && r4.push("start"), e3 === a4.year && r4.push("end"));
            };
            o4 ? (g2(a3) ? a3 : [[a3]]).forEach((function(e4) {
              return d3(e4);
            })) : d3(a3);
          } else [].concat(a3).some((function(r5) {
            return r5 && r5.year === e3;
          })) && r4.push("rmdp-selected");
          else e3 === n4.year && r4.push("rmdp-selected");
          return r4.join(" ");
        }
      }
      function T3(e3) {
        return h3 && e3 < h3.year || y3 && e3 > y3.year;
      }
    }
    function V2(e3, r3, t3) {
      return t3 || (e3 ? "MM/YYYY" : r3 ? "YYYY" : "YYYY/MM/DD");
    }
    function W2(e3, r3) {
      var t3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "YYYY/MM/DD";
      return e3 instanceof d2.default ? e3.set({ calendar: r3, format: t3 }) : e3 = new d2.default({ date: e3, calendar: r3, format: t3 }), e3;
    }
    function B(e3) {
      "_self" in a2.default.createElement("div") && console.warn(e3.join("\n"));
    }
    var K = new d2.default(), _2 = K.calendar, z2 = K.locale;
    function H2(e3, r3) {
      return e3 && e3.constructor !== Object && (B(q("calendar")), e3 = void 0), r3 && r3.constructor !== Object && (B(q("locale")), r3 = void 0), [e3 || _2, r3 || z2];
    }
    function q(e3) {
      return ["".concat(e3, " must be an object"), "https://shahabyazdi.github.io/react-multi-date-picker/calendars/"];
    }
    function J2(e3) {
      return e3 && e3.name ? e3.name.split("_")[1] : "";
    }
    function U2(e3) {
      return ["fa", "ar"].includes(J2(e3));
    }
    function $2(e3, r3) {
      void 0 === r3 && (r3 = {});
      var t3 = r3.insertAt;
      if (e3 && "undefined" != typeof document) {
        var n3 = document.head || document.getElementsByTagName("head")[0], a3 = document.createElement("style");
        a3.type = "text/css", "top" === t3 && n3.firstChild ? n3.insertBefore(a3, n3.firstChild) : n3.appendChild(a3), a3.styleSheet ? a3.styleSheet.cssText = e3 : a3.appendChild(document.createTextNode(e3));
      }
    }
    $2(".rmdp-wrapper{background-color:#fff;border-radius:5px;direction:ltr;text-align:center;width:max-content}.rmdp-shadow{box-shadow:0 0 5px #8798ad}.rmdp-border{border:1px solid #cfd8e2}.rmdp-calendar{height:max-content;padding:4px}.rmdp-border-top{border-top:1px solid #cfd8e2}.rmdp-border-bottom{border-bottom:1px solid #cfd8e2}.rmdp-border-left{border-left:1px solid #cfd8e2}.rmdp-border-right{border-right:1px solid #cfd8e2}.rmdp-week,.rmdp-ym{display:flex;justify-content:space-between}.rmdp-ym{height:25%}.rmdp-day,.rmdp-week-day{color:#000;cursor:pointer;height:34px;position:relative;width:34px}.rmdp-calendar :focus{outline-color:#00539c}.rmdp-day:not(.rmdp-range):focus{border-radius:50%}.rmdp-ym .rmdp-day:not(.rmdp-range):focus{border-radius:15px}.rmdp-week-day{color:#0074d9;cursor:default;font-size:13px;font-weight:500}.rmdp-day span,.rmdp-week-day{display:flex;flex-direction:column;justify-content:center}.rmdp-day span{border-radius:50%;bottom:3px;font-size:14px;left:3px;position:absolute;right:3px;top:3px}.rmdp-day.rmdp-today span{background-color:#7fdbff;color:#fff}.rmdp-day.rmdp-selected span:not(.highlight){background-color:#0074d9;box-shadow:0 0 3px #8798ad;color:#fff}.rmdp-day.rmdp-deactive,.rmdp-day.rmdp-disabled{color:#8798ad}.rmdp-day.rmdp-deactive.rmdp-selected span{background-color:#4ca6f5;box-shadow:0 0 3px #bac5d3}.rmdp-ym .rmdp-day{flex:1;margin:auto}.rmdp-ym .rmdp-day span{border-radius:12px;padding:2px 0}.rmdp-range{background-color:#0074d9;box-shadow:0 0 3px #8798ad;color:#fff}.rmdp-range-hover{background-color:#7ea6f0;color:#fff}.rmdp-range-hover.start:not(.force),.rmdp-range.start:not(.force){border-bottom-left-radius:50%;border-top-left-radius:50%}.rmdp-range-hover.end:not(.force),.rmdp-range.end:not(.force){border-bottom-right-radius:50%;border-top-right-radius:50%}.rmdp-ym .rmdp-range-hover.start:not(.force),.rmdp-ym .rmdp-range.start:not(.force){border-bottom-left-radius:15px;border-top-left-radius:15px}.rmdp-ym .rmdp-range-hover.end:not(.force),.rmdp-ym .rmdp-range.end:not(.force){border-bottom-right-radius:15px;border-top-right-radius:15px}@media (hover:hover){.rmdp-day:not(.rmdp-disabled,.rmdp-day-hidden) span:hover{background-color:#7ea6f0;color:#fff}}.rmdp-day-picker{padding:5px}.rmdp-header{font-size:14px;margin-top:5px;padding:9px 0}.rmdp-month-picker,.rmdp-year-picker{background-color:#fff;border-radius:0 0 5px 5px;bottom:2px;left:2px;position:absolute;right:2px;top:2px}.only.rmdp-month-picker,.only.rmdp-year-picker{height:240px;position:static;width:240px}.rmdp-header-values{color:#000;margin:auto}.rmdp-header-values span{padding:0 0 0 5px}.rmdp-arrow{border:solid #0074d9;border-width:0 2px 2px 0;display:inline-block;height:3px;margin-top:5px;padding:2px;width:3px}.rmdp-right i{margin-right:3px;transform:rotate(-45deg);-webkit-transform:rotate(-45deg)}.rmdp-left i{margin-left:3px;transform:rotate(135deg);-webkit-transform:rotate(135deg)}.rmdp-left{left:0}.rmdp-right{right:0}.rmdp-arrow-container{background:transparent;border:none;border-radius:50%;cursor:pointer;display:flex;height:20px;justify-content:center;margin:0 5px;padding:0;width:20px}.rmdp-arrow-container:hover{background-color:#0074d9;box-shadow:0 0 3px #8798ad}.rmdp-arrow-container:hover .rmdp-arrow{border:solid #fff;border-width:0 2px 2px 0}.rmdp-arrow-container.disabled{cursor:default}.rmdp-arrow-container.disabled:hover{background-color:inherit;box-shadow:inherit}.rmdp-arrow-container.disabled .rmdp-arrow,.rmdp-arrow-container.disabled:hover .rmdp-arrow{border:solid gray;border-width:0 2px 2px 0}.rmdp-rtl{direction:rtl}.rmdp-rtl .rmdp-left i{margin-left:0;margin-right:3px;transform:rotate(-45deg);-webkit-transform:rotate(-45deg)}.rmdp-rtl .rmdp-right i{margin-left:3px;margin-right:0;transform:rotate(135deg);-webkit-transform:rotate(135deg)}.rmdp-rtl .rmdp-right{left:0;right:auto}.rmdp-rtl .rmdp-left{left:auto;right:0}.rmdp-rtl .rmdp-range-hover.start:not(.force),.rmdp-rtl .rmdp-range.start:not(.force){border-bottom-left-radius:unset;border-bottom-right-radius:50%;border-top-left-radius:unset;border-top-right-radius:50%}.rmdp-rtl .rmdp-range-hover.end:not(.force),.rmdp-rtl .rmdp-range.end:not(.force){border-bottom-left-radius:50%;border-bottom-right-radius:unset;border-top-left-radius:50%;border-top-right-radius:unset}.rmdp-rtl .rmdp-range.start.end:not(.force){border-radius:50%}.rmdp-rtl .rmdp-ym .rmdp-range-hover.start:not(.force),.rmdp-rtl .rmdp-ym .rmdp-range.start:not(.force){border-bottom-right-radius:15px;border-top-right-radius:15px}.rmdp-rtl .rmdp-ym .rmdp-range-hover.end:not(.force),.rmdp-rtl .rmdp-ym .rmdp-range.end:not(.force){border-bottom-left-radius:15px;border-top-left-radius:15px}.rmdp-day-hidden,.rmdp-day.rmdp-disabled{cursor:default}.rmdp-selected .highlight{box-shadow:0 0 3px #8798ad}.rmdp-day:not(.rmdp-disabled):not(.rmdp-day-hidden) .highlight-red:hover{background-color:#ff6687}.rmdp-day:not(.rmdp-deactive) .highlight-red{color:#cc0303}.rmdp-day.rmdp-deactive .highlight-red{color:#e08e8e}.rmdp-day.rmdp-selected .highlight-red{background-color:#ea0034;color:#fff}.rmdp-day.rmdp-deactive.rmdp-selected .highlight-red{background-color:#e4b0ba;color:#fff}.rmdp-day:not(.rmdp-disabled):not(.rmdp-day-hidden) .highlight-green:hover{background-color:#4db6ac}.rmdp-day:not(.rmdp-deactive) .highlight-green{color:#00796b}.rmdp-day.rmdp-deactive .highlight-green{color:#7ab3ac}.rmdp-day.rmdp-selected .highlight-green{background-color:#009688;color:#fff}.rmdp-day.rmdp-deactive.rmdp-selected .highlight-green{background-color:#749c98;color:#fff}.rmdp-day-hidden,.rmdp-day-hidden:hover span{background-color:unset;color:transparent}.rmdp-month-name{cursor:default;font-size:14px;margin:3px 0}.rmdp-full-year{grid-template-columns:1fr 1fr 1fr}@media (max-height:450px),(max-width:450px){.rmdp-day,.rmdp-week-day{height:28px;width:28px}.rmdp-day span{font-size:12px;padding-left:.5px}.only.rmdp-month-picker,.only.rmdp-year-picker{height:200px;width:230px}.rmdp-header{padding:3px 0 0}.rmdp-header,.rmdp-month-name{font-size:12px}.rmdp-full-year{grid-template-columns:1fr 1fr}}");
    var G = ["datePickerProps", "DatePicker"];
    function Q(r3, t3) {
      var n3, o3 = r3.value, i3 = r3.calendar, c3 = r3.locale, p3 = r3.format, m3 = r3.onlyMonthPicker, h3 = r3.onlyYearPicker, y3 = r3.range, v3 = void 0 !== y3 && y3, b3 = r3.multiple, x3 = void 0 !== b3 && b3, w3 = r3.className, k3 = r3.role, D3 = r3.weekDays, Y3 = r3.months, E3 = r3.children, O3 = r3.onChange, M3 = r3.showOtherDays, P3 = r3.minDate, N3 = r3.maxDate, T3 = r3.mapDays, L3 = r3.disableMonthPicker, B2 = r3.disableYearPicker, K2 = r3.formattingIgnoreList, _3 = r3.onReady, z3 = r3.onlyShowInRangeDates, q2 = void 0 === z3 || z3, J3 = r3.zIndex, $3 = void 0 === J3 ? 100 : J3, Q2 = r3.plugins, X2 = void 0 === Q2 ? [] : Q2, ee2 = r3.sort, re2 = r3.numberOfMonths, te2 = void 0 === re2 ? 1 : re2, ne2 = r3.currentDate, ae2 = r3.digits, oe2 = r3.buttons, de = void 0 === oe2 || oe2, ie = r3.renderButton, le = r3.weekStartDayIndex, ce = void 0 === le ? 0 : le, ue = r3.disableDayPicker, se = r3.onPropsChange, fe = r3.onMonthChange, pe = r3.onYearChange, me = r3.onFocusedDateChange, he = r3.readOnly, ye = r3.disabled, ge = r3.hideMonth, ve = r3.hideYear, be = r3.hideWeekDays, xe = r3.shadow, we = void 0 === xe || xe, ke = r3.fullYear, De = r3.displayWeekNumbers, Ye = r3.weekNumber, Ee = r3.weekPicker, Oe = r3.rangeHover, Me = r3.monthYearSeparator, Se = r3.formatMonth, Pe = r3.formatYear, Ce = r3.highlightToday, Ne = void 0 === Ce || Ce, Ie = r3.headerOrder, je = void 0 === Ie ? ["LEFT_BUTTON", "MONTH_YEAR", "RIGHT_BUTTON"] : Ie, Te = r3.style, Ae = void 0 === Te ? {} : Te, Re = r3.autoFocus, Le = void 0 !== Re && Re;
      !ne2 || ne2 instanceof d2.default || (console.warn("currentDate must be instance of DateObject"), ne2 = void 0), ("number" != typeof ce || ce < 0 || ce > 6) && (ce = 0), ("number" != typeof te2 || te2 < 1 || h3) && (te2 = 1), !(x3 || v3 || g2(o3)) || v3 || x3 || (x3 = true), Ee && (v3 = true, x3 = false), ke && (te2 = 12, m3 = false, h3 = false), h3 && !ge && (ge = true);
      var Fe = f2(H2(i3, c3), 2);
      i3 = Fe[0], c3 = Fe[1], p3 = V2(m3, h3, p3), K2 = j2(K2), T3 = [].concat(T3).filter(Boolean), X2 = [].concat.apply([], X2);
      var Ve = f2(e2.useState({}), 2), We = Ve[0], Be = Ve[1], Ke = {}, _e = e2.useRef({ mustCallOnReady: true, currentDate: ne2 });
      e2.useEffect((function() {
        Be((function(e3) {
          var r4 = _e.current.currentDate, t4 = e3.date, n4 = e3.selectedDate, a3 = e3.initialValue, u3 = e3.focused, s3 = e3.mustSortDates;
          function f3(e4) {
            if (e4) return e4.calendar.name !== i3.name && e4.setCalendar(i3), e4.locale.name !== c3.name && e4.setLocale(c3), e4._format !== p3 && e4.setFormat(p3), e4.digits = ae2, e4.ignoreList = JSON.parse(K2), e4;
          }
          function y4(e4) {
            return new d2.default(r4 || e4);
          }
          if (o3) if (g2(n4 = Z(o3, i3, c3, p3))) t4 || (t4 = y4(n4.flat()[0]));
          else if (t4 && 1 !== te2) {
            var b4 = new d2.default(t4).toFirstOfMonth(), w4 = new d2.default(t4).add(te2 - 1, m3 ? "years" : "months").toLastOfMonth();
            (n4 < b4 || n4 > w4) && (t4 = new d2.default(n4));
          } else t4 = y4(n4);
          else t4 || (t4 = y4({ calendar: i3, locale: c3, format: p3 })), a3 && (n4 = void 0);
          if ([].concat(n4).flat().forEach(f3), f3(t4), x3 || v3 || g2(o3)) {
            if (n4 || (n4 = []), g2(n4) || (n4 = x3 && v3 ? [[n4]] : [n4]), v3 && !x3 && n4.length > 2) {
              var k4 = n4[n4.length - 1];
              n4 = [n4[0], k4], u3 = k4;
            }
            x3 && !v3 && ee2 && !s3 ? (s3 = true, n4.sort((function(e4, r5) {
              return e4 - r5;
            }))) : v3 && !x3 && n4.sort((function(e4, r5) {
              return e4 - r5;
            }));
          } else g2(n4) && (n4 = n4.flat()[n4.length - 1]);
          return ke && t4.toFirstOfYear(), delete _e.current.currentDate, l2(l2({}, e3), {}, { date: t4, selectedDate: n4, multiple: x3, range: v3, onlyMonthPicker: m3, onlyYearPicker: h3, initialValue: e3.initialValue || o3, value: o3, focused: u3, calendar: i3, locale: c3, format: p3, mustSortDates: s3, year: t4.year, today: f3(e3.today) || new d2.default({ calendar: i3 }), weekPicker: Ee });
        }));
      }), [o3, i3, c3, p3, m3, h3, v3, x3, ee2, te2, ae2, K2, ke, Ee]), e2.useEffect((function() {
        (P3 || N3) && Be((function(e3) {
          var r4 = e3.calendar, t4 = e3.locale, n4 = e3.format, a3 = (function(e4, r5, t5, n5, a4) {
            r5 && (r5 = W2(r5, n5, a4).set({ hour: 0, minute: 0, second: 0, millisecond: 0 }));
            t5 && (t5 = W2(t5, n5, a4).set({ hour: 23, minute: 59, second: 59, millisecond: 999 }));
            g2(e4) && (e4 = e4.filter((function(e5) {
              return !(r5 && e5 < r5) && !(t5 && e5 > t5);
            })));
            return [e4, r5, t5];
          })(Z(o3, r4, t4, n4), P3, N3, r4, n4), d3 = f2(a3, 3), i4 = d3[0], c4 = d3[1], u3 = d3[2];
          return l2(l2({}, e3), {}, { inRangeDates: q2 ? i4 : e3.selectedDate, minDate: c4, maxDate: u3 });
        }));
      }), [P3, N3, q2, o3]), We.today && !_e.current.isReady && (_e.current.isReady = true), e2.useEffect((function() {
        _e.current.isReady && _e.current.mustCallOnReady && _3 instanceof Function && (_e.current.mustCallOnReady = false, _3());
      }), [_e.current.isReady, _3]);
      var ze = "rmdp-top-class " + tr(["top", "bottom"]), He = { top: [], bottom: [], left: [], right: [] }, qe = U2(null === (n3 = We.date) || void 0 === n3 ? void 0 : n3.locale), Je = { state: We, setState: Be, onChange: Xe, sort: ee2, handleFocusedDate: er, isRTL: qe, fullYear: ke, monthAndYears: (function() {
        var e3 = We.date;
        if (!e3) return [];
        for (var r4 = [], t4 = [], n4 = e3.digits, a3 = 0; a3 < te2; a3++) {
          var o4 = void 0, d3 = e3.year, i4 = e3.monthIndex + a3;
          if (m3 && (d3 += a3), i4 > 11 && (i4 -= 12, m3 || d3++), g2(Y3) && Y3.length >= 12) {
            var l3 = Y3[i4];
            o4 = g2(l3) ? l3[0] : l3;
          } else o4 = e3.months[i4].name;
          d3 = R2(d3.toString(), n4), r4.push(o4), t4.push(d3);
        }
        return [r4, t4];
      })(), rangeHover: Oe, highlightToday: Ne, numberOfMonths: te2 }, Ue = arguments[0], $e = Ue.datePickerProps, Ge = Ue.DatePicker, Qe = s2(Ue, G);
      return e2.useEffect((function() {
        var e3 = _e.current.Calendar;
        e3 && S2(e3, void 0, Le && !Ge);
      }), [Le, We.today, Ge]), (function() {
        if (!_e.current.isReady || !g2(X2)) return;
        var r4 = { state: We, setState: Be, registerListener: nr, calendarProps: Qe, datePickerProps: $e, handleChange: Xe, Calendar: _e.current.Calendar, DatePicker: Ge, handlePropsChange: Ze, handleFocusedDate: function(e3) {
          return er(e3);
        }, minDate: P3, maxDate: N3 }, t4 = function(e3) {
          return ue ? "bottom" : e3.props.position || "right";
        };
        X2.forEach((function(n4, a3) {
          if ("string" != typeof n4.type) {
            var o4 = {}, d3 = t4(n4);
            if (He[d3] && !n4.props.disabled) {
              for (var i4 = 0; i4 < X2.length; i4++) if ("string" != typeof X2[i4].type && !X2[i4].props.disabled) {
                if (4 === Object.keys(o4).length) break;
                var c4 = t4(X2[i4]);
                ["top", "bottom"].includes(d3) ? (c4 === d3 && i4 > a3 && (o4.bottom = true), c4 === d3 && i4 < a3 && (o4.top = true)) : (ze.includes("border-top") && (o4.top = true), ze.includes("border-bottom") && (o4.bottom = true), c4 === d3 && i4 > a3 && (o4.right = true), c4 === d3 && i4 < a3 && (o4.left = true));
              }
              He[d3].push(e2.cloneElement(n4, l2({ key: a3, position: d3, nodes: o4 }, r4)));
            }
          } else "mapDays" === n4.type && T3.push(n4.fn(r4));
        }));
      })(), We.today ? a2.default.createElement("div", { ref: function(e3) {
        e3 && (e3.date = We.date, e3.set = function(e4, r4) {
          ye || Be(l2(l2({}, We), {}, { date: new d2.default(We.date.set(e4, r4)) }));
        });
        if (_e.current.Calendar = e3, t3 instanceof Function) return t3(e3);
        t3 && (t3.current = e3);
      }, role: k3 || "dialog", className: "rmdp-wrapper rmdp-".concat(we ? "shadow" : "border", " ").concat(w3 || ""), style: l2({ zIndex: $3 }, Ae) }, He.top, a2.default.createElement("div", { style: { display: "flex" }, className: ze }, He.left, !ue && a2.default.createElement("div", { className: "rmdp-calendar ".concat(qe ? "rmdp-rtl" : "", " ").concat(tr(["left", "right"])) }, a2.default.createElement(I2, l2(l2({}, Je), {}, { disableYearPicker: B2, disableMonthPicker: L3, buttons: de, renderButton: ie, handleMonthChange: rr, disabled: ye, hideMonth: ge, hideYear: ve, monthYearSeparator: Me, formatMonth: Se, formatYear: Pe, headerOrder: je, onYearChange: pe })), a2.default.createElement("div", { style: { position: "relative" } }, a2.default.createElement(C2, l2(l2({}, Je), {}, { showOtherDays: M3, mapDays: T3, onlyShowInRangeDates: q2, customWeekDays: D3, weekStartDayIndex: ce, hideWeekDays: be, displayWeekNumbers: De, weekNumber: Ye })), !ke && a2.default.createElement(a2.default.Fragment, null, !L3 && a2.default.createElement(A2, u2({}, Je, { customMonths: Y3, handleMonthChange: rr })), !B2 && a2.default.createElement(F2, u2({}, Je, { onYearChange: pe }))))), He.right), He.bottom, E3) : null;
      function Xe(e3, r4) {
        if (e3 instanceof d2.default && (e3 = new d2.default(e3)), !ye) {
          if (e3 || null === e3) {
            if (he) return;
            Ke.change && Ke.change.forEach((function(r5) {
              return r5(e3);
            }));
          }
          if (e3 || null === e3) {
            var t4 = null == O3 ? void 0 : O3(e3);
            r4 && false !== t4 && Be(r4);
          } else r4 && Be(r4);
          Ze({ value: e3 });
        }
      }
      function Ze() {
        var e3, r4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        if (!he && !ye) {
          var t4 = l2(l2(l2(l2({}, Qe), $e), r4), {}, { value: null !== (e3 = r4.value) && void 0 !== e3 ? e3 : We.selectedDate });
          delete t4.onPropsChange, null == se || se(t4);
        }
      }
      function er(e3, r4) {
        he || ye || null == me || me(e3, r4);
      }
      function rr(e3) {
        null == fe || fe(e3);
      }
      function tr(e3) {
        return ue || !g2(X2) ? "" : Array.from(new Set(X2.map((function(r4) {
          if (!r4.props) return "";
          var t4 = r4.props.position || "right";
          return e3.includes(t4) && !r4.props.disabled ? "rmdp-border-" + t4 : "";
        })))).join(" ");
      }
      function nr(e3, r4) {
        Ke[e3] || (Ke[e3] = []), Ke[e3].push(r4);
      }
    }
    var X = e2.forwardRef(Q);
    function Z(e3, r3, t3, n3) {
      var a3 = [].concat(e3).map((function(e4) {
        return g2(e4) ? e4.map(o3).filter(i3) : o3(e4);
      })).filter(i3);
      return g2(e3) ? a3 : a3.flat()[0];
      function o3(e4) {
        return e4 ? e4 instanceof d2.default ? e4 : new d2.default({ date: e4, calendar: r3, locale: t3, format: n3 }) : {};
      }
      function i3(e4) {
        return g2(e4) || e4.isValid;
      }
    }
    $2('.rmdp-visible{visibility:visible}.rmdp-invisible{visibility:hidden}.rmdp-input{border:1px solid #c0c4d6;border-radius:5px;height:22px;margin:1px 0;padding:2px 5px}.rmdp-input:focus{border:1px solid #a4b3c5;box-shadow:0 0 2px #a4b3c5;outline:none!important}.rmdp-button{background-color:#0074d9;border:none;border-radius:5px;color:#fff;cursor:pointer;display:inline-block;padding:7px 16px;text-align:center;text-decoration:none;transition:.3s}.rmdp-button:hover{background-color:#143ac5;transition:.4s}.rmdp-button:disabled{background-color:#8798ad}.rmdp-action-button{border-radius:unset;color:#2682d3;float:right;font-weight:700;margin:15px 10px 15px 0}.rmdp-action-button,.rmdp-action-button:hover{background-color:transparent}.rmdp-ep-arrow{overflow:hidden;will-change:transform}.rmdp-ep-arrow:after{background-color:#fff;content:"";height:12px;position:absolute;transform:rotate(45deg);width:12px}.rmdp-ep-shadow:after{box-shadow:0 0 6px #8798ad}.rmdp-ep-border:after{border:1px solid #cfd8e2}.rmdp-ep-arrow[direction=top]{border-bottom:1px solid #fff}.rmdp-ep-arrow[direction=left]{border-right:1px solid #fff}.rmdp-ep-arrow[direction=right]{border-left:1px solid #fff;margin-left:-1px}.rmdp-ep-arrow[direction=bottom]{border-top:1px solid #fff;margin-top:-1.5px}.rmdp-ep-arrow[direction=top]:after{left:4px;top:5px}.rmdp-ep-arrow[direction=bottom]:after{left:4px;top:-6px}.rmdp-ep-arrow[direction=left]:after{left:5px;top:3px}.rmdp-ep-arrow[direction=right]:after{left:-6px;top:3px}');
    var ee = ["value", "calendar", "locale", "format", "onlyMonthPicker", "onlyYearPicker", "onChange", "range", "multiple", "name", "id", "title", "placeholder", "required", "style", "className", "inputClass", "disabled", "render", "weekDays", "months", "children", "inputMode", "scrollSensitive", "hideOnScroll", "minDate", "maxDate", "formattingIgnoreList", "containerClassName", "calendarPosition", "editable", "onOpen", "onClose", "arrowClassName", "zIndex", "arrow", "fixMainPosition", "onPositionChange", "onPropsChange", "digits", "readOnly", "shadow", "onFocusedDateChange", "type", "weekPicker", "mobileLabels", "onOpenPickNewDate", "mobileButtons", "dateSeparator", "multipleRangeSeparator", "typingTimeout"], re = ["label"];
    function te(r3, t3) {
      var n3 = r3.value, i3 = r3.calendar, c3 = r3.locale, p3 = r3.format, m3 = r3.onlyMonthPicker, h3 = r3.onlyYearPicker, v3 = r3.onChange, b3 = r3.range, x3 = void 0 !== b3 && b3, w3 = r3.multiple, k3 = void 0 !== w3 && w3, D3 = r3.name, Y3 = r3.id, E3 = r3.title, O3 = r3.placeholder, M3 = r3.required, S3 = r3.style, P3 = void 0 === S3 ? {} : S3, C3 = r3.className, N3 = void 0 === C3 ? "" : C3, I3 = r3.inputClass, T3 = r3.disabled, A3 = r3.render, L3 = r3.weekDays, F3 = r3.months, B2 = r3.children, K2 = r3.inputMode, _3 = r3.scrollSensitive, z3 = void 0 === _3 || _3, q2 = r3.hideOnScroll, $3 = r3.minDate, G2 = r3.maxDate, Q2 = r3.formattingIgnoreList, Z2 = r3.containerClassName, te2 = void 0 === Z2 ? "" : Z2, ne2 = r3.calendarPosition, de = void 0 === ne2 ? "bottom-left" : ne2, ie = r3.editable, le = void 0 === ie || ie, ce = r3.onOpen, ue = r3.onClose, se = r3.arrowClassName, fe = void 0 === se ? "" : se, pe = r3.zIndex, me = void 0 === pe ? 100 : pe, he = r3.arrow, ye = void 0 === he || he, ge = r3.fixMainPosition, ve = r3.onPositionChange, be = r3.onPropsChange, xe = r3.digits, we = r3.readOnly, ke = r3.shadow, De = void 0 === ke || ke, Ye = r3.onFocusedDateChange, Ee = r3.type, Oe = r3.weekPicker, Me = r3.mobileLabels, Se = r3.onOpenPickNewDate, Pe = void 0 === Se || Se, Ce = r3.mobileButtons, Ne = void 0 === Ce ? [] : Ce, Ie = r3.dateSeparator, je = r3.multipleRangeSeparator, Te = void 0 === je ? "," : je, Ae = r3.typingTimeout, Re = void 0 === Ae ? 700 : Ae, Le = s2(r3, ee), Fe = f2(e2.useState(), 2), Ve = Fe[0], We = Fe[1], Be = f2(e2.useState(), 2), Ke = Be[0], _e = Be[1], ze = f2(e2.useState(""), 2), He = ze[0], qe = ze[1], Je = f2(e2.useState(false), 2), Ue = Je[0], $e = Je[1], Ge = f2(e2.useState(false), 2), Qe = Ge[0], Xe = Ge[1], Ze = e2.useRef(), er = e2.useRef(), rr = e2.useRef(), tr = e2.useRef({ isTyping: false }), nr = Ie || (x3 || Oe ? " ~ " : ", "), ar = arguments[0], or = "string" == typeof N3 && N3.includes("rmdp-mobile"), dr = e2.useCallback((function() {
        if (false !== (null == ue ? void 0 : ue())) {
          var e3 = oe(er);
          if (e3 && e3.forEach((function(e4) {
            return e4.blur();
          })), tr.current.mobile) {
            var r4 = rr.current.parentNode.parentNode;
            r4.classList.remove("rmdp-calendar-container-mobile"), r4.style.position = "absolute", r4.style.visibility = "hidden";
          }
          void 0 !== tr.current.validInputValue && (qe(tr.current.validInputValue), tr.current.validInputValue = void 0), $e(false), Xe(false);
        }
      }), [ue]), ir = [{ type: "button", className: "rmdp-button rmdp-action-button", onClick: function() {
        _e(void 0), dr();
      }, label: ur("CANCEL") }, { type: "button", className: "rmdp-button rmdp-action-button", onClick: function() {
        Ke && (pr(Ke, true), _e(void 0)), dr();
      }, label: ur("OK") }];
      or && !tr.current.mobile && (tr.current = l2(l2({}, tr.current), {}, { mobile: true })), !or && tr.current.mobile && (tr.current = l2(l2({}, tr.current), {}, { mobile: false })), Q2 = j2(Q2), p3 = V2(m3, h3, p3);
      var lr, cr = f2(H2(i3, c3), 2);
      return i3 = cr[0], c3 = cr[1], e2.useEffect((function() {
        function e3(e4) {
          if (Ue && !tr.current.mobile) {
            var r5 = [];
            if ([er.current, rr.current].forEach((function(t4) {
              var n4, a3;
              !t4 || t4.contains(e4.target) || e4.target.classList.contains("b-deselect") || null !== (n4 = e4.target.parentNode) && void 0 !== n4 && null !== (n4 = n4.classList) && void 0 !== n4 && null !== (a3 = n4.contains) && void 0 !== a3 && a3.call(n4, "b-deselect") || r5.push(t4);
            })), 2 === r5.length) return dr();
            rr.current && rr.current.contains(e4.target) && (Ze.current.removeTransition(), Ze.current.refreshPosition());
          }
        }
        function r4() {
          q2 && Ue && dr();
        }
        return document.addEventListener("click", e3, false), document.addEventListener("scroll", r4, true), function() {
          document.removeEventListener("click", e3, false), document.removeEventListener("scroll", r4, true);
        };
      }), [dr, t3, Ue, q2]), e2.useEffect((function() {
        var e3 = n3, r4 = tr.current, t4 = r4.date, a3 = r4.initialValue, o3 = function() {
          return e3[e3.length - 1];
        };
        function u3(e4) {
          if (e4) return e4 instanceof d2.default || (e4 = new d2.default({ date: e4, calendar: i3, locale: c3, format: p3 })), e4.calendar !== i3 && e4.setCalendar(i3), e4.set({ weekDays: L3, months: F3, digits: xe, locale: c3, format: p3, ignoreList: JSON.parse(Q2) }), e4;
        }
        n3 || a3 || !t4 ? a3 && !n3 && (a3 = void 0) : e3 = t4;
        var s3 = "";
        if (x3 || k3 || g2(e3)) {
          var m4 = function(e4) {
            return e4 = e4.map(u3).filter((function(e5) {
              return void 0 !== e5;
            })), x3 && e4.length > 2 && (e4 = [e4[0], o3()]), [e4, ae(e4, nr)];
          };
          if (g2(e3) || (e3 = x3 && k3 ? e3 ? [[e3]] : [] : [e3]), k3 && x3) e3 = e3.map((function(r5, t5) {
            var n4 = f2(m4(g2(r5) ? r5 : [r5]), 2), a4 = n4[0], o4 = n4[1];
            return s3 += o4 + (t5 < e3.length - 1 ? " ".concat(Te, " ") : ""), a4;
          }));
          else {
            var h4 = f2(m4(e3), 2);
            e3 = h4[0], s3 = h4[1];
          }
          s3 = s3.toString().replace(/\s,\s$/, "");
        } else g2(e3) && (e3 = o3()), (e3 = u3(e3)) && (s3 = e3.format());
        tr.current.isTyping || qe(s3), tr.current = l2(l2({}, tr.current), {}, { date: e3, separator: nr, initialValue: a3 || n3 }), tr.current.mobile && Ze.current.isOpen ? _e(e3) : (tr.current.validInputValue = void 0, We(e3));
      }), [n3, i3, c3, p3, x3, k3, nr, m3, h3, L3, F3, xe, Q2]), e2.useEffect((function() {
        var e3 = tr.current.selection;
        if (e3) {
          var r4 = oe(er);
          0 !== r4.length && (r4.forEach((function(r5) {
            document.activeElement === r5 && (r5.setSelectionRange(e3, e3), tr.current.selection = void 0);
          })), Ze.current.refreshPosition());
        }
      }), [He]), (k3 || x3 || g2(Ve) || !le) && (K2 = "none"), a2.default.createElement(o2.default, u2({ ref: function(e3) {
        e3 && (e3.openCalendar = function() {
          return setTimeout((function() {
            return sr();
          }), 10);
        }, e3.closeCalendar = dr, e3.isOpen = Ue && Qe);
        if (Ze.current = e3, t3 instanceof Function) return t3(e3);
        t3 && (t3.current = e3);
      }, element: A3 ? a2.default.createElement("div", { ref: er }, e2.isValidElement(A3) ? e2.cloneElement(A3, { value: He, openCalendar: sr, onFocus: sr, handleValueChange: mr, onChange: mr, locale: c3, separator: nr }) : A3 instanceof Function ? A3(He, sr, mr, c3, nr) : null) : a2.default.createElement("input", { ref: er, type: Ee || "text", name: D3, id: Y3, title: E3, required: M3, onFocus: sr, className: I3 || "rmdp-input", placeholder: O3, value: He, onChange: mr, style: P3, autoComplete: "off", disabled: !!T3, inputMode: K2 || (or ? "none" : void 0), readOnly: we }), popper: Ue && a2.default.createElement(X, u2({ ref: rr, value: Ke || Ve, onChange: pr, range: x3, multiple: k3, calendar: i3, locale: c3, format: p3, onlyMonthPicker: m3, onlyYearPicker: h3, className: N3 + (or ? " rmdp-mobile" : ""), weekDays: L3, months: F3, digits: xe, minDate: $3, maxDate: G2, formattingIgnoreList: JSON.parse(Q2), onPropsChange: be, shadow: De, onReady: hr, DatePicker: Ze.current, datePickerProps: ar, onFocusedDateChange: yr, weekPicker: Oe }, Le), B2, or && (lr = [].concat.apply([], ar.plugins || []).some((function(e3) {
        var r4 = e3.props;
        return !(void 0 === r4 ? {} : r4).disabled;
      })), g2(Ne) && a2.default.createElement("div", { className: "rmdp-action-buttons ".concat(U2(c3) ? "rmdp-rtl" : "", " ").concat(lr ? "rmdp-border-top" : "") }, Ne.concat(ir).map((function(e3, r4) {
        var t4 = e3.label, n4 = s2(e3, re);
        return a2.default.createElement("button", u2({ key: r4 }, n4), t4);
      }))))), active: !or && Qe, position: de, arrow: !or && ye, fixMainPosition: !z3 || ge, zIndex: me, onChange: !or && ve, containerClassName: "rmdp-container ".concat(te2), arrowClassName: ["rmdp-ep-arrow", "rmdp-ep-".concat(De ? "shadow" : "border"), N3, fe].join(" ") }, Le));
      function ur(e3) {
        var r4, t4 = c3 || new d2.default().locale;
        if ("string" != typeof t4.name) return e3;
        return (null == Me ? void 0 : Me[e3]) || (null === (r4 = { en: { OK: "OK", CANCEL: "CANCEL" }, fa: { OK: "", CANCEL: "" }, ar: { OK: "", CANCEL: "" }, hi: { OK: "", CANCEL: " " } }[J2(t4)]) || void 0 === r4 ? void 0 : r4[e3]) || e3;
      }
      function sr() {
        if (!T3 && !we && false !== (null == ce ? void 0 : ce())) {
          if (Pe && !n3 && !tr.current.date && !x3 && !k3 && !or) {
            var e3 = new d2.default({ calendar: i3, locale: c3, format: p3, months: F3, weekDays: L3, digits: xe, ignoreList: JSON.parse(Q2) });
            (!$3 || e3 > W2($3, i3, p3)) && (!G2 || e3 < W2(G2, i3, p3)) && (pr(e3), null == be || be(l2(l2({}, ar), {}, { value: e3 })), tr.current.date = e3);
          }
          var r4 = oe(er);
          or && r4.length > 0 && r4.forEach((function(e4) {
            return e4.blur();
          })), r4.length > 0 || !Ue ? $e(true) : dr();
        }
      }
      function fr(e3) {
        var r4 = "";
        return e3 && (r4 = k3 && x3 && g2(e3) ? e3.map((function(e4) {
          return ae(e4, nr);
        })).join(" ".concat(Te, " ")) : ae(e3, nr)), r4;
      }
      function pr(e3, r4, t4) {
        if (or && !r4) return _e(e3);
        var a3 = fr(e3), o3 = t4 || a3.toString().replace(/\s,\s$/, "");
        return e3 && [].concat(e3).flat().some((function(e4) {
          return $3 && e4 < W2($3, i3, p3) || G2 && e4 > W2(G2, i3, p3);
        })) ? (tr.current.validInputValue = fr(n3 || tr.current.date), qe(o3)) : (tr.current.validInputValue = a3, false === (null == v3 ? void 0 : v3(e3, { validatedValue: a3, input: er.current, isTyping: !!t4 })) ? (qe(He), false) : (We(e3), qe(o3), void (tr.current = l2(l2({}, tr.current), {}, { date: e3 }))));
      }
      function mr(e3) {
        if (le) {
          tr.current.isTyping = true, setTimeout((function() {
            tr.current.isTyping = false;
          }), Re), tr.current.selection = e3.target.selectionStart;
          var r4 = e3.target.value, t4 = { calendar: i3, locale: c3, format: p3, ignoreList: JSON.parse(Q2) };
          if (xe = g2(xe) ? xe : c3.digits, !r4) return qe(""), pr(null);
          if (xe) {
            var n4, a3, o3 = y2(xe);
            try {
              for (o3.s(); !(n4 = o3.n()).done; ) {
                var u3 = n4.value;
                r4 = r4.replace(new RegExp(u3, "g"), xe.indexOf(u3));
              }
            } catch (e4) {
              o3.e(e4);
            } finally {
              o3.f();
            }
            a3 = g2(Ve) ? k3 && x3 ? (r4 || "").split(Te).filter(Boolean).map(f3) : f3(r4) : s3(r4), pr(g2(Ve) || a3.isValid ? a3 : null, void 0, R2(r4, xe));
          }
        }
        function s3(e4) {
          return /(?=.*Y)(?=.*M)(?=.*D)/.test(p3) ? new d2.default(l2(l2({}, t4), {}, { date: e4 })) : new d2.default(t4).parse(e4);
        }
        function f3(e4) {
          return (e4 || "").split(nr).filter(Boolean).map((function(e5) {
            return s3(e5.trim());
          }));
        }
      }
      function hr() {
        if (Xe(true), or) {
          var e3 = rr.current.parentNode.parentNode;
          e3.className = "rmdp-calendar-container-mobile", e3.style.position = "fixed", e3.style.transform = "", setTimeout((function() {
            e3.style.visibility = "visible";
          }), 50);
        }
      }
      function yr(e3, r4) {
        g2(tr.current.date) || !r4 || or || dr(), null == Ye || Ye(e3, r4);
      }
    }
    var ne = e2.forwardRef(te);
    function ae(e3, r3) {
      var t3 = [].concat(e3).map((function(e4) {
        return null != e4 && e4.isValid ? e4.format() : "";
      }));
      return t3.toString = function() {
        return this.filter(Boolean).join(r3);
      }, t3;
    }
    function oe(e3) {
      return e3.current ? "INPUT" === e3.current.tagName ? [e3.current] : Array.from(e3.current.querySelectorAll("input")) : [];
    }
    Object.defineProperty(exports$1, "DateObject", { enumerable: true, get: function() {
      return d2.default;
    } }), exports$1.Calendar = X, exports$1.default = ne, exports$1.getAllDatesInRange = function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], r3 = arguments.length > 1 ? arguments[1] : void 0;
      if (!Array.isArray(e3)) return [];
      var t3 = e3[0], n3 = e3[e3.length - 1], a3 = [];
      if (!(t3 instanceof d2.default && n3 instanceof d2.default && t3.isValid && n3.isValid && !(t3 > n3))) return [];
      for (t3 = new d2.default(t3), n3 = new d2.default(n3); t3 <= n3; t3.day++) a3.push(r3 ? t3.toDate() : new d2.default(t3));
      return a3;
    }, exports$1.toDateObject = W2;
  })(build);
  return build;
}
var buildExports = requireBuild();
const DatePicker = /* @__PURE__ */ getDefaultExportFromCjs(buildExports);
const PageHeader = (props) => {
  const [dropdownOpen, setDropdownOpen] = reactExports.useState(false);
  const selectopen = () => setDropdownOpen((prevState) => !prevState);
  const [state, setState] = reactExports.useState([
    {
      startDate: /* @__PURE__ */ new Date(),
      endDate: addDays(/* @__PURE__ */ new Date(), 7),
      key: "selection"
    }
  ]);
  const [dates, setDates] = reactExports.useState();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-leftheader", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "page-title", children: props.title }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-rightheader ms-auto d-lg-flex d-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ms-5 mb-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "btn btn-white date-range-btn", id: "daterange-btn", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "header-icon2 me-3", x: "1008", y: "1248", viewBox: "0 0 24 24", height: "100%", width: "100%", preserveAspectRatio: "xMidYMid meet", focusable: "false", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 8h14V6H5z", opacity: ".3" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11h2v2H7zm12-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V10h14v10zm0-12H5V6h14v2zm-4 3h2v2h-2zm-4 0h2v2h-2z" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Dropdown$1, { tag: "span", isOpen: dropdownOpen, toggle: selectopen, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownToggle, { tag: "span", caret: true, children: [
          props.date,
          " "
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenu, { className: "mt-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DatePicker,
          {
            className: "form-control",
            placeholder: "Date Range",
            value: dates,
            onChange: setDates,
            multiple: true,
            numberOfMonths: 1
          }
        ) })
      ] })
    ] }) }) })
  ] });
};
const PageHeaders = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-leftheader", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "page-title", children: props.title }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-rightheader ms-auto d-lg-flex d-none", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Breadcrumb$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbItem, { className: "d-flex", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            className: "svg-icon",
            xmlns: "http://www.w3.org/2000/svg",
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0 0h24v24H0V0z", fill: "none" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 3L2 12h3v8h6v-6h2v6h6v-8h3L12 3zm5 15h-2v-6H9v6H7v-7.81l5-4.5 5 4.5V18z" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 10.19V18h2v-6h6v6h2v-7.81l-5-4.5z", opacity: ".3" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "breadcrumb-icon", children: props.home })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", children: props.name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbItem, { active: true, "aria-current": "page", children: props.fonticonsname })
    ] }) })
  ] });
};
const PageHeaderstyle = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-leftheader", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "page-title", children: props.title }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-rightheader ms-auto d-lg-flex d-none", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Breadcrumb$1, { tag: "ol", className: "", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbItem, { tag: "li", className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", className: "d-flex", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "svg-icon", xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 0 24 24", width: "24", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0 0h24v24H0V0z", fill: "none" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 3L2 12h3v8h6v-6h2v6h6v-8h3L12 3zm5 15h-2v-6H9v6H7v-7.81l5-4.5 5 4.5V18z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 10.19V18h2v-6h6v6h2v-7.81l-5-4.5z", opacity: ".3" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "breadcrumb-icon", children: [
          " ",
          props.home
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbItem, { tag: "li", className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", children: props.Pages }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbItem, { tag: "li", className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", children: props.elements }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbItem, { tag: "li", className: " ", active: true, "aria-current": "page", children: props.name })
    ] }) })
  ] });
};
function Modaluser(args) {
  const [modal, setModal] = reactExports.useState(false);
  const toggle2 = () => setModal(!modal);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$1, { color: "primary", onClick: toggle2, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fe fe-plus" }),
      " Add New User"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Modal$1, { isOpen: modal, toggle: toggle2, ...args, size: "lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ModalHeader, { toggle: toggle2, children: "Modal title" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ModalBody, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-1", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { className: "form", noValidate: true, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Row, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Col, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: "Full Name" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  className: "form-control",
                  type: "text",
                  name: "name",
                  placeholder: "John Smith",
                  defaultValue: "John Smith"
                }
              )
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: "Username" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  className: "form-control",
                  type: "text",
                  name: "username",
                  placeholder: "johnny.s",
                  defaultValue: "johnny.s"
                }
              )
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Row, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: "Email" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                className: "form-control",
                type: "text",
                placeholder: "user@example.com"
              }
            )
          ] }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Row, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { className: "mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: "About" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "textarea",
              {
                className: "form-control",
                rows: 5,
                placeholder: "My Bio"
              }
            )
          ] }) }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Col, { sm: 6, className: "col-12  mb-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "Change Password" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Row, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: "Current Password" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  className: "form-control",
                  type: "password",
                  placeholder: ""
                }
              )
            ] }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: "New Password" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    className: "form-control",
                    type: "password",
                    placeholder: ""
                  }
                )
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { children: [
                  "Confirm",
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "d-none d-xl-inline", children: "Password" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    className: "form-control",
                    type: "password",
                    placeholder: ""
                  }
                )
              ] }) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Col, { sm: 5, className: "col-12 offset-sm-1 mb-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "Keeping in Touch" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Row, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Col, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: "Email Notifications" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "custom-controls-stacked px-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "custom-control custom-checkbox", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      type: "checkbox",
                      className: "custom-control-input",
                      id: "notifications-blog",
                      defaultChecked: true
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Label,
                    {
                      className: "custom-control-label",
                      htmlFor: "notifications-blog",
                      children: "Blog posts"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "custom-control custom-checkbox", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      type: "checkbox",
                      className: "custom-control-input",
                      id: "notifications-news",
                      defaultChecked: true
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Label,
                    {
                      className: "custom-control-label",
                      htmlFor: "notifications-news",
                      children: "Newsletter"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "custom-control custom-checkbox", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      type: "checkbox",
                      className: "custom-control-input",
                      id: "notifications-offers",
                      defaultChecked: true
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Label,
                    {
                      className: "custom-control-label",
                      htmlFor: "notifications-offers",
                      children: "Personal Offers"
                    }
                  )
                ] })
              ] })
            ] }) })
          ] })
        ] })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ModalFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Row, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { className: "d-flex justify-content-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "", className: "btn btn-primary", onClick: toggle2, children: "Save Changes" }) }) }) })
    ] })
  ] });
}
const PeerAssessment = () => {
  const [loading, setLoading2] = reactExports.useState(false);
  const [submitting, setSubmitting] = reactExports.useState(false);
  const [activeTab, setActiveTab] = reactExports.useState("assess");
  const [employees, setEmployees] = reactExports.useState([]);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [selectedPeer, setSelectedPeer] = reactExports.useState(null);
  const [showAssessmentModal, setShowAssessmentModal] = reactExports.useState(false);
  const [myAssessments, setMyAssessments] = reactExports.useState([]);
  const [currentEmployee, setCurrentEmployee] = reactExports.useState(null);
  const [peerCriteria, setPeerCriteria] = reactExports.useState([]);
  const [appraisalConfigs, setAppraisalConfigs] = reactExports.useState([]);
  const [selectedConfig, setSelectedConfig] = reactExports.useState(null);
  const [filteredEmployees, setFilteredEmployees] = reactExports.useState([]);
  const [currentStep, setCurrentStep] = reactExports.useState(0);
  const [assessmentForm, setAssessmentForm] = reactExports.useState({
    ratings: {},
    comments: {},
    generalComment: "",
    progress: 0
  });
  reactExports.useEffect(() => {
    initializeData();
  }, []);
  reactExports.useEffect(() => {
    if (searchTerm.trim() === "") {
      setFilteredEmployees(employees);
    } else {
      const filtered = employees.filter(
        (emp) => {
          var _a2, _b;
          return ((_a2 = emp.staff_name) == null ? void 0 : _a2.toLowerCase().includes(searchTerm.toLowerCase())) || ((_b = emp.job_role) == null ? void 0 : _b.toLowerCase().includes(searchTerm.toLowerCase()));
        }
      );
      setFilteredEmployees(filtered);
    }
  }, [searchTerm, employees]);
  const initializeData = async () => {
    try {
      setLoading2(true);
      const empData = await APIServices2.getCurrentEmployeeData();
      setCurrentEmployee(empData);
      try {
        const criteria = await APIServices2.getAllPcriteria();
        setPeerCriteria(criteria || []);
      } catch (criteriaError) {
        console.warn("Failed to load performance criteria:", criteriaError);
        setPeerCriteria([]);
      }
      try {
        const configs = await APIServices2.getAppraisalConfigurations();
        setAppraisalConfigs(configs || []);
        const activeConfig = (configs == null ? void 0 : configs.find((config2) => config2.status === "active")) || (configs == null ? void 0 : configs[0]);
        setSelectedConfig(activeConfig);
        if (!activeConfig) {
          console.warn("No active appraisal configurations found");
        }
      } catch (configError) {
        console.warn("Failed to load appraisal configurations:", configError);
        setAppraisalConfigs([]);
        setSelectedConfig(null);
        Swal.fire({
          title: "Configuration Warning",
          text: "Unable to load appraisal configurations. You can still view colleagues but assessment submission may be limited.",
          icon: "warning",
          confirmButtonText: "Continue"
        });
      }
      if (empData == null ? void 0 : empData.deptcode) {
        try {
          const departmentEmployees = await APIServices2.getEmployeesByDepartmentForManager();
          const colleagues = (departmentEmployees == null ? void 0 : departmentEmployees.filter(
            (emp) => emp.employeeID !== empData.employeeID && emp.deptcode === empData.deptcode
          )) || [];
          setEmployees(colleagues);
        } catch (employeeError) {
          console.warn("Failed to load department colleagues:", employeeError);
          setEmployees([]);
        }
      }
      setMyAssessments([]);
    } catch (error2) {
      console.error("Error initializing peer assessment data:", error2);
      Swal.fire({
        title: "Error",
        text: "Failed to load peer assessment data. Please check your connection and try again.",
        icon: "error"
      });
    } finally {
      setLoading2(false);
    }
  };
  const handleRatingChange = (criteriaId, rating) => {
    const progressMap = {
      1: 20,
      // Rating 1 = 20%
      2: 40,
      // Rating 2 = 40%
      3: 60,
      // Rating 3 = 60%
      4: 80,
      // Rating 4 = 80%
      5: 100
      // Rating 5 = 100%
    };
    const newProgress = progressMap[rating] || 0;
    setAssessmentForm((prev) => ({
      ...prev,
      ratings: {
        ...prev.ratings,
        [criteriaId]: rating
      },
      progress: newProgress
    }));
  };
  const handleCommentChange = (criteriaId, comment) => {
    setAssessmentForm((prev) => ({
      ...prev,
      comments: {
        ...prev.comments,
        [criteriaId]: comment
      }
    }));
  };
  const startAssessment = (peer) => {
    setSelectedPeer(peer);
    setCurrentStep(0);
    setAssessmentForm({
      ratings: {},
      comments: {},
      generalComment: "",
      progress: 0
    });
    setShowAssessmentModal(true);
  };
  const handleNext = () => {
    if (currentStep < peerCriteria.length - 1) {
      setCurrentStep((prev) => prev + 1);
    }
  };
  const handlePrevious = () => {
    if (currentStep > 0) {
      setCurrentStep((prev) => prev - 1);
    }
  };
  const getCurrentCriteria = () => {
    return peerCriteria[currentStep] || null;
  };
  const submitAssessment = async () => {
    try {
      setSubmitting(true);
      const missingRatings = peerCriteria.filter((criteria) => !assessmentForm.ratings[criteria.sno]);
      if (missingRatings.length > 0) {
        Swal.fire({
          title: "Incomplete Assessment",
          text: "Please provide ratings for all criteria before submitting.",
          icon: "warning"
        });
        return;
      }
      if (!selectedConfig) {
        Swal.fire({
          title: "Configuration Missing",
          text: "No active appraisal configuration found. Please contact your administrator.",
          icon: "error"
        });
        return;
      }
      const ratings = Object.values(assessmentForm.ratings);
      const overallRating = Math.round(ratings.reduce((sum, rating) => sum + rating, 0) / ratings.length);
      const responsesObj = {};
      const commentsObj = {};
      Object.keys(assessmentForm.ratings || {}).forEach((criteriaId) => {
        const criteria = peerCriteria.find((c2) => c2.sno.toString() === criteriaId.toString());
        const criteriaName = (criteria == null ? void 0 : criteria.criteriaName) || `Criterion_${criteriaId}`;
        responsesObj[criteriaName] = assessmentForm.ratings[criteriaId];
        if (assessmentForm.comments && assessmentForm.comments[criteriaId]) {
          commentsObj[criteriaName] = assessmentForm.comments[criteriaId];
        }
      });
      const assessmentData = {
        config_sno: selectedConfig.sno,
        // Backend expects config_sno, not config_id
        employee_id: selectedPeer.employeeID,
        // The person being assessed
        staff_name: selectedPeer.staff_name,
        // Required field
        type: "peer",
        responses: responsesObj,
        // Using criterion names as keys
        comments: commentsObj,
        // Using criterion names as keys
        general_comment: assessmentForm.generalComment || "",
        last_completed_step: peerCriteria.length - 1,
        progress: assessmentForm.progress || 100,
        status: "completed",
        is_anonymous: true,
        assessor_id: (currentEmployee == null ? void 0 : currentEmployee.employeeID) || (currentEmployee == null ? void 0 : currentEmployee.id) || (currentEmployee == null ? void 0 : currentEmployee.sno)
        // Try multiple possible ID fields
      };
      await APIServices2.createPeerAssessment(assessmentData);
      setMyAssessments((prev) => [{
        peer_name: selectedPeer.staff_name,
        department: selectedPeer.department,
        overall_rating: overallRating,
        assessment_date: (/* @__PURE__ */ new Date()).toISOString()
      }, ...prev]);
      setAssessmentForm({
        ratings: {},
        comments: {},
        generalComment: "",
        overallRating: 0
      });
      setShowAssessmentModal(false);
      console.log("Assessment submitted successfully");
      console.log("Current employee data for debugging:", currentEmployee);
      console.log("Assessor ID used:", (currentEmployee == null ? void 0 : currentEmployee.employeeID) || (currentEmployee == null ? void 0 : currentEmployee.id) || (currentEmployee == null ? void 0 : currentEmployee.sno));
      Swal.fire({
        title: "Success!",
        text: "Peer assessment submitted successfully.",
        icon: "success"
      });
    } catch (error2) {
      console.error("Error submitting assessment:", error2);
      Swal.fire({
        title: "Error",
        text: "Failed to submit assessment. Please try again.",
        icon: "error"
      });
    } finally {
      setSubmitting(false);
    }
  };
  const getRatingColor = (rating) => {
    if (rating >= 4.5) return "success";
    if (rating >= 3.5) return "info";
    if (rating >= 2.5) return "warning";
    return "danger";
  };
  const getRatingText = (rating) => {
    if (rating >= 4.5) return "Excellent";
    if (rating >= 3.5) return "Good";
    if (rating >= 2.5) return "Average";
    if (rating >= 1.5) return "Below Average";
    return "Poor";
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "d-flex justify-content-center align-items-center", style: { minHeight: "400px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner-border text-primary", role: "status", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "visually-hidden", children: "Loading..." }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PageHeaders, { title: "Peer Assessment", breadCrumbItems: [
      { label: "Dashboard", path: "/dashboard" },
      { label: "Peer Assessment", active: true }
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container-fluid", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "nav nav-tabs mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            className: `nav-link ${activeTab === "assess" ? "active" : ""}`,
            onClick: () => setActiveTab("assess"),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-users me-2" }),
              "Assess Colleagues"
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            className: `nav-link ${activeTab === "history" ? "active" : ""}`,
            onClick: () => setActiveTab("history"),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-history me-2" }),
              "My Assessments"
            ]
          }
        ) })
      ] }),
      activeTab === "assess" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-header", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h5", { className: "card-title mb-0", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-user-friends me-2" }),
          "Select a Colleague to Assess"
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "input-group-text", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-search" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                className: "form-control",
                placeholder: "Search colleagues by name, department, or role...",
                value: searchTerm,
                onChange: (e2) => setSearchTerm(e2.target.value)
              }
            )
          ] }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: filteredEmployees.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-12 text-center py-5", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-users fa-3x text-muted mb-3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "text-muted", children: "No colleagues found" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted", children: "Try adjusting your search criteria" })
          ] }) : filteredEmployees.map((employee) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6 col-lg-4 mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card h-100 shadow-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body text-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "bg-primary rounded-circle d-inline-flex align-items-center justify-content-center",
                style: { width: "60px", height: "60px" },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-user text-white fa-2x" })
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { className: "card-title", children: employee.staff_name || "Unknown" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "card-text text-muted small mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-briefcase me-1" }),
              employee.job_role || "No role specified"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "card-text text-muted small mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-building me-1" }),
              employee.department || employee.deptname || "No department"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                className: "btn btn-primary btn-sm",
                onClick: () => startAssessment(employee),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-star me-1" }),
                  "Assess"
                ]
              }
            )
          ] }) }) }, employee.id || employee._id)) })
        ] })
      ] }) }) }),
      activeTab === "history" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-header", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h5", { className: "card-title mb-0", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-history me-2" }),
          "My Peer Assessments"
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-body", children: myAssessments.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-clipboard-list fa-3x text-muted mb-3" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "text-muted", children: "No assessments yet" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted", children: 'Start by assessing your colleagues in the "Assess Colleagues" tab' })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-responsive", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "table table-hover", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Colleague" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Department" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Overall Rating" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Assessment Date" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Actions" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: myAssessments.map((assessment, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: assessment.peer_name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: assessment.department }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `badge bg-${getRatingColor(assessment.overall_rating)}`, children: [
              assessment.overall_rating,
              "/5 - ",
              getRatingText(assessment.overall_rating)
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: new Date(assessment.assessment_date).toLocaleDateString() }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "btn btn-sm btn-outline-primary", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-eye" }),
              " View"
            ] }) })
          ] }, index2)) })
        ] }) }) })
      ] }) }) })
    ] }),
    showAssessmentModal && selectedPeer && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal show d-block", tabIndex: "-1", style: { backgroundColor: "rgba(0,0,0,0.5)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-dialog modal-lg modal-dialog-scrollable", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h5", { className: "modal-title", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-star me-2" }),
          "Peer Assessment: ",
          selectedPeer.staff_name
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            className: "btn-close",
            onClick: () => setShowAssessmentModal(false)
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-md-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Name:" }),
              " ",
              selectedPeer.staff_name
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Role:" }),
              " ",
              selectedPeer.job_role
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-md-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Department:" }),
              " ",
              selectedPeer.department || selectedPeer.deptname || "N/A"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Progress:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "badge bg-primary ms-2", children: [
                assessmentForm.progress,
                "%"
              ] })
            ] })
          ] })
        ] }) }),
        peerCriteria.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-info-circle text-muted fa-3x mb-3" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "text-muted", children: "No Criteria Available" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted", children: "No assessment criteria found. Please contact your administrator." })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between align-items-center mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { className: "mb-0", children: "Assessment Progress" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "badge bg-primary", children: [
                assessmentForm.progress,
                "%"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress", style: { height: "10px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "progress-bar",
                role: "progressbar",
                style: { width: `${assessmentForm.progress}%` },
                "aria-valuenow": assessmentForm.progress,
                "aria-valuemin": "0",
                "aria-valuemax": "100"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "small text-muted mt-2", children: [
              "Step ",
              currentStep + 1,
              " of ",
              peerCriteria.length
            ] })
          ] }),
          (() => {
            const currentCriteria = getCurrentCriteria();
            if (!currentCriteria) return null;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-header bg-light", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { className: "mb-1", children: currentCriteria.criteriaName || currentCriteria.question || currentCriteria.name || "Unnamed Criterion" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted mb-0 small", children: currentCriteria.description || currentCriteria.desc || "Evaluate this performance criterion" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-label fw-bold", children: "Rating *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "d-flex gap-2 mb-2", children: [1, 2, 3, 4, 5].map((rating) => {
                    const isSelected2 = assessmentForm.ratings && currentCriteria.sno && assessmentForm.ratings[currentCriteria.sno] === rating;
                    return /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        type: "button",
                        className: `btn ${isSelected2 ? "btn-primary" : "btn-outline-primary"}`,
                        style: { width: "45px", height: "45px" },
                        onClick: () => handleRatingChange(currentCriteria.sno, rating),
                        disabled: submitting,
                        children: rating
                      },
                      rating
                    );
                  }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between small text-muted", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Poor" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Excellent" })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-label fw-bold", children: "Comments" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      className: "form-control",
                      value: assessmentForm.comments[currentCriteria.sno] || "",
                      onChange: (e2) => handleCommentChange(currentCriteria.sno, e2.target.value),
                      placeholder: "Provide specific feedback and examples...",
                      disabled: submitting,
                      rows: 4
                    }
                  )
                ] })
              ] })
            ] });
          })(),
          currentStep === peerCriteria.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { className: "mb-0", children: "General Comments" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-body", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "textarea",
              {
                className: "form-control",
                value: assessmentForm.generalComment,
                onChange: (e2) => setAssessmentForm((prev) => ({ ...prev, generalComment: e2.target.value })),
                placeholder: "Provide any general comments about this peer assessment...",
                disabled: submitting,
                rows: 4
              }
            ) })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-footer", children: peerCriteria.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between align-items-center w-100", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            type: "button",
            className: "btn btn-outline-secondary",
            onClick: handlePrevious,
            disabled: currentStep === 0 || submitting,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-arrow-left me-1" }),
              "Previous"
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn btn-secondary",
              onClick: () => setShowAssessmentModal(false),
              children: "Cancel"
            }
          ),
          currentStep < peerCriteria.length - 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              type: "button",
              className: "btn btn-primary",
              onClick: handleNext,
              disabled: submitting,
              children: [
                "Next",
                /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-arrow-right ms-1" })
              ]
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn btn-success",
              onClick: submitAssessment,
              disabled: submitting || Object.keys(assessmentForm.ratings).length < peerCriteria.length || !selectedConfig,
              children: submitting ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "spinner-border spinner-border-sm me-2", role: "status" }),
                "Submitting..."
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-check me-2" }),
                "Submit Assessment"
              ] })
            }
          )
        ] })
      ] }) })
    ] }) }) })
  ] });
};
const SubordinateAssessment = () => {
  const { configId, managerId, assessmentId } = useParams();
  const navigate = useNavigate();
  const [loading, setLoading2] = reactExports.useState(true);
  const [submitting, setSubmitting] = reactExports.useState(false);
  const [appraisalConfig, setAppraisalConfig] = reactExports.useState(null);
  const [assessment, setAssessment] = reactExports.useState(null);
  const [manager, setManager] = reactExports.useState(null);
  const [currentEmployee, setCurrentEmployee] = reactExports.useState(null);
  const [criteria, setCriteria] = reactExports.useState([]);
  const [currentStep, setCurrentStep] = reactExports.useState(0);
  const [responses, setResponses] = reactExports.useState({});
  const [progress, setProgress] = reactExports.useState(0);
  reactExports.useEffect(() => {
    if (assessmentId) {
      fetchExistingAssessment();
    } else if (configId && managerId) {
      fetchAppraisalConfig();
      fetchManagerData();
      fetchCurrentEmployee();
      fetchAssessmentCriteria();
    } else {
      setLoading2(false);
    }
  }, [configId, managerId, assessmentId]);
  reactExports.useEffect(() => {
    if (criteria.length > 0) {
      const answeredQuestions = Object.keys(responses).filter((key) => !key.includes("_comments")).length;
      const totalQuestions = criteria.length;
      const calculatedProgress = Math.round(answeredQuestions / totalQuestions * 100);
      setProgress(calculatedProgress);
    }
  }, [responses, criteria]);
  const fetchExistingAssessment = async () => {
    try {
      setLoading2(true);
      const result = await APIService.getAssessment(assessmentId);
      setAssessment(result);
      setAppraisalConfig(result.appraisalConfig);
      setManager(result.manager);
      setCurrentEmployee(result.employee);
      setCriteria(result.criteria || []);
      setResponses(result.responses || {});
      setCurrentStep(result.lastCompletedStep || 0);
    } catch (error2) {
      console.error("Error fetching assessment:", error2);
      Swal.fire("Error", "Failed to fetch assessment", "error");
    } finally {
      setLoading2(false);
    }
  };
  const fetchAppraisalConfig = async () => {
    try {
      const config2 = await APIService.getAppraisalConfiguration(configId);
      setAppraisalConfig(config2);
    } catch (error2) {
      console.error("Error fetching appraisal configuration:", error2);
      Swal.fire("Error", "Failed to fetch appraisal configuration", "error");
    }
  };
  const fetchManagerData = async () => {
    try {
      const mgr = await APIService.getManager(managerId);
      setManager(mgr);
    } catch (error2) {
      console.error("Error fetching manager data:", error2);
      Swal.fire("Error", "Failed to fetch manager data", "error");
    }
  };
  const fetchCurrentEmployee = async () => {
    try {
      const emp = await APIService.getCurrentEmployeeData();
      setCurrentEmployee(emp);
    } catch (error2) {
      console.error("Error fetching employee data:", error2);
      Swal.fire("Error", "Failed to fetch employee data", "error");
    }
  };
  const fetchAssessmentCriteria = async () => {
    try {
      const result = await APIService.getAssessmentCriteria("subordinate");
      setCriteria(result || []);
    } catch (error2) {
      console.error("Error fetching assessment criteria:", error2);
      Swal.fire("Error", "Failed to fetch assessment criteria", "error");
    } finally {
      setLoading2(false);
    }
  };
  const handleInputChange = (criteriaId, value) => {
    setResponses((prev) => ({
      ...prev,
      [criteriaId]: value
    }));
  };
  const handleCommentsChange = (criteriaId, comments) => {
    setResponses((prev) => ({
      ...prev,
      [`${criteriaId}_comments`]: comments
    }));
  };
  const handleNext = () => {
    if (currentStep < criteria.length - 1) {
      setCurrentStep((prev) => prev + 1);
    }
  };
  const handlePrevious = () => {
    if (currentStep > 0) {
      setCurrentStep((prev) => prev - 1);
    }
  };
  const saveProgress = async () => {
    try {
      setSubmitting(true);
      const assessmentData = {
        configId,
        employeeId: currentEmployee.employeeID,
        managerId: manager.id,
        type: "subordinate",
        responses,
        lastCompletedStep: currentStep,
        progress,
        status: "in_progress",
        isAnonymous: true
        // Subordinate assessments are typically anonymous
      };
      let result;
      if (assessment) {
        result = await APIService.updateAssessment(assessment.id, assessmentData);
      } else {
        result = await APIService.createAssessment(assessmentData);
      }
      Swal.fire("Success", "Progress saved successfully", "success");
      if (!assessment) {
        setAssessment(result);
      }
      return result;
    } catch (error2) {
      console.error("Error saving progress:", error2);
      Swal.fire("Error", "Failed to save progress", "error");
      return null;
    } finally {
      setSubmitting(false);
    }
  };
  const handleSubmit = async () => {
    const unansweredQuestions = criteria.filter((c2) => !responses[c2.id]);
    if (unansweredQuestions.length > 0) {
      Swal.fire({
        title: "Incomplete Assessment",
        text: `You have ${unansweredQuestions.length} unanswered questions. Do you want to review them before submitting?`,
        icon: "warning",
        showCancelButton: true,
        confirmButtonText: "Review",
        cancelButtonText: "Submit Anyway"
      }).then((result) => {
        if (result.isConfirmed) {
          const firstUnansweredIndex = criteria.findIndex((c2) => !responses[c2.id]);
          setCurrentStep(firstUnansweredIndex);
        } else {
          finalizeSubmission();
        }
      });
    } else {
      finalizeSubmission();
    }
  };
  const finalizeSubmission = async () => {
    try {
      setSubmitting(true);
      const savedAssessment = await saveProgress();
      if (!savedAssessment) {
        return;
      }
      const result = await APIService.submitAssessment(savedAssessment.id);
      Swal.fire({
        title: "Assessment Submitted",
        text: "Your assessment of your manager has been submitted successfully. Your feedback will remain anonymous.",
        icon: "success",
        confirmButtonText: "View All Assessments"
      }).then(() => {
        navigate(`/performance-assessment/${configId}`);
      });
    } catch (error2) {
      console.error("Error submitting assessment:", error2);
      Swal.fire("Error", "Failed to submit assessment", "error");
    } finally {
      setSubmitting(false);
    }
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "d-flex justify-content-center align-items-center", style: { height: "300px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { color: "primary" }) });
  }
  if (!configId && !assessmentId) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container-fluid mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardBody, { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No assessment selected" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Please select an appraisal configuration to start a subordinate assessment." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "primary", onClick: () => navigate("/appraisal-configurations"), children: "View Configurations" })
    ] }) }) });
  }
  if (!appraisalConfig || !manager || !currentEmployee) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container-fluid mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardBody, { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Error Loading Data" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Could not load the required data for this assessment." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "primary", onClick: () => navigate(-1), children: "Go Back" })
    ] }) }) });
  }
  const currentCriteria = criteria[currentStep];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container-fluid mt-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4", children: "Subordinate Assessment" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "bg-warning text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "mb-0", children: [
        appraisalConfig.title,
        " - Manager Assessment"
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardBody, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { color: "info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Confidentiality Notice:" }),
          " Your responses will be kept anonymous. Your manager will not know who provided this feedback."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Col, { md: 6, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Manager:" }),
              " ",
              manager.staff_name
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Job Role:" }),
              " ",
              manager.job_role
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Col, { md: 6, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Department:" }),
              " ",
              manager.department
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Period:" }),
              " ",
              new Date(appraisalConfig.startDate).toLocaleDateString(),
              " - ",
              new Date(appraisalConfig.endDate).toLocaleDateString()
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between mb-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Progress" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              progress,
              "%"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Progress$1, { value: progress, className: "mb-3" })
        ] })
      ] })
    ] }),
    criteria.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { color: "warning", children: "No assessment criteria found. Please contact your administrator." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between align-items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h5", { className: "mb-0", children: [
          "Question ",
          currentStep + 1,
          " of ",
          criteria.length
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: (assessment == null ? void 0 : assessment.status) === "completed" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { color: "success", children: "Completed" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            color: "success",
            size: "sm",
            onClick: saveProgress,
            disabled: submitting,
            children: submitting ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "sm" }) : "Save Progress"
          }
        ) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardBody, { children: [
        currentCriteria && /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { className: "h5", children: currentCriteria.question }),
          currentCriteria.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted", children: currentCriteria.description }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: "Your Rating" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex flex-column flex-md-row justify-content-between mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-check form-check-inline", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    type: "radio",
                    name: `rating_${currentCriteria.id}`,
                    id: `rating_${currentCriteria.id}_1`,
                    value: "1",
                    checked: responses[currentCriteria.id] === "1",
                    onChange: () => handleInputChange(currentCriteria.id, "1"),
                    disabled: (assessment == null ? void 0 : assessment.status) === "completed"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { className: "form-check-label", for: `rating_${currentCriteria.id}_1`, children: "1 - Poor" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-check form-check-inline", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    type: "radio",
                    name: `rating_${currentCriteria.id}`,
                    id: `rating_${currentCriteria.id}_2`,
                    value: "2",
                    checked: responses[currentCriteria.id] === "2",
                    onChange: () => handleInputChange(currentCriteria.id, "2"),
                    disabled: (assessment == null ? void 0 : assessment.status) === "completed"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { className: "form-check-label", for: `rating_${currentCriteria.id}_2`, children: "2 - Below Expectations" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-check form-check-inline", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    type: "radio",
                    name: `rating_${currentCriteria.id}`,
                    id: `rating_${currentCriteria.id}_3`,
                    value: "3",
                    checked: responses[currentCriteria.id] === "3",
                    onChange: () => handleInputChange(currentCriteria.id, "3"),
                    disabled: (assessment == null ? void 0 : assessment.status) === "completed"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { className: "form-check-label", for: `rating_${currentCriteria.id}_3`, children: "3 - Meets Expectations" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-check form-check-inline", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    type: "radio",
                    name: `rating_${currentCriteria.id}`,
                    id: `rating_${currentCriteria.id}_4`,
                    value: "4",
                    checked: responses[currentCriteria.id] === "4",
                    onChange: () => handleInputChange(currentCriteria.id, "4"),
                    disabled: (assessment == null ? void 0 : assessment.status) === "completed"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { className: "form-check-label", for: `rating_${currentCriteria.id}_4`, children: "4 - Exceeds Expectations" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-check form-check-inline", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    type: "radio",
                    name: `rating_${currentCriteria.id}`,
                    id: `rating_${currentCriteria.id}_5`,
                    value: "5",
                    checked: responses[currentCriteria.id] === "5",
                    onChange: () => handleInputChange(currentCriteria.id, "5"),
                    disabled: (assessment == null ? void 0 : assessment.status) === "completed"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { className: "form-check-label", for: `rating_${currentCriteria.id}_5`, children: "5 - Outstanding" })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { for: `comments_${currentCriteria.id}`, children: "Comments" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                type: "textarea",
                id: `comments_${currentCriteria.id}`,
                name: `comments_${currentCriteria.id}`,
                value: responses[`${currentCriteria.id}_comments`] || "",
                onChange: (e2) => handleCommentsChange(currentCriteria.id, e2.target.value),
                placeholder: "Provide any additional comments or examples...",
                rows: "4",
                disabled: (assessment == null ? void 0 : assessment.status) === "completed"
              }
            )
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between mt-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              color: "secondary",
              onClick: handlePrevious,
              disabled: currentStep === 0,
              children: "Previous"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: currentStep < criteria.length - 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              color: "primary",
              onClick: handleNext,
              children: "Next"
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              color: "success",
              onClick: handleSubmit,
              disabled: submitting || (assessment == null ? void 0 : assessment.status) === "completed",
              children: submitting ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "sm" }) : "Submit Assessment"
            }
          ) })
        ] })
      ] })
    ] })
  ] });
};
const EmployeeSelector = () => {
  const { configId, assessmentType } = useParams();
  const navigate = useNavigate();
  const [loading, setLoading2] = reactExports.useState(true);
  const [employees, setEmployees] = reactExports.useState([]);
  const [filteredEmployees, setFilteredEmployees] = reactExports.useState([]);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [appraisalConfig, setAppraisalConfig] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (configId) {
      fetchAppraisalConfig();
      fetchEmployees();
    } else {
      setLoading2(false);
    }
  }, [configId]);
  reactExports.useEffect(() => {
    if (employees.length > 0) {
      const filtered = employees.filter(
        (emp) => emp.staff_name.toLowerCase().includes(searchTerm.toLowerCase()) || emp.job_role.toLowerCase().includes(searchTerm.toLowerCase()) || emp.department && emp.department.toLowerCase().includes(searchTerm.toLowerCase())
      );
      setFilteredEmployees(filtered);
    }
  }, [searchTerm, employees]);
  const fetchAppraisalConfig = async () => {
    try {
      const config2 = await APIService.getAppraisalConfiguration(configId);
      setAppraisalConfig(config2);
    } catch (error2) {
      console.error("Error fetching appraisal configuration:", error2);
      Swal.fire("Error", "Failed to fetch appraisal configuration", "error");
    }
  };
  const fetchEmployees = async () => {
    try {
      setLoading2(true);
      let result = [];
      if (assessmentType === "manager") {
        result = await APIService.getSubordinates();
      } else if (assessmentType === "peer") {
        result = await APIService.getPeers();
      } else if (assessmentType === "subordinate") {
        result = await APIService.getManagers();
      }
      setEmployees(result || []);
      setFilteredEmployees(result || []);
    } catch (error2) {
      console.error("Error fetching employees:", error2);
      Swal.fire("Error", "Failed to fetch employees", "error");
    } finally {
      setLoading2(false);
    }
  };
  const selectEmployee = (employeeId) => {
    if (assessmentType === "manager") {
      navigate(`/assessment/${configId}/manager/${employeeId}`);
    } else if (assessmentType === "peer") {
      navigate(`/assessment/${configId}/peer/${employeeId}`);
    } else if (assessmentType === "subordinate") {
      navigate(`/assessment/${configId}/subordinate/${employeeId}`);
    }
  };
  const getTitle2 = () => {
    switch (assessmentType) {
      case "manager":
        return "Select Team Member to Assess";
      case "peer":
        return "Select Peer to Assess";
      case "subordinate":
        return "Select Manager to Assess";
      default:
        return "Select Employee";
    }
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "d-flex justify-content-center align-items-center", style: { height: "300px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { color: "primary" }) });
  }
  if (!configId || !assessmentType) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container-fluid mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardBody, { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Invalid Selection" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Please return to the assessment page and try again." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "primary", onClick: () => navigate("/performance-assessment"), children: "Back to Assessments" })
    ] }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container-fluid mt-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4", children: getTitle2() }),
    appraisalConfig && /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "bg-primary text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "mb-0", children: appraisalConfig.title }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardBody, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: appraisalConfig.description }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Period:" }),
          " ",
          new Date(appraisalConfig.startDate).toLocaleDateString(),
          " - ",
          new Date(appraisalConfig.endDate).toLocaleDateString()
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between align-items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "mb-0", children: "Available Employees" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              type: "text",
              placeholder: "Search employees...",
              value: searchTerm,
              onChange: (e2) => setSearchTerm(e2.target.value),
              className: "me-2",
              style: { maxWidth: "300px" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              color: "secondary",
              onClick: () => navigate(`/performance-assessment/${configId}`),
              children: "Back"
            }
          )
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardBody, { children: filteredEmployees.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { color: "info", children: [
        "No employees found. ",
        searchTerm ? "Try a different search term." : ""
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-responsive", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { striped: true, bordered: true, hover: true, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Job Role" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Department" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Actions" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: filteredEmployees.map((employee) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: employee.staff_name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: employee.job_role }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: employee.department }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              color: "primary",
              size: "sm",
              onClick: () => selectEmployee(employee.employeeID),
              children: "Select"
            }
          ) })
        ] }, employee.employeeID)) })
      ] }) }) })
    ] })
  ] });
};
const normalizeEmployeeData = (employee) => {
  if (!employee) return null;
  return {
    id: employee.id || employee.employeeID || employee.employee_id,
    name: employee.name || employee.staff_name || employee.fullName || "Unknown",
    ...employee
  };
};
const AssessmentSelection = () => {
  const navigate = useNavigate();
  const [loading, setLoading2] = reactExports.useState(true);
  const [error2, setError] = reactExports.useState(null);
  const [appraisalConfigs, setAppraisalConfigs] = reactExports.useState([]);
  const [employees, setEmployees] = reactExports.useState([]);
  const [selectedConfigId, setSelectedConfigId] = reactExports.useState("");
  const [selectedEmployee, setSelectedEmployee] = reactExports.useState("");
  const handleError2 = (err, context) => {
    var _a2, _b;
    const errorMessage = ((_b = (_a2 = err.response) == null ? void 0 : _a2.data) == null ? void 0 : _b.detail) || err.message || "An unexpected error occurred.";
    setError(`Error in ${context}: ${errorMessage}`);
    Swal.fire("Error", `Could not load data for ${context}. Please try again later.`, "error");
  };
  reactExports.useEffect(() => {
    const loadConfigs = async () => {
      try {
        setLoading2(true);
        const response = await APIServices2.getAppraisalConfigs();
        const managerAssessments = (response.configurations || []).filter((c2) => c2.include_manager_assessment);
        setAppraisalConfigs(managerAssessments);
      } catch (err) {
        handleError2(err, "loading configurations");
      } finally {
        setLoading2(false);
      }
    };
    loadConfigs();
  }, []);
  reactExports.useEffect(() => {
    if (!selectedConfigId) {
      setEmployees([]);
      return;
    }
    const loadEmployees = async () => {
      var _a2;
      try {
        setLoading2(true);
        const selectedConfig = appraisalConfigs.find((c2) => c2.sno.toString() === selectedConfigId);
        if (((_a2 = selectedConfig == null ? void 0 : selectedConfig.employees) == null ? void 0 : _a2.length) > 0) {
          const employeePromises = selectedConfig.employees.map((id) => APIServices2.getEmployeeById(id));
          const fetchedEmployees = await Promise.all(employeePromises);
          const normalized = fetchedEmployees.filter(Boolean).map(normalizeEmployeeData);
          setEmployees(normalized);
        } else {
          setEmployees([]);
        }
      } catch (err) {
        handleError2(err, "loading employees");
      } finally {
        setLoading2(false);
      }
    };
    loadEmployees();
  }, [selectedConfigId, appraisalConfigs]);
  const handleStartAssessment = () => {
    if (selectedConfigId && selectedEmployee) {
      navigate(`/assessment/${selectedConfigId}/manager/${selectedEmployee}`);
    } else {
      Swal.fire("Selection Missing", "Please select both an assessment type and an employee.", "warning");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container-fluid mt-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4", children: "Manager Assessment Portal" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "bg-primary text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "mb-0", children: "Start a New Assessment" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardBody, { children: [
        error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { color: "danger", children: error2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { for: "configSelect", children: "Select Assessment Type" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Input,
                {
                  type: "select",
                  id: "configSelect",
                  value: selectedConfigId,
                  onChange: (e2) => {
                    setSelectedConfigId(e2.target.value);
                    setSelectedEmployee("");
                  },
                  disabled: loading || appraisalConfigs.length === 0,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "-- Select Assessment Type --" }),
                    appraisalConfigs.map((config2) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: config2.sno, children: config2.title }, config2.sno))
                  ]
                }
              )
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { for: "employeeSelect", children: "Select Employee" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Input,
                {
                  type: "select",
                  id: "employeeSelect",
                  value: selectedEmployee,
                  onChange: (e2) => setSelectedEmployee(e2.target.value),
                  disabled: loading || !selectedConfigId || employees.length === 0,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "-- Select an Employee --" }),
                    employees.map((emp) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: emp.id, children: emp.name }, emp.id))
                  ]
                }
              )
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "success", onClick: handleStartAssessment, disabled: loading || !selectedEmployee, children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "sm" }) : "Start Assessment" })
        ] })
      ] })
    ] })
  ] });
};
const App = reactExports.lazy(() => __vitePreload(() => import("./App-Bke1WHj_.js"), true ? __vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]) : void 0));
const Custompages = reactExports.lazy(() => __vitePreload(() => import("./custompages-O_0tnQcQ.js"), true ? __vite__mapDeps([18,1,2,4,3,17]) : void 0));
const Switcherapp = reactExports.lazy(() => __vitePreload(() => import("./Switcherapp-Bp-VLfph.js"), true ? __vite__mapDeps([19,1,2,4,6,3,7,8,9,10,11,12,13,14,15,16,17]) : void 0));
const Dashboard = reactExports.lazy(() => __vitePreload(() => import("./Dashboard01-9Ho2UgJB.js"), true ? __vite__mapDeps([20,1,2,21,22,23,24,25,26,27,28,13,29,3,17]) : void 0));
const Dashboard2 = reactExports.lazy(() => __vitePreload(() => import("./Dashboard02-DjSDvjG8.js"), true ? __vite__mapDeps([30,1,2,29,13,31,32,22,26,28,33,27,24,34,35,36,37,25,38,23,39,40,41,7,17]) : void 0));
const Dashboard3 = reactExports.lazy(() => __vitePreload(() => import("./Dashboard03-5Jg2HVOO.js"), true ? __vite__mapDeps([42,1,2,28,26,27,40,36,25,33,13,43,32,22,24,34,35,37,38,23,39,41,7,3,17]) : void 0));
const Dashboard4 = reactExports.lazy(() => __vitePreload(() => import("./Dashboard04-yK2LdAZm.js"), true ? __vite__mapDeps([44,1,2,13,31,43,22,28,27,33,24,34,26,35,23,25,17]) : void 0));
const Dashboard5 = reactExports.lazy(() => __vitePreload(() => import("./Dashboard05-i2LEqSF5.js"), true ? __vite__mapDeps([45,1,2,46,47,48,49,50,43,51,22,52,53,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Chat-qG7L5VDN.js"), true ? __vite__mapDeps([54,1,2,3,24,26,35,33,37,34,7,48,49,50,13,55,51,56,57,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Chat02-CVrgYvRI.js"), true ? __vite__mapDeps([58,1,2,3,23,26,40,36,33,38,39,35,28,24,34,7,41,48,50,56,57,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Chat03-DNHcGuEq.js"), true ? __vite__mapDeps([59,1,2,13,31,56,57,28,26,33,27,24,34,37,25,38,23,7,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Contactlist-vvuqguzm.js"), true ? __vite__mapDeps([60,1,2,35,28,26,33,27,24,34,36,37,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Contactlist02-t1vDNlNk.js"), true ? __vite__mapDeps([61,1,2,7,23,28,33,27,24,34,35,36,3,43,8,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./FileManager-BLCn_TQF.js"), true ? __vite__mapDeps([62,1,2,63,64,22,65,66,13,55,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./FileManager02-McxPiKnb.js"), true ? __vite__mapDeps([67,1,2,63,64,22,66,65,55,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./FileDetails-DfCSmw90.js"), true ? __vite__mapDeps([68,1,2,52,53,66,69,70,71,72,73,74,75,76,77,78,79,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./FileAttachments-Bt9SmKI3.js"), true ? __vite__mapDeps([80,1,2,79,66,81,70,82,63,43,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Todolist-BA-cYKuK.js"), true ? __vite__mapDeps([83,1,2,48,49,50,13,28,26,33,27,24,34,35,36,37,25,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./TodoList03-g58fDHj7.js"), true ? __vite__mapDeps([84,1,2,48,49,50,13,82,63,65,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./TodoList02-BCuE01T6.js"), true ? __vite__mapDeps([85,1,2,48,49,50,13,31,28,26,33,27,24,34,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./UserList01-DsDqFqu3.js"), true ? __vite__mapDeps([86,1,2,26,28,33,27,24,34,35,36,37,25,38,23,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./UserList02-CSP6F03B.js"), true ? __vite__mapDeps([87,1,2,88,35,34,24,28,36,33,27,37,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./UserList03-D6IKJVw8.js"), true ? __vite__mapDeps([89,1,2,13,31,88,35,34,24,28,36,33,27,37,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./UserList04-SyNz30ke.js"), true ? __vite__mapDeps([90,1,2,13,31,88,35,34,24,28,36,33,27,37,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./LeafletMaps-DBA3XJE3.js"), true ? __vite__mapDeps([91,1,2,43,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./SimpleMaps-DzKND3GF.js"), true ? __vite__mapDeps([92,1,2,43,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Calendar-BbrtElYa.js"), true ? __vite__mapDeps([93,1,2,43,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Pagesessiontimeout-n-qF9b0z.js"), true ? __vite__mapDeps([94,1,2,43,16,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Notifications-BRFA7Jhq.js"), true ? __vite__mapDeps([95,1,2,43,96,57,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./ImageCrop-BkO2SwMH.js"), true ? __vite__mapDeps([97,1,2,43,98,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Rating-OTcfcBVt.js"), true ? __vite__mapDeps([99,1,2,100,43,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./TimeLine-XvOYBw4o.js"), true ? __vite__mapDeps([101,1,2,23,26,37,27,7,70,81,71,48,49,50,13,43,55,56,57,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Loaders-PSZJAhty.js"), true ? __vite__mapDeps([102,1,2,43,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Counters-C1wZEy6c.js"), true ? __vite__mapDeps([103,1,2,73,74,75,43,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Sweetalerts-BFSsVcNi.js"), true ? __vite__mapDeps([104,1,2,16,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Rangeslider-Ur0WuwIw.js"), true ? __vite__mapDeps([105,1,2,43,17]) : void 0));
reactExports.lazy(() => __vitePreload(() => import("./Widgets-CNa6iYuM.js"), true ? __vite__mapDeps([106,1,2,31,43,28,7,33,66,81,70,71,17]) : void 0));
const ChartWidgets = reactExports.lazy(() => __vitePreload(() => import("./ChartWidgets-1zxDwvuc.js"), true ? __vite__mapDeps([107,1,2,22,46,17]) : void 0));
const FormElements = reactExports.lazy(() => __vitePreload(() => import("./FormElements-DdQcMAO1.js"), true ? __vite__mapDeps([108,1,2,48,49,50,13,43,55,51,47,17]) : void 0));
const AdvancedForms = reactExports.lazy(() => __vitePreload(() => import("./AdvancedForms-iQiUd9uS.js"), true ? __vite__mapDeps([109,1,2,43,47,110,111,112,17,113]) : void 0));
const FormWizard = reactExports.lazy(() => __vitePreload(() => import("./FormWizard-C5XoqR43.js"), true ? __vite__mapDeps([114,1,2,43,115,17]) : void 0));
const FormEdit = reactExports.lazy(() => __vitePreload(() => import("./FormEdit-CxvpxzQo.js"), true ? __vite__mapDeps([116,1,2,43,17]) : void 0));
const FormElementSizes = reactExports.lazy(() => __vitePreload(() => import("./FormElementSizes-UKUAvAeD.js"), true ? __vite__mapDeps([117,1,2,43,17]) : void 0));
const FormTreeView = reactExports.lazy(() => __vitePreload(() => import("./FormTreeView-DBk5i2uN.js"), true ? __vite__mapDeps([118,1,2,100,17]) : void 0));
const Area = reactExports.lazy(() => __vitePreload(() => import("./Area-1LYzaRnR.js"), true ? __vite__mapDeps([119,1,2,120,22,43,17]) : void 0));
const Bar = reactExports.lazy(() => __vitePreload(() => import("./Bar-CMX6ssyb.js"), true ? __vite__mapDeps([121,1,2,43,120,22,17]) : void 0));
const Column = reactExports.lazy(() => __vitePreload(() => import("./Column-DJ6gDcxD.js"), true ? __vite__mapDeps([122,1,2,43,120,22,17]) : void 0));
const Line = reactExports.lazy(() => __vitePreload(() => import("./Line-Brx_GrIW.js"), true ? __vite__mapDeps([123,1,2,43,120,22,17]) : void 0));
const Mixed = reactExports.lazy(() => __vitePreload(() => import("./Mixed-Ka_89bxq.js"), true ? __vite__mapDeps([124,1,2,43,120,22,17]) : void 0));
const Echart = reactExports.lazy(() => __vitePreload(() => import("./Echart-CWFa80g4.js"), true ? __vite__mapDeps([125,1,2,43,17]) : void 0));
const Chartjs = reactExports.lazy(() => __vitePreload(() => import("./Chartjs-BioxNYB_.js"), true ? __vite__mapDeps([126,1,2,43,46,17]) : void 0));
const Defaulttable = reactExports.lazy(() => __vitePreload(() => import("./Defaulttable-Bbs754DI.js"), true ? __vite__mapDeps([127,1,2,17]) : void 0));
const DataTable = reactExports.lazy(() => __vitePreload(() => import("./DataTable-D7cmPjb1.js"), true ? __vite__mapDeps([128,1,2,43,21,129,130,17]) : void 0));
const Accordion = reactExports.lazy(() => __vitePreload(() => import("./Accordion-C6Kjk0g0.js"), true ? __vite__mapDeps([131,1,2,132,14,17]) : void 0));
const Alerts = reactExports.lazy(() => __vitePreload(() => import("./Alerts-BrJIpmEL.js"), true ? __vite__mapDeps([133,1,2,48,49,50,43,96,57,51,17]) : void 0));
const Avatars = reactExports.lazy(() => __vitePreload(() => import("./Avatars-DfUe3EOz.js"), true ? __vite__mapDeps([134,1,2,28,38,25,26,33,27,24,34,35,36,37,41,39,7,40,23,43,17]) : void 0));
const Badges = reactExports.lazy(() => __vitePreload(() => import("./Badges-Bk-wGwLa.js"), true ? __vite__mapDeps([135,1,2,43,17]) : void 0));
const Breadcrumb = reactExports.lazy(() => __vitePreload(() => import("./Breadcrumd-B6Jf-6q7.js"), true ? __vite__mapDeps([136,1,2,43,17]) : void 0));
const Button = reactExports.lazy(() => __vitePreload(() => import("./Button-BqifmvQ_.js"), true ? __vite__mapDeps([137,1,2,13,43,17]) : void 0));
const Cards = reactExports.lazy(() => __vitePreload(() => import("./Cards-5YQA1Ey8.js"), true ? __vite__mapDeps([138,1,2,48,49,50,31,43,55,75,17]) : void 0));
const CardImages = reactExports.lazy(() => __vitePreload(() => import("./CardImages-DeWiPL7b.js"), true ? __vite__mapDeps([139,1,2,81,140,66,71,73,75,76,69,141,31,43,7,25,17]) : void 0));
const Carousel = reactExports.lazy(() => __vitePreload(() => import("./Carousel-DIDk20IJ.js"), true ? __vite__mapDeps([142,1,2,98,140,66,81,70,71,72,73,69,141,143,76,74,75,43,17]) : void 0));
const Dropdown = reactExports.lazy(() => __vitePreload(() => import("./Dropdown-BNe4mJoH.js"), true ? __vite__mapDeps([144,1,2,13,43,17]) : void 0));
const Footers = reactExports.lazy(() => __vitePreload(() => import("./Footers-CRqgSi2C.js"), true ? __vite__mapDeps([145,1,2,43,17]) : void 0));
const Header = reactExports.lazy(() => __vitePreload(() => import("./Header-DlG5HaFB.js"), true ? __vite__mapDeps([146,1,2,13,43,27,28,36,7,15,16,17]) : void 0));
const List = reactExports.lazy(() => __vitePreload(() => import("./List-XLpyRiOi.js"), true ? __vite__mapDeps([147,1,2,43,17]) : void 0));
const MediaObject = reactExports.lazy(() => __vitePreload(() => import("./MediaObject-WVJOQLUb.js"), true ? __vite__mapDeps([148,1,2,43,27,37,36,38,23,26,17]) : void 0));
const Modal = reactExports.lazy(() => __vitePreload(() => import("./Modal-s-fu73HS.js"), true ? __vite__mapDeps([149,1,2,47,43,56,57,17]) : void 0));
const Navigation = reactExports.lazy(() => __vitePreload(() => import("./Navigation-DRuVQxjt.js"), true ? __vite__mapDeps([150,1,2,48,49,50,13,43,17]) : void 0));
const Pagination = reactExports.lazy(() => __vitePreload(() => import("./Pagination-CVo6lEpN.js"), true ? __vite__mapDeps([151,1,2,48,43,17]) : void 0));
const Panel = reactExports.lazy(() => __vitePreload(() => import("./Panel-D1e6ERCh.js"), true ? __vite__mapDeps([152,1,2,43,17]) : void 0));
const Tooltips = reactExports.lazy(() => __vitePreload(() => import("./Tooltips-AIpXD13A.js"), true ? __vite__mapDeps([153,1,2,43,56,57,17]) : void 0));
const Tags = reactExports.lazy(() => __vitePreload(() => import("./Tags-MoJib5vo.js"), true ? __vite__mapDeps([154,1,2,34,40,28,27,37,23,35,38,43,17]) : void 0));
const Tabs = reactExports.lazy(() => __vitePreload(() => import("./Tabs-vfpgC5zH.js"), true ? __vite__mapDeps([155,1,2,48,49,50,43,51,17]) : void 0));
const Popover = reactExports.lazy(() => __vitePreload(() => import("./Popover-Bwu7rb44.js"), true ? __vite__mapDeps([156,1,2,43,96,57,17]) : void 0));
const Progress = reactExports.lazy(() => __vitePreload(() => import("./Progress-1wMRX1AP.js"), true ? __vite__mapDeps([157,1,2,43,17]) : void 0));
const FontAwesome = reactExports.lazy(() => __vitePreload(() => import("./FontAwesome-lQ7E2lcx.js"), true ? __vite__mapDeps([158,1,2,43,56,57,17]) : void 0));
const SimpleLineIcons = reactExports.lazy(() => __vitePreload(() => import("./SimpleLineIcons-BvNn3MhG.js"), true ? __vite__mapDeps([159,1,2,43,56,57,17]) : void 0));
const MaterialDesignIcons = reactExports.lazy(() => __vitePreload(() => import("./MaterialDesignIcons-B6jYqD4Z.js"), true ? __vite__mapDeps([160,1,2,56,57,17]) : void 0));
const FeatherIcons = reactExports.lazy(() => __vitePreload(() => import("./FeatherIcons-CMZY7BCf.js"), true ? __vite__mapDeps([161,1,2,43,56,57,17]) : void 0));
const ThemifyIcons = reactExports.lazy(() => __vitePreload(() => import("./ThemifyIcons-Br4G9nqe.js"), true ? __vite__mapDeps([162,1,2,43,56,57,17]) : void 0));
const Pe7Icons = reactExports.lazy(() => __vitePreload(() => import("./Pe7Icons-Vb99_KT5.js"), true ? __vite__mapDeps([163,1,2,43,56,57,17]) : void 0));
const FlagIcons = reactExports.lazy(() => __vitePreload(() => import("./FlagIcons-BafXhNRA.js"), true ? __vite__mapDeps([164,1,2,43,56,57,17]) : void 0));
const IonicIcons = reactExports.lazy(() => __vitePreload(() => import("./IonicIcons-CKMBE09d.js"), true ? __vite__mapDeps([165,1,2,43,56,57,17]) : void 0));
const Bootstrap5SVGIcons = reactExports.lazy(() => __vitePreload(() => import("./Bootstrap5SVGIcons-jG0N7kqr.js"), true ? __vite__mapDeps([166,1,2,43,17]) : void 0));
const MaterialIcons = reactExports.lazy(() => __vitePreload(() => import("./MaterialIcons-Cz-go8ss.js"), true ? __vite__mapDeps([167,1,2,43,17]) : void 0));
const WeatherIcons = reactExports.lazy(() => __vitePreload(() => import("./WeatherIcons-DMay-gQT.js"), true ? __vite__mapDeps([168,1,2,43,56,57,17]) : void 0));
const Profile01 = reactExports.lazy(() => __vitePreload(() => import("./Profile01-F613ldXv.js"), true ? __vite__mapDeps([169,1,2,31,43,56,57,7,17]) : void 0));
const Profile03 = reactExports.lazy(() => __vitePreload(() => import("./Profile03-BsnwF9K5.js"), true ? __vite__mapDeps([170,1,2,23,26,37,27,7,81,70,71,13,43,56,57,17]) : void 0));
const Profile02 = reactExports.lazy(() => __vitePreload(() => import("./Profile02-Ct4EyFiy.js"), true ? __vite__mapDeps([171,1,2,7,66,81,70,35,34,24,28,36,33,27,37,48,49,50,51,17]) : void 0));
const AboutUs = reactExports.lazy(() => __vitePreload(() => import("./AboutUs-9uSs23rs.js"), true ? __vite__mapDeps([172,1,2,28,26,33,27,17]) : void 0));
const EditProfile = reactExports.lazy(() => __vitePreload(() => import("./EditProfile-e2_F8gmW.js"), true ? __vite__mapDeps([173,1,2,31,43,7,47,17]) : void 0));
const Settings = reactExports.lazy(() => __vitePreload(() => import("./Settings-BKpApWJJ.js"), true ? __vite__mapDeps([174,1,2,31,43,55,17]) : void 0));
const EmailCompose = reactExports.lazy(() => __vitePreload(() => import("./EmailCompose-B0gtm9CP.js"), true ? __vite__mapDeps([175,1,2,31,43,55,56,57,17]) : void 0));
const EmailInbox = reactExports.lazy(() => __vitePreload(() => import("./EmailInbox-CosMFTYz.js"), true ? __vite__mapDeps([176,1,2,13,55,56,57,17]) : void 0));
const EmailRead = reactExports.lazy(() => __vitePreload(() => import("./EmailRead-DaunGyl9.js"), true ? __vite__mapDeps([177,1,2,26,82,13,31,43,55,56,57,17]) : void 0));
const Pricing03 = reactExports.lazy(() => __vitePreload(() => import("./Pricing03-x9as3b2k.js"), true ? __vite__mapDeps([178,1,2,48,49,50,55,51,17]) : void 0));
const Pricing02 = reactExports.lazy(() => __vitePreload(() => import("./Pricing02-C7D9voBK.js"), true ? __vite__mapDeps([179,1,2,55,17]) : void 0));
const Pricing01 = reactExports.lazy(() => __vitePreload(() => import("./Pricing01-7knmcG2e.js"), true ? __vite__mapDeps([180,1,2,17]) : void 0));
const Invoicelist = reactExports.lazy(() => __vitePreload(() => import("./Invoicelist-BshR6w5P.js"), true ? __vite__mapDeps([181,1,2,63,13,17]) : void 0));
const Invoice01 = reactExports.lazy(() => __vitePreload(() => import("./Invoice01-CmJshT2b.js"), true ? __vite__mapDeps([182,1,2,17]) : void 0));
const Invoice02 = reactExports.lazy(() => __vitePreload(() => import("./Invoice02-CDGXeSTd.js"), true ? __vite__mapDeps([183,1,2,17]) : void 0));
const Invoice03 = reactExports.lazy(() => __vitePreload(() => import("./Invoice03-D4JTgMwV.js"), true ? __vite__mapDeps([184,1,2,63,17]) : void 0));
const AddInvoice = reactExports.lazy(() => __vitePreload(() => import("./AddInvoice-BxIWEjSo.js"), true ? __vite__mapDeps([185,1,2,31,43,17]) : void 0));
const EditInvoice = reactExports.lazy(() => __vitePreload(() => import("./EditInvoice-M2-HsbTM.js"), true ? __vite__mapDeps([186,1,2,31,43,17]) : void 0));
const BlogPost = reactExports.lazy(() => __vitePreload(() => import("./BlogPost-DJ7xxp5b.js"), true ? __vite__mapDeps([187,1,2,110,31,47,111,112,130,17,188]) : void 0));
const BlogStyles = reactExports.lazy(() => __vitePreload(() => import("./BlogStyles-Cp-HAxdG.js"), true ? __vite__mapDeps([189,1,2,7,40,72,34,73,81,23,33,143,41,141,69,74,75,17]) : void 0));
const Blog03 = reactExports.lazy(() => __vitePreload(() => import("./Blog03-C_dZUUtq.js"), true ? __vite__mapDeps([190,1,2,23,37,26,28,33,43,17]) : void 0));
const Blog01 = reactExports.lazy(() => __vitePreload(() => import("./Blog01-BZPjXBir.js"), true ? __vite__mapDeps([191,1,2,7,192,66,81,70,71,72,73,74,17]) : void 0));
const Blog02 = reactExports.lazy(() => __vitePreload(() => import("./Blog02-B4S4et5Y.js"), true ? __vite__mapDeps([193,1,2,7,23,26,37,13,192,66,81,70,71,72,73,74,17]) : void 0));
const Wishlist = reactExports.lazy(() => __vitePreload(() => import("./Wishlist-rVJfQRq4.js"), true ? __vite__mapDeps([194,1,2,31,43,195,9,10,11,12,17]) : void 0));
const Checkout = reactExports.lazy(() => __vitePreload(() => import("./Checkout-DxQx1Mgq.js"), true ? __vite__mapDeps([196,1,2,47,48,49,50,43,51,11,12,17]) : void 0));
const ShoppingCart = reactExports.lazy(() => __vitePreload(() => import("./ShoppingCart-BRIp9sux.js"), true ? __vite__mapDeps([197,1,2,43,56,57,195,10,11,17]) : void 0));
const ProductDetails = reactExports.lazy(() => __vitePreload(() => import("./ProductDetails-CzFHUgoi.js"), true ? __vite__mapDeps([198,1,2,9,10,11,12,31,43,195,17]) : void 0));
const Products = reactExports.lazy(() => __vitePreload(() => import("./Products-DfzfrGsA.js"), true ? __vite__mapDeps([199,1,2,43,195,9,10,11,12,47,17]) : void 0));
const Gallery = reactExports.lazy(() => __vitePreload(() => import("./Gallery-BvhlppYj.js"), true ? __vite__mapDeps([200,1,2,77,78,66,69,70,71,72,73,74,75,76,17]) : void 0));
const FAQS = reactExports.lazy(() => __vitePreload(() => import("./FAQS-DvCzU1dW.js"), true ? __vite__mapDeps([201,1,2,132,14,43,17]) : void 0));
const Terms = reactExports.lazy(() => __vitePreload(() => import("./Terms-B_Dq2Sxv.js"), true ? __vite__mapDeps([202,1,2,43,17]) : void 0));
const Search = reactExports.lazy(() => __vitePreload(() => import("./Search-Pkp3W6Ce.js"), true ? __vite__mapDeps([203,1,2,43,47,17]) : void 0));
const EmptyPage = reactExports.lazy(() => __vitePreload(() => import("./EmptyPage-mSRujYcn.js"), true ? __vite__mapDeps([204,1,2,17]) : void 0));
const Error400 = reactExports.lazy(() => __vitePreload(() => import("./Error400-VZRkK1y5.js"), true ? __vite__mapDeps([205,1,2,17]) : void 0));
const Error401 = reactExports.lazy(() => __vitePreload(() => import("./Error401-Cky5slib.js"), true ? __vite__mapDeps([206,1,2,17]) : void 0));
const Error403 = reactExports.lazy(() => __vitePreload(() => import("./Error403-BDCAy-nJ.js"), true ? __vite__mapDeps([207,1,2,17]) : void 0));
const Error404 = reactExports.lazy(() => __vitePreload(() => import("./Error404-Cv01yE1n.js"), true ? __vite__mapDeps([208,1,2,17]) : void 0));
const Error500 = reactExports.lazy(() => __vitePreload(() => import("./Error500-BBux22QF.js"), true ? __vite__mapDeps([209,1,2,17]) : void 0));
const Error503 = reactExports.lazy(() => __vitePreload(() => import("./Error503-DZRgV-up.js"), true ? __vite__mapDeps([210,1,2,17]) : void 0));
const ComingSoon = reactExports.lazy(() => __vitePreload(() => import("./ComingSoon-CNZPOu7Q.js"), true ? __vite__mapDeps([211,1,2,17]) : void 0));
const UnderConstruction = reactExports.lazy(() => __vitePreload(() => import("./UnderConstruction-FXQCT9Ex.js"), true ? __vite__mapDeps([212,1,2,15,213,115,17]) : void 0));
const Login01 = reactExports.lazy(() => __vitePreload(() => import("./Login01-Dcrus_vt.js"), true ? __vite__mapDeps([214,1,2,115,17]) : void 0));
const Login02 = reactExports.lazy(() => __vitePreload(() => import("./Login02-y2hiNByG.js"), true ? __vite__mapDeps([215,1,2,115,17]) : void 0));
const Login03 = reactExports.lazy(() => __vitePreload(() => import("./Login03-BldAFyOk.js"), true ? __vite__mapDeps([216,1,2,115,217,17]) : void 0));
const Register03 = reactExports.lazy(() => __vitePreload(() => import("./Register03-CZAfUSHB.js"), true ? __vite__mapDeps([218,1,2,115,217,17]) : void 0));
const Register02 = reactExports.lazy(() => __vitePreload(() => import("./Register02-D8lDo_5h.js"), true ? __vite__mapDeps([219,1,2,15,115,17]) : void 0));
const Register01 = reactExports.lazy(() => __vitePreload(() => import("./Register01-HHmy_vuw.js"), true ? __vite__mapDeps([220,1,2,115,17]) : void 0));
const ForgetPassword02 = reactExports.lazy(() => __vitePreload(() => import("./ForgetPassword02-CtWVVgPQ.js"), true ? __vite__mapDeps([221,1,2,15,213,115,17]) : void 0));
const ForgetPassword01 = reactExports.lazy(() => __vitePreload(() => import("./ForgetPassword01-CVsA5fTv.js"), true ? __vite__mapDeps([222,1,2,115,17]) : void 0));
const ForgetPassword03 = reactExports.lazy(() => __vitePreload(() => import("./ForgetPassword03-9o-_rCwa.js"), true ? __vite__mapDeps([223,1,2,115,217,17]) : void 0));
const ResetPassword01 = reactExports.lazy(() => __vitePreload(() => import("./ResetPassword01-C9eobT38.js"), true ? __vite__mapDeps([224,1,2,115,17]) : void 0));
const ResetPassword02 = reactExports.lazy(() => __vitePreload(() => import("./ResetPassword02-BbBl7L27.js"), true ? __vite__mapDeps([225,1,2,213,15,115,17]) : void 0));
const ResetPassword03 = reactExports.lazy(() => __vitePreload(() => import("./ResetPassword03-8FPbup07.js"), true ? __vite__mapDeps([226,1,2,115,217,17]) : void 0));
const LockScreen03 = reactExports.lazy(() => __vitePreload(() => import("./LockScreen03-Cd-MeY3V.js"), true ? __vite__mapDeps([227,1,2,7,217,17]) : void 0));
const LockScreen02 = reactExports.lazy(() => __vitePreload(() => import("./LockScreen02-Jcj-gY1A.js"), true ? __vite__mapDeps([228,1,2,7,15,213,17]) : void 0));
const LockScreen01 = reactExports.lazy(() => __vitePreload(() => import("./LockScreen01-BrAYOA9H.js"), true ? __vite__mapDeps([229,1,2,7,17]) : void 0));
const Height = reactExports.lazy(() => __vitePreload(() => import("./Height-CrDGGAlJ.js"), true ? __vite__mapDeps([230,1,2,43,17]) : void 0));
const Width = reactExports.lazy(() => __vitePreload(() => import("./Width-CPncCxkB.js"), true ? __vite__mapDeps([231,1,2,43,17]) : void 0));
const Padding = reactExports.lazy(() => __vitePreload(() => import("./Padding-B48fzb2u.js"), true ? __vite__mapDeps([232,1,2,43,17]) : void 0));
const Typography = reactExports.lazy(() => __vitePreload(() => import("./Typography-BMFFTbyz.js"), true ? __vite__mapDeps([233,1,2,43,17]) : void 0));
const Margin = reactExports.lazy(() => __vitePreload(() => import("./Margin--rwYF9Qa.js"), true ? __vite__mapDeps([234,1,2,43,17]) : void 0));
const Colors = reactExports.lazy(() => __vitePreload(() => import("./Colors-CslkKQb5.js"), true ? __vite__mapDeps([235,1,2,43,17]) : void 0));
const Flexitems = reactExports.lazy(() => __vitePreload(() => import("./FlexItems-BJEcy1UI.js"), true ? __vite__mapDeps([236,1,2,43,17]) : void 0));
const Border = reactExports.lazy(() => __vitePreload(() => import("./Border-CZsfFy4z.js"), true ? __vite__mapDeps([237,1,2,43,17]) : void 0));
const Display = reactExports.lazy(() => __vitePreload(() => import("./Display-XEPMiAwv.js"), true ? __vite__mapDeps([238,1,2,43,17]) : void 0));
const TypiconsIcons = reactExports.lazy(() => __vitePreload(() => import("./TypiconsIcons-cpuPjfep.js"), true ? __vite__mapDeps([239,1,2,43,56,57,17]) : void 0));
const Sigup = reactExports.lazy(() => __vitePreload(() => import("./Signup-CpyQgd52.js"), true ? __vite__mapDeps([240,1,2,115,5,17]) : void 0));
const Auth = reactExports.lazy(() => __vitePreload(() => import("./Auth-C_xNB_SP.js"), true ? __vite__mapDeps([241,1,2,17]) : void 0));
const ForgetPassword = reactExports.lazy(() => __vitePreload(() => import("./ForgetPassword-k8qTzVfh.js"), true ? __vite__mapDeps([242,1,2,115,17]) : void 0));
const CreateGoal = reactExports.lazy(() => __vitePreload(() => import("./CreateGoal-BrpDJ129.js"), true ? __vite__mapDeps([243,1,2,43,47,17]) : void 0));
const GoalCategory = reactExports.lazy(() => __vitePreload(() => import("./GoalCategory-xpumh5FT.js"), true ? __vite__mapDeps([244,1,2,17]) : void 0));
const SetingsTools = reactExports.lazy(() => __vitePreload(() => import("./SettingsTools-yqBiaaF-.js"), true ? __vite__mapDeps([245,1,2,43,55,129,246,17,247,244]) : void 0));
const SetupManager = reactExports.lazy(() => __vitePreload(() => import("./Manager-YrR08pIe.js"), true ? __vite__mapDeps([248,1,2,43,17]) : void 0));
const PerformanceCriteria = reactExports.lazy(() => __vitePreload(() => import("./PerformanceCriteria-BLWmvIoq.js"), true ? __vite__mapDeps([246,1,2,17]) : void 0));
const PerformanceMetric = reactExports.lazy(() => __vitePreload(() => import("./PerformanceMetric-B2ZcsIJL.js"), true ? __vite__mapDeps([247,1,2,17]) : void 0));
const AppraisalRoutes = reactExports.lazy(() => __vitePreload(() => import("./AppraisalRoutes-CxOfozoG.js"), true ? __vite__mapDeps([249,1,2,17]) : void 0));
const BusinessGoal = reactExports.lazy(() => __vitePreload(() => import("./BusinessGoal-BgEQhA4i.js"), true ? __vite__mapDeps([250,1,2,43,47,17]) : void 0));
const AppraisalPeriod = reactExports.lazy(() => __vitePreload(() => import("./AppraisalPeriod-C3tc_ioJ.js"), true ? __vite__mapDeps([251,1,2,43,17]) : void 0));
const DeveloymentPlan = reactExports.lazy(() => __vitePreload(() => import("./DeveloymentPlan-D73NLB7c.js"), true ? __vite__mapDeps([252,1,2,43,17]) : void 0));
const CreateNewEmployee = reactExports.lazy(() => __vitePreload(() => import("./CreateNewEmployee-C1jjCW6P.js"), true ? __vite__mapDeps([253,1,2,43,17]) : void 0));
const EmployeeDetails = reactExports.lazy(() => __vitePreload(() => import("./EmployeeDetails-CQsp6Bi2.js"), true ? __vite__mapDeps([254,1,2,43,21,17]) : void 0));
const EmployeeProfile = reactExports.lazy(() => __vitePreload(() => import("./EmployeeProfile-C-0XJSc9.js"), true ? __vite__mapDeps([255,1,2,31,43,47,7,17]) : void 0));
const FeedBack = reactExports.lazy(() => __vitePreload(() => import("./FeedBack-DkuhBsmx.js"), true ? __vite__mapDeps([256,1,2,43,17]) : void 0));
const FeedBackDetails = reactExports.lazy(() => __vitePreload(() => import("./FeedBackDetails-jAYV0Cnb.js"), true ? __vite__mapDeps([257,1,2,43,17]) : void 0));
const GoalApproval = reactExports.lazy(() => __vitePreload(() => import("./GoalApproval-BmpVOdHy.js"), true ? __vite__mapDeps([258,1,2,43,17]) : void 0));
const GoalTracking = reactExports.lazy(() => __vitePreload(() => import("./GoalTracking-DXlmcfi7.js"), true ? __vite__mapDeps([259,1,2,43,17]) : void 0));
const CreateBulkUsers = reactExports.lazy(() => __vitePreload(() => import("./CreateBulkUsers-g3QriRRP.js"), true ? __vite__mapDeps([260,1,2,43,110,17,261]) : void 0));
const Login = reactExports.lazy(() => __vitePreload(() => import("./Login-uEOzC-Rv.js"), true ? __vite__mapDeps([262,1,2,115,17]) : void 0));
const Routing = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AuthProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(React$1.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(Loader, {}), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(Auth, {}), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Login, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Login", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Login, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Auth/Signup/Signup", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Sigup, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "account/forgetpassword", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ForgetPassword, {}) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "role-switcher", element: /* @__PURE__ */ jsxRuntimeExports.jsx(RoleSwitcher, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "dashboard/dashboard01", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "dashboard/dashboard02", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard2, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "dashboard/dashboard03", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard3, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "dashboard/dashboard04", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard4, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "dashboard/dashboard05", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard5, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "performance-manager/*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PerformanceAssessment, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "360-degree-appraisal/*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AppraisalRoutes, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "appraisal/selfassessment", element: /* @__PURE__ */ jsxRuntimeExports.jsx(SelfAssessment, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "employee/profile", element: /* @__PURE__ */ jsxRuntimeExports.jsx(EmployeeProfile, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "employee/details", element: /* @__PURE__ */ jsxRuntimeExports.jsx(EmployeeDetails, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "survey-manager/*", element: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Survey Manager" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Survey functionality is coming soon." })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "report-manager/*", element: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Report Manager" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Report functionality is coming soon." })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "tools/*", element: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Tools Dashboard" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Tools functionality is coming soon." })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Goal/Configuration", element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateGoal, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Goal/Category", element: /* @__PURE__ */ jsxRuntimeExports.jsx(GoalCategory, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Tools/Settings", element: /* @__PURE__ */ jsxRuntimeExports.jsx(SetingsTools, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Setup/Manager", element: /* @__PURE__ */ jsxRuntimeExports.jsx(SetupManager, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "performance/criteria", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PerformanceCriteria, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "performance/metric", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PerformanceMetric, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "business/goal", element: /* @__PURE__ */ jsxRuntimeExports.jsx(BusinessGoal, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "appraisal/period", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AppraisalPeriod, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "develoyment/plan", element: /* @__PURE__ */ jsxRuntimeExports.jsx(DeveloymentPlan, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "employee/create", element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateNewEmployee, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "employee/list", element: /* @__PURE__ */ jsxRuntimeExports.jsx(EmployeeDetails, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "employee/profile", element: /* @__PURE__ */ jsxRuntimeExports.jsx(EmployeeProfile, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "feed/back", element: /* @__PURE__ */ jsxRuntimeExports.jsx(FeedBack, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "feed/details", element: /* @__PURE__ */ jsxRuntimeExports.jsx(FeedBackDetails, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "goal/approval", element: /* @__PURE__ */ jsxRuntimeExports.jsx(GoalApproval, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "goal/tracking", element: /* @__PURE__ */ jsxRuntimeExports.jsx(GoalTracking, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { allowedRoles: ["admin", "manager", "employee"] }), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "create/bulkusers", element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateBulkUsers, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "appraisal-configurations", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AppraisalConfiguration, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "performance-assessment/:configId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PerformanceAssessment, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "performance-assessment", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PerformanceAssessment, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "assessment/:configId/self/current", element: /* @__PURE__ */ jsxRuntimeExports.jsx(SelfAssessment, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "assessment/continue/:assessmentId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(SelfAssessment, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "assessment-selection", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AssessmentSelection, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "assessment/:configId/manager/select", element: /* @__PURE__ */ jsxRuntimeExports.jsx(EmployeeSelector, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "assessment/:configId/manager/:employeeId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ManagerAssessment, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "peer-assessment", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PeerAssessment, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "assessment/:configId/peer/select", element: /* @__PURE__ */ jsxRuntimeExports.jsx(EmployeeSelector, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "assessment/:configId/peer/:peerId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PeerAssessment, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "assessment/:configId/subordinate/select", element: /* @__PURE__ */ jsxRuntimeExports.jsx(EmployeeSelector, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "assessment/:configId/subordinate/:managerId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(SubordinateAssessment, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/assessment/view/:assessmentId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PerformanceAssessment, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "widgets/chartwidgets", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartWidgets, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "forms/formelements", element: /* @__PURE__ */ jsxRuntimeExports.jsx(FormElements, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "forms/advancedforms", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AdvancedForms, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "forms/formwizard", element: /* @__PURE__ */ jsxRuntimeExports.jsx(FormWizard, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "forms/formedit", element: /* @__PURE__ */ jsxRuntimeExports.jsx(FormEdit, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "forms/formelementsizes",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(FormElementSizes, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "forms/formtreeview", element: /* @__PURE__ */ jsxRuntimeExports.jsx(FormTreeView, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "charts/apexcharts/area", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Area, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "charts/apexcharts/bar", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "charts/apexcharts/line", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "charts/apexcharts/column", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Column, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "charts/apexcharts/mixed", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Mixed, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "charts/chartjs", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Chartjs, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "charts/echart", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Echart, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "tables/defaulttable", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Defaulttable, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "tables/datatable", element: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTable, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/accordion", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Accordion, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/alerts", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Alerts, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/avatars", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatars, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/badges", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Badges, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/breadcrumb", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Breadcrumb, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/buttons", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/cards", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Cards, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/cardimages", element: /* @__PURE__ */ jsxRuntimeExports.jsx(CardImages, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/Carousel", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Carousel, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/dropdown", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Dropdown, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/footers", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Footers, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/headers", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/list", element: /* @__PURE__ */ jsxRuntimeExports.jsx(List, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/mediaobject", element: /* @__PURE__ */ jsxRuntimeExports.jsx(MediaObject, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/modal", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Modal, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/navigation", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Navigation, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/pagination", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Pagination, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/panel", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Panel, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/popover", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Popover, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/progress", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Progress, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/tabs", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/tags", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Tags, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "elements/tooltips", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltips, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "icons/fontawesome", element: /* @__PURE__ */ jsxRuntimeExports.jsx(FontAwesome, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "icons/materialdesignicons",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(MaterialDesignIcons, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "icons/simplelineicons",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleLineIcons, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "icons/feathericons", element: /* @__PURE__ */ jsxRuntimeExports.jsx(FeatherIcons, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "icons/ionicicons", element: /* @__PURE__ */ jsxRuntimeExports.jsx(IonicIcons, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "icons/flagicons", element: /* @__PURE__ */ jsxRuntimeExports.jsx(FlagIcons, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "icons/pe7icons", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Pe7Icons, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "icons/themifyicons", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemifyIcons, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "icons/typiconsicons", element: /* @__PURE__ */ jsxRuntimeExports.jsx(TypiconsIcons, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "icons/weathericons", element: /* @__PURE__ */ jsxRuntimeExports.jsx(WeatherIcons, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "icons/materialicons", element: /* @__PURE__ */ jsxRuntimeExports.jsx(MaterialIcons, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "icons/bootstrap5svgicons",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(Bootstrap5SVGIcons, {})
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/profile/profile01", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Profile01, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/profile/profile02", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Profile02, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/profile/profile03", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Profile03, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/aboutus", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AboutUs, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/editprofile", element: /* @__PURE__ */ jsxRuntimeExports.jsx(EditProfile, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/settings", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Settings, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "pages/email/emailcompose",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(EmailCompose, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/email/emailinbox", element: /* @__PURE__ */ jsxRuntimeExports.jsx(EmailInbox, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/email/emailread", element: /* @__PURE__ */ jsxRuntimeExports.jsx(EmailRead, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/pricing/pricing01", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Pricing01, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/pricing/pricing02", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Pricing02, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/pricing/pricing03", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Pricing03, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "pages/invoice/invoicelist",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(Invoicelist, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/invoice/invoice01", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Invoice01, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/invoice/invoice02", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Invoice02, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/invoice/invoice03", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Invoice03, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/invoice/addinvoice", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AddInvoice, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "pages/invoice/editinvoice",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(EditInvoice, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/blog/blog01", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Blog01, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/blog/blog02", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Blog02, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/blog/blog03", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Blog03, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/blog/blogstyles", element: /* @__PURE__ */ jsxRuntimeExports.jsx(BlogStyles, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/blog/blogpost", element: /* @__PURE__ */ jsxRuntimeExports.jsx(BlogPost, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/ecommerce/products", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Products, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "pages/ecommerce/productdetails",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProductDetails, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/ecommerce/productdetails/:id", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProductDetails, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "pages/ecommerce/shoppingcart",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(ShoppingCart, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/ecommerce/checkout", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkout, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/ecommerce/wishlist", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Wishlist, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/gallery", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Gallery, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/faqs", element: /* @__PURE__ */ jsxRuntimeExports.jsx(FAQS, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/terms", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Terms, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/search", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Search, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "utilities/color", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Colors, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "utilities/flexitems", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Flexitems, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "utilities/height", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Height, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "utilities/border", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Border, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "utilities/display", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Display, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "utilities/margin", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Margin, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "utilities/padding", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Padding, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "utilities/typography", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "utilities/width", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Width, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/emptypage", element: /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyPage, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "appraisal/*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AppraisalRoutes, {}) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Custompages, {}), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "errorpages/error400", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Error400, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "errorpages/error401", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Error401, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "errorpages/error403", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Error403, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "errorpages/error404", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Error404, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "errorpages/error500", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Error500, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "errorpages/error503", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Error503, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "account/comingsoon", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ComingSoon, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "account/underconstruction",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(UnderConstruction, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "account/login/login01", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Login01, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "account/login/login02", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Login02, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "account/login/login03", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Login03, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "account/register/register01", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Register01, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "account/register/register02", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Register02, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "account/register/register03", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Register03, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "account/forgetpassword/forgetpassword01",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(ForgetPassword01, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "account/forgetpassword/forgetpassword02",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(ForgetPassword02, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "account/forgetpassword/forgetpassword03",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(ForgetPassword03, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "account/resetpassword/resetpassword01",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPassword01, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "account/resetpassword/resetpassword02",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPassword02, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "account/resetpassword/resetpassword03",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPassword03, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "account/lockscreen/lockscreen01",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(LockScreen01, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "account/lockscreen/lockscreen02",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(LockScreen02, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "account/lockscreen/lockscreen03",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(LockScreen03, {})
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pages/switcher", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Switcherapp, {}) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/", replace: true }) })
  ] }) }) }) });
};
const basename = "/apps/nsh/";
{
  __vitePreload(() => Promise.resolve().then(() => seedHelper$1), true ? void 0 : void 0).then((seedHelper2) => {
    window.seedDemoData = seedHelper2.seedDemoData;
    window.seedGoalWorkflowTestData = seedHelper2.seedGoalWorkflowTestData;
    window.seedSurveyManagerTestData = seedHelper2.seedSurveyManagerTestData;
    window.seedReportManagerTestData = seedHelper2.seedReportManagerTestData;
    window.seedEmpmanTestData = seedHelper2.seedEmpmanTestData;
    window.seedLoginAdminTestData = seedHelper2.seedLoginAdminTestData;
    window.clearTestData = seedHelper2.clearTestData;
    window.testFixtures = seedHelper2.testFixtures;
    console.log("[NSHRM] Dev seeding utilities loaded. Available commands:");
    console.log("  await window.seedDemoData()           - Seed ALL demo data");
    console.log("  await window.seedGoalWorkflowTestData() - Seed goal workflow");
    console.log("  await window.seedSurveyManagerTestData() - Seed survey data");
    console.log("  await window.seedReportManagerTestData() - Seed report data");
    console.log("  await window.clearTestData()          - Clear localStorage");
    console.log("  window.testFixtures                   - View all test fixtures");
  }).catch((err) => {
    console.warn("[NSHRM] Dev seeding utilities not available:", err.message);
  });
}
ReactDOM.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React$1.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Provider_default, { store, children: [
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { basename, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Routing, {}) })
  ] }) })
);
export {
  TransitionTimeouts as $,
  APIServices2 as A,
  Button$1 as B,
  Col as C,
  DropdownMenu as D,
  requireClassnames as E,
  Form as F,
  Pagination$1 as G,
  PaginationItem as H,
  Input as I,
  PaginationLink as J,
  Modaluser as K,
  Label as L,
  MenuProvider as M,
  NavLink as N,
  Outlet as O,
  Provider_default as P,
  __assign as Q,
  Row as R,
  Swal as S,
  Table as T,
  __rest as U,
  omit as V,
  DropdownContext as W,
  Dropdown$1 as X,
  pick as Y,
  TransitionPropTypeKeys as Z,
  __extends as _,
  useNavigate as a,
  TransitionStatuses as a0,
  addDefaultProps as a1,
  Fade as a2,
  DOMElement as a3,
  targetPropType as a4,
  getTarget as a5,
  Popper as a6,
  PopperPlacements as a7,
  DatePicker as a8,
  InputGroupContext as a9,
  __awaiter as aa,
  __generator as ab,
  Badge as ac,
  Breadcrumb$1 as ad,
  BreadcrumbItem as ae,
  connect_default as af,
  useParams as ag,
  useSearchParams as ah,
  Routes as ai,
  Route as aj,
  AppraisalConfiguration as ak,
  PerformanceAssessment as al,
  SelfAssessment as am,
  EmployeeSelector as an,
  ManagerAssessment as ao,
  PeerAssessment as ap,
  SubordinateAssessment as aq,
  useAuth as ar,
  Link as b,
  DropdownToggle as c,
  useMenu as d,
  AuthProvider as e,
  PageHeaders as f,
  Card as g,
  CardBody as h,
  classnames as i,
  configureStore as j,
  useDispatch as k,
  ServiceFactory as l,
  mapToCssModules as m,
  CardHeader as n,
  Spinner as o,
  Alert as p,
  PageHeader as q,
  Progress$1 as r,
  PageHeaderstyle as s,
  tagPropType as t,
  useLocation as u,
  Modal$1 as v,
  ModalHeader as w,
  ModalBody as x,
  ModalFooter as y,
  FormGroup as z
};
